<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Format&#39;s Notes</title>
  <subtitle>吃饭睡觉撸代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fangjian0423.github.io/"/>
  <updated>2017-05-31T13:53:46.000Z</updated>
  <id>http://fangjian0423.github.io/</id>
  
  <author>
    <name>Format</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot源码分析之SpringBoot可执行文件解析</title>
    <link href="http://fangjian0423.github.io/2017/05/31/springboot-executable-jar/"/>
    <id>http://fangjian0423.github.io/2017/05/31/springboot-executable-jar/</id>
    <published>2017-05-31T12:33:33.000Z</published>
    <updated>2017-05-31T13:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。在pom文件里加入这个插件即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<p>打包完生成的executable-jar-1.0-SNAPSHOT.jar内部的结构如下：</p>
<pre><code>├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── spring.study
│           └── executable-jar
│               ├── pom.properties
│               └── pom.xml
├── lib
│   ├── aopalliance-1.0.jar
│   ├── classmate-1.1.0.jar
│   ├── spring-boot-1.3.5.RELEASE.jar
│   ├── spring-boot-autoconfigure-1.3.5.RELEASE.jar
│   ├── ...
├── org
│   └── springframework
│       └── boot
│           └── loader
│               ├── ExecutableArchiveLauncher$1.class
│               ├── ...
└── spring
    └── study
        └── executablejar
            └── ExecutableJarApplication.class
</code></pre><p>然后可以直接执行jar包就能启动程序了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar executable-jar-1.0-SNAPSHOT.jar</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>打包出来fat jar内部有4种文件类型：</p>
<ol>
<li>META-INF文件夹：程序入口，其中MANIFEST.MF用于描述jar包的信息</li>
<li>lib目录：放置第三方依赖的jar包，比如springboot的一些jar包</li>
<li>spring boot loader相关的代码</li>
<li>模块自身的代码</li>
</ol>
<p>MANIFEST.MF文件的内容：</p>
<pre><code>Manifest-Version: 1.0
Implementation-Title: executable-jar
Implementation-Version: 1.0-SNAPSHOT
Archiver-Version: Plexus Archiver
Built-By: Format
Start-Class: spring.study.executablejar.ExecutableJarApplication
Implementation-Vendor-Id: spring.study
Spring-Boot-Version: 1.3.5.RELEASE
Created-By: Apache Maven 3.2.3
Build-Jdk: 1.8.0_20
Implementation-Vendor: Pivotal Software, Inc.
Main-Class: org.springframework.boot.loader.JarLauncher
</code></pre><p>我们看到，它的Main-Class是org.springframework.boot.loader.JarLauncher，当我们使用java -jar执行jar包的时候会调用JarLauncher的main方法，而不是我们编写的SpringApplication。</p>
<p>那么JarLauncher这个类是的作用是什么的？</p>
<p>它是SpringBoot内部提供的工具Spring Boot Loader提供的一个用于执行Application类的工具类(fat jar内部有spring loader相关的代码就是因为这里用到了)。相当于Spring Boot Loader提供了一套标准用于执行SpringBoot打包出来的jar</p>
<h2 id="Spring-Boot-Loader抽象的一些类"><a href="#Spring-Boot-Loader抽象的一些类" class="headerlink" title="Spring Boot Loader抽象的一些类"></a>Spring Boot Loader抽象的一些类</h2><p>抽象类Launcher：各种Launcher的基础抽象类，用于启动应用程序；跟Archive配合使用；目前有3种实现，分别是JarLauncher、WarLauncher以及PropertiesLauncher</p>
<p>Archive：归档文件的基础抽象类。JarFileArchive就是jar包文件的抽象。它提供了一些方法比如getUrl会返回这个Archive对应的URL；getManifest方法会获得Manifest数据等。ExplodedArchive是文件目录的抽象</p>
<p>JarFile：对jar包的封装，每个JarFileArchive都会对应一个JarFile。JarFile被构造的时候会解析内部结构，去获取jar包里的各个文件或文件夹，这些文件或文件夹会被封装到Entry中，也存储在JarFileArchive中。如果Entry是个jar，会解析成JarFileArchive。</p>
<p>比如一个JarFileArchive对应的URL为：</p>
<pre><code>jar:file:/Users/format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/
</code></pre><p>它对应的JarFile为：</p>
<pre><code>/Users/format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar
</code></pre><p>这个JarFile有很多Entry，比如：</p>
<pre><code>META-INF/
META-INF/MANIFEST.MF
spring/
spring/study/
....
spring/study/executablejar/ExecutableJarApplication.class
lib/spring-boot-starter-1.3.5.RELEASE.jar
lib/spring-boot-1.3.5.RELEASE.jar
...
</code></pre><p>JarFileArchive内部的一些依赖jar对应的URL(SpringBoot使用org.springframework.boot.loader.jar.Handler处理器来处理这些URL)：</p>
<pre><code>jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-starter-web-1.3.5.RELEASE.jar!/

jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class
</code></pre><p>我们看到如果有jar包中包含jar，或者jar包中包含jar包里面的class文件，那么会使用 <strong>!/</strong> 分隔开，这种方式只有org.springframework.boot.loader.jar.Handler能处理，它是SpringBoot内部扩展出来的一种URL协议。</p>
<h2 id="JarLauncher的执行过程"><a href="#JarLauncher的执行过程" class="headerlink" title="JarLauncher的执行过程"></a>JarLauncher的执行过程</h2><p>JarLauncher的main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造JarLauncher，然后调用它的launch方法。参数是控制台传递的</span></div><div class="line">    <span class="keyword">new</span> JarLauncher().launch(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JarLauncher被构造的时候会调用父类ExecutableArchiveLauncher的构造方法。</p>
<p>ExecutableArchiveLauncher的构造方法内部会去构造Archive，这里构造了JarFileArchive。构造JarFileArchive的过程中还会构造很多东西，比如JarFile，Entry …</p>
<p>JarLauncher的launch方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 在系统属性中设置注册了自定义的URL处理器：org.springframework.boot.loader.jar.Handler。如果URL中没有指定处理器，会去系统属性中查询</span></div><div class="line">    JarFile.registerUrlProtocolHandler();</div><div class="line">    <span class="comment">// getClassPathArchives方法在会去找lib目录下对应的第三方依赖JarFileArchive，同时也会项目自身的JarFileArchive</span></div><div class="line">    <span class="comment">// 根据getClassPathArchives得到的JarFileArchive集合去创建类加载器ClassLoader。这里会构造一个LaunchedURLClassLoader类加载器，这个类加载器继承URLClassLoader，并使用这些JarFileArchive集合的URL构造成URLClassPath</span></div><div class="line">    <span class="comment">// LaunchedURLClassLoader类加载器的父类加载器是当前执行类JarLauncher的类加载器</span></div><div class="line">    ClassLoader classLoader = createClassLoader(getClassPathArchives());</div><div class="line">    <span class="comment">// getMainClass方法会去项目自身的Archive中的Manifest中找出key为Start-Class的类</span></div><div class="line">    <span class="comment">// 调用重载方法launch</span></div><div class="line">    launch(args, getMainClass(), classLoader);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    ex.printStackTrace();</div><div class="line">    System.exit(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Archive的getMainClass方法</span></div><div class="line"><span class="comment">// 这里会找出spring.study.executablejar.ExecutableJarApplication这个类</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMainClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	Manifest manifest = getManifest();</div><div class="line">	String mainClass = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span> (manifest != <span class="keyword">null</span>) &#123;</div><div class="line">		mainClass = manifest.getMainAttributes().getValue(<span class="string">"Start-Class"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (mainClass == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">				<span class="string">"No 'Start-Class' manifest entry specified in "</span> + <span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mainClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// launch重载方法</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span></span></div><div class="line">		<span class="keyword">throws</span> Exception &#123;</div><div class="line">      <span class="comment">// 创建一个MainMethodRunner，并把args和Start-Class传递给它</span></div><div class="line">	Runnable runner = createMainMethodRunner(mainClass, args, classLoader);</div><div class="line">      <span class="comment">// 构造新线程</span></div><div class="line">	Thread runnerThread = <span class="keyword">new</span> Thread(runner);</div><div class="line">      <span class="comment">// 线程设置类加载器以及名字，然后启动</span></div><div class="line">	runnerThread.setContextClassLoader(classLoader);</div><div class="line">	runnerThread.setName(Thread.currentThread().getName());</div><div class="line">	runnerThread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MainMethodRunner的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 根据Start-Class进行实例化</span></div><div class="line">    Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</div><div class="line">        .loadClass(<span class="keyword">this</span>.mainClassName);</div><div class="line">    <span class="comment">// 找出main方法</span></div><div class="line">    Method mainMethod = mainClass.getDeclaredMethod(<span class="string">"main"</span>, String[].class);</div><div class="line">    <span class="comment">// 如果main方法不存在，抛出异常</span></div><div class="line">    <span class="keyword">if</span> (mainMethod == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">          <span class="keyword">this</span>.mainClassName + <span class="string">" does not have a main method"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 调用</span></div><div class="line">    mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    UncaughtExceptionHandler handler = Thread.currentThread()</div><div class="line">        .getUncaughtExceptionHandler();</div><div class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">      handler.uncaughtException(Thread.currentThread(), ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Start-Class的main方法调用之后，内部会构造Spring容器，启动内置Servlet容器等过程。 这些过程我们都已经分析过了。</p>
<h2 id="关于自定义的类加载器LaunchedURLClassLoader"><a href="#关于自定义的类加载器LaunchedURLClassLoader" class="headerlink" title="关于自定义的类加载器LaunchedURLClassLoader"></a>关于自定义的类加载器LaunchedURLClassLoader</h2><p>LaunchedURLClassLoader重写了loadClass方法，也就是说它修改了默认的类加载方式(先看该类是否已加载这部分不变，后面真正去加载类的规则改变了，不再是直接从父类加载器中去加载)。LaunchedURLClassLoader定义了自己的类加载规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Class&lt;?&gt; doLoadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 1) Try the root class loader</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rootClassLoader != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.rootClassLoader.loadClass(name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    <span class="comment">// Ignore and continue</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 2) Try to find locally</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    findPackage(name);</div><div class="line">    Class&lt;?&gt; cls = findClass(name);</div><div class="line">    <span class="keyword">return</span> cls;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    <span class="comment">// Ignore and continue</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 3) Use standard loading</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载规则：</p>
<ol>
<li>如果根类加载器存在，调用它的加载方法。这里是根类加载是ExtClassLoader</li>
<li>调用LaunchedURLClassLoader自身的findClass方法，也就是URLClassLoader的findClass方法</li>
<li>调用父类的loadClass方法，也就是执行默认的类加载顺序(从BootstrapClassLoader开始从下往下寻找)</li>
</ol>
<p>LaunchedURLClassLoader自身的findClass方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</div><div class="line">     <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</div><div class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                    <span class="comment">// 把类名解析成路径并加上.class后缀</span></div><div class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</div><div class="line">                    <span class="comment">// 基于之前得到的第三方jar包依赖以及自己的jar包得到URL数组，进行遍历找出对应类名的资源</span></div><div class="line">                    <span class="comment">// 比如path是org/springframework/boot/loader/JarLauncher.class，它在jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/中被找出</span></div><div class="line">                    <span class="comment">// 那么找出的资源对应的URL为jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class</span></div><div class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123; <span class="comment">// 找到了资源</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            <span class="keyword">return</span> defineClass(name, res);</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找不到资源的话直接抛出ClassNotFoundException异常</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, acc);</div><div class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</div><div class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是LaunchedURLClassLoader的一个测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册org.springframework.boot.loader.jar.Handler URL协议处理器</span></div><div class="line">JarFile.registerUrlProtocolHandler();</div><div class="line"><span class="comment">// 构造LaunchedURLClassLoader类加载器，这里使用了2个URL，分别对应jar包中依赖包spring-boot-loader和spring-boot，使用 "!/" 分开，需要org.springframework.boot.loader.jar.Handler处理器处理</span></div><div class="line">LaunchedURLClassLoader classLoader = <span class="keyword">new</span> LaunchedURLClassLoader(</div><div class="line">        <span class="keyword">new</span> URL[] &#123;</div><div class="line">                <span class="keyword">new</span> URL(<span class="string">"jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/"</span>)</div><div class="line">                , <span class="keyword">new</span> URL(<span class="string">"jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-1.3.5.RELEASE.jar!/"</span>)</div><div class="line">        &#125;,</div><div class="line">        LaunchedURLClassLoaderTest.class.getClassLoader());</div><div class="line"></div><div class="line"><span class="comment">// 加载类</span></div><div class="line"><span class="comment">// 这2个类都会在第二步本地查找中被找出(URLClassLoader的findClass方法)</span></div><div class="line">classLoader.loadClass(<span class="string">"org.springframework.boot.loader.JarLauncher"</span>);</div><div class="line">classLoader.loadClass(<span class="string">"org.springframework.boot.SpringApplication"</span>);</div><div class="line"><span class="comment">// 在第三步使用默认的加载顺序在ApplicationClassLoader中被找出</span></div><div class="line">classLoader.loadClass(<span class="string">"org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration"</span>);</div></pre></td></tr></table></figure>
<h2 id="Spring-Boot-Loader的作用"><a href="#Spring-Boot-Loader的作用" class="headerlink" title="Spring Boot Loader的作用"></a>Spring Boot Loader的作用</h2><p>SpringBoot在可执行jar包中定义了自己的一套规则，比如第三方依赖jar包在/lib目录下，jar包的URL路径使用自定义的规则并且这个规则需要使用org.springframework.boot.loader.jar.Handler处理器处理。它的Main-Class使用JarLauncher，如果是war包，使用WarLauncher执行。这些Launcher内部都会另起一个线程启动自定义的SpringApplication类。</p>
<p>这些特性通过spring-boot-maven-plugin插件打包完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。在pom文件里加入这个插件即可：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打包完生成的executable-jar-1.0-SNAPSHOT.jar内部的结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── spring.study
│           └── executable-jar
│               ├── pom.properties
│               └── pom.xml
├── lib
│   ├── aopalliance-1.0.jar
│   ├── classmate-1.1.0.jar
│   ├── spring-boot-1.3.5.RELEASE.jar
│   ├── spring-boot-autoconfigure-1.3.5.RELEASE.jar
│   ├── ...
├── org
│   └── springframework
│       └── boot
│           └── loader
│               ├── ExecutableArchiveLauncher$1.class
│               ├── ...
└── spring
    └── study
        └── executablejar
            └── ExecutableJarApplication.class
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后可以直接执行jar包就能启动程序了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;java -jar executable-jar-1.0-SNAPSHOT.jar&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringData ES 关于字段名和索引中的列名字不一致导致的查询问题</title>
    <link href="http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/"/>
    <id>http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/</id>
    <published>2017-05-23T16:33:33.000Z</published>
    <updated>2017-05-31T13:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中使用了<a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="external">Spring Data Elasticsearch</a>。发生它存在一个问题：</p>
<p><strong>Document对应的POJO的属性跟es里面文档的字段名字不一样，这样Repository里面编写自定义的查询方法就会查询不出结果。</strong></p>
<p>比如有个Person类，它有2个属性goodFace和goodAt。这2个属性在es的索引里对应的字段表为good_face和good_at：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Document</span>(replicas = <span class="number">1</span>, shards = <span class="number">1</span>, type = <span class="string">"person"</span>, indexName = <span class="string">"person"</span>)</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="meta">@Setter</span></div><div class="line"><span class="meta">@JsonNaming</span>(PropertyNamingStrategy.SnakeCaseStrategy.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="keyword">private</span> String id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> goodFace;</div><div class="line">    <span class="keyword">private</span> String goodAt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Repository中的自定义查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByGoodFace</span><span class="params">(<span class="keyword">boolean</span> isGoodFace)</span></span>;</div><div class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法findByGoodFace是查询不出结果的，而findByName是ok的。</p>
<p>为什么findByGoodFace不行而findByName可以呢，来探究一下。</p>
<a id="more"></a>
<p>Person类的name属性跟ES中的字段名是一模一样的，而goodFace字段在ES中的字段是good_face(因为我们使用了SnakeCaseStrategy策略)。</p>
<p>所以产生这个问题的原因在于ES中文档的字段名跟POJO中的字段名不统一造成的。</p>
<p><strong>但是我们使用PersonRepository的save方法保存文档的时候属性和字段是可以对上的。</strong></p>
<p>那为什么使用repository的save方法能对应上文档和字段，而自定义的find方法却不行呢？</p>
<p>ES是使用<a href="https://github.com/FasterXML/jackson" target="_blank" rel="external">jackson</a>来完成POJO到json的映射关系的。</p>
<p>在Person类上使用@JsonNaming注解完成POJO和json的映射，我们使用了SnakeCaseStrategy策略，这个策略会把属性从驼峰方式改成小写带下划线的方式。</p>
<p>比如goodAt属性映射的时候就会变成good_at，good_face变成good_face，name变成name。</p>
<p>Spring Data Elasticsearch把对ES的操作封装成了一个ElasticsearchOperations接口。比如queryForObject、queryForPage、count、queryForList方法。</p>
<p>ElasticsearchOperations接口目前有一个实现类ElasticsearchTemplate。</p>
<p>ElasticsearchTemplate内部有个ResultsMapper属性，这个ResultsMapper目前只有一个实现类DefaultResultMapper，DefaultResultMapper内部使用DefaultEntityMapper完成映射。DefaultEntityMapper是个EntityMapper接口的实现类，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityMapper</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">mapToString</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">mapToObject</span><span class="params">(String source, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法很明白：对象到json字符串的转换和json字符串倒对象的转换。</p>
<p>DefaultEntityMapper内部使用jackson的ObjectMapper完成。</p>
<p>自定义的Repository继承自ElasticsearchRepository，最后会使用代理映射成SimpleElasticsearchRepository。</p>
<p>SimpleElasticsearchRepository内部有个属性ElasticsearchOperations用于完成与ES的交互。</p>
<p>我们看下SimpleElasticsearchRepository的save方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</div><div class="line">  Assert.notNull(entity, <span class="string">"Cannot save 'null' entity."</span>);</div><div class="line">  <span class="comment">// createIndexQuery方法会构造一个IndexQuery，然后调用ElasticsearchOperations的index方法</span></div><div class="line">  elasticsearchOperations.index(createIndexQuery(entity));</div><div class="line">  elasticsearchOperations.refresh(entityInformation.getIndexName());</div><div class="line">  <span class="keyword">return</span> entity;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ElasticsearchTemplate的index方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(IndexQuery query)</span> </span>&#123;</div><div class="line">      <span class="comment">// 调用prepareIndex方法构造一个IndexRequestBuilder</span></div><div class="line">	String documentId = prepareIndex(query).execute().actionGet().getId();</div><div class="line">	<span class="comment">// 设置保存文档的id</span></div><div class="line">	<span class="keyword">if</span> (query.getObject() != <span class="keyword">null</span>) &#123;</div><div class="line">		setPersistentEntityId(query.getObject(), documentId);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> documentId;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> IndexRequestBuilder <span class="title">prepareIndex</span><span class="params">(IndexQuery query)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">// 从@Document注解中得到索引的名字</span></div><div class="line">		String indexName = isBlank(query.getIndexName()) ? retrieveIndexNameFromPersistentEntity(query.getObject()</div><div class="line">				.getClass())[<span class="number">0</span>] : query.getIndexName();</div><div class="line">              <span class="comment">// 从@Document注解中得到索引的类型</span></div><div class="line">		String type = isBlank(query.getType()) ? retrieveTypeFromPersistentEntity(query.getObject().getClass())[<span class="number">0</span>]</div><div class="line">				: query.getType();</div><div class="line"></div><div class="line">		IndexRequestBuilder indexRequestBuilder = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (query.getObject() != <span class="keyword">null</span>) &#123; <span class="comment">// save方法这里保存的object就是POJO</span></div><div class="line">            <span class="comment">// 得到id字段</span></div><div class="line">			String id = isBlank(query.getId()) ? getPersistentEntityId(query.getObject()) : query.getId();</div><div class="line">			<span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123; <span class="comment">// 如果设置了id字段</span></div><div class="line">				indexRequestBuilder = client.prepareIndex(indexName, type, id);</div><div class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有设置id字段</span></div><div class="line">				indexRequestBuilder = client.prepareIndex(indexName, type);</div><div class="line">			&#125;</div><div class="line">            <span class="comment">// 使用ResultsMapper映射POJO到json字符串</span></div><div class="line">			indexRequestBuilder.setSource(resultsMapper.getEntityMapper().mapToString(query.getObject()));</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.getSource() != <span class="keyword">null</span>) &#123; <span class="comment">// 如果自定义了source属性，直接赋值</span></div><div class="line">			indexRequestBuilder = client.prepareIndex(indexName, type, query.getId()).setSource(query.getSource());</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有设置object属性或者source属性，抛出ElasticsearchException异常</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchException(<span class="string">"object or source is null, failed to index the document [id: "</span> + query.getId() + <span class="string">"]"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (query.getVersion() != <span class="keyword">null</span>) &#123; <span class="comment">// 设置版本</span></div><div class="line">			indexRequestBuilder.setVersion(query.getVersion());</div><div class="line">			indexRequestBuilder.setVersionType(EXTERNAL);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (query.getParentId() != <span class="keyword">null</span>) &#123; <span class="comment">// 设置parentId</span></div><div class="line">			indexRequestBuilder.setParent(query.getParentId());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> indexRequestBuilder;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchException(<span class="string">"failed to index the document [id: "</span> + query.getId() + <span class="string">"]"</span>, e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>save方法使用ResultsMapper完成了POJO到json的转换，所以save方法保存成功对应的文档数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">indexRequestBuilder.setSource(resultsMapper.getEntityMapper().mapToString(query.getObject()));</div></pre></td></tr></table></figure>
<p>自定义的findByGoodFace方法：</p>
<p>由于是Repository中的自定义方法，会被Spring Data通过代理进行构造，内部还是用了AOP，最终在QueryExecutorMethodInterceptor中并解析成ElasticsearchPartQuery这个RepositoryQuery接口的实现类，然后调用execute方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(Object[] parameters)</span> </span>&#123;</div><div class="line">  ParametersParameterAccessor accessor = <span class="keyword">new</span> ParametersParameterAccessor(queryMethod.getParameters(), parameters);</div><div class="line">  CriteriaQuery query = createQuery(accessor);</div><div class="line">  <span class="keyword">if</span>(tree.isDelete()) &#123; <span class="comment">// 如果是删除方法</span></div><div class="line">    Object result = countOrGetDocumentsForDelete(query, accessor);</div><div class="line">    elasticsearchOperations.delete(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryMethod.isPageQuery()) &#123; <span class="comment">// 如果是分页查询</span></div><div class="line">    query.setPageable(accessor.getPageable());</div><div class="line">    <span class="keyword">return</span> elasticsearchOperations.queryForPage(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryMethod.isStreamQuery()) &#123; <span class="comment">// 如果是流式查询</span></div><div class="line">    Class&lt;?&gt; entityType = queryMethod.getEntityInformation().getJavaType();</div><div class="line">    <span class="keyword">if</span> (query.getPageable() == <span class="keyword">null</span>) &#123;</div><div class="line">      query.setPageable(<span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">20</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> StreamUtils.createStreamFromIterator((CloseableIterator&lt;Object&gt;) elasticsearchOperations.stream(query, entityType));</div><div class="line"></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryMethod.isCollectionQuery()) &#123; <span class="comment">// 如果是集合查询</span></div><div class="line">    <span class="keyword">if</span> (accessor.getPageable() == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">int</span> itemCount = (<span class="keyword">int</span>) elasticsearchOperations.count(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">      query.setPageable(<span class="keyword">new</span> PageRequest(<span class="number">0</span>, Math.max(<span class="number">1</span>, itemCount)));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        query.setPageable(accessor.getPageable());</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> elasticsearchOperations.queryForList(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree.isCountProjection()) &#123; <span class="comment">// 如果是count查询</span></div><div class="line">    <span class="keyword">return</span> elasticsearchOperations.count(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 单个查询</span></div><div class="line">  <span class="keyword">return</span> elasticsearchOperations.queryForObject(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>findByGoodFace方法是个集合查询，最终会调用ElasticsearchOperations的queryForList方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(CriteriaQuery query, Class&lt;T&gt; clazz)</span> </span>&#123;</div><div class="line">  <span class="comment">// 调用queryForPage方法</span></div><div class="line">  <span class="keyword">return</span> queryForPage(query, clazz).getContent();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">queryForPage</span><span class="params">(CriteriaQuery criteriaQuery, Class&lt;T&gt; clazz)</span> </span>&#123;</div><div class="line">  <span class="comment">// 查询解析器进行语法的解析</span></div><div class="line">  QueryBuilder elasticsearchQuery = <span class="keyword">new</span> CriteriaQueryProcessor().createQueryFromCriteria(criteriaQuery.getCriteria());</div><div class="line">  QueryBuilder elasticsearchFilter = <span class="keyword">new</span> CriteriaFilterProcessor().createFilterFromCriteria(criteriaQuery.getCriteria());</div><div class="line">  SearchRequestBuilder searchRequestBuilder = prepareSearch(criteriaQuery, clazz);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (elasticsearchQuery != <span class="keyword">null</span>) &#123;</div><div class="line">    searchRequestBuilder.setQuery(elasticsearchQuery);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    searchRequestBuilder.setQuery(QueryBuilders.matchAllQuery());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (criteriaQuery.getMinScore() &gt; <span class="number">0</span>) &#123;</div><div class="line">    searchRequestBuilder.setMinScore(criteriaQuery.getMinScore());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (elasticsearchFilter != <span class="keyword">null</span>)</div><div class="line">    searchRequestBuilder.setPostFilter(elasticsearchFilter);</div><div class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">    logger.debug(<span class="string">"doSearch query:\n"</span> + searchRequestBuilder.toString());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  SearchResponse response = getSearchResponse(searchRequestBuilder</div><div class="line">      .execute());</div><div class="line">  <span class="comment">// 最终的结果是用ResultsMapper进行映射</span></div><div class="line">  <span class="keyword">return</span> resultsMapper.mapResults(response, clazz, criteriaQuery.getPageable());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义的方法使用ElasticsearchQueryCreator去创建CriteriaQuery，内部做一些词法的分析，有了CriteriaQuery之后，使用CriteriaQueryProcessor基于Criteria构造了QueryBuilder，最后使用QueryBuilder去做rest请求得到es的查询结果。这些过程中是没有用到ResultsMapper，而只是用反射得到POJO的属性，只有在得到查询结果后才会用ResultsMapper去做映射。</p>
<p>如果出现了这种情况，解决方案目前有两种：</p>
<p>1.使用repository的search方法，参数可以是QueryBuilder或者SearchQuery</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">personRepository.search(</div><div class="line">        QueryBuilders.boolQuery()</div><div class="line">                .must(QueryBuilders.termQuery(<span class="string">"good_face"</span>, <span class="keyword">true</span>))</div><div class="line">)</div></pre></td></tr></table></figure>
<p>2.使用@Query注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Query</span>(<span class="string">"&#123;\"bool\" : &#123;\"must\" : &#123;\"term\" : &#123;\"good_face\" : \"?0\"&#125;&#125;&#125;&#125;"</span>)</div><div class="line"><span class="function">List&lt;Person&gt; <span class="title">findByGoodFace</span><span class="params">(<span class="keyword">boolean</span> isGoodFace)</span></span>;</div></pre></td></tr></table></figure>
<p>暂时发现这两种解决方法，不知还有否更好的解决方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作中使用了&lt;a href=&quot;https://github.com/spring-projects/spring-data-elasticsearch&quot;&gt;Spring Data Elasticsearch&lt;/a&gt;。发生它存在一个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document对应的POJO的属性跟es里面文档的字段名字不一样，这样Repository里面编写自定义的查询方法就会查询不出结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有个Person类，它有2个属性goodFace和goodAt。这2个属性在es的索引里对应的字段表为good_face和good_at：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Document&lt;/span&gt;(replicas = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, shards = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, type = &lt;span class=&quot;string&quot;&gt;&quot;person&quot;&lt;/span&gt;, indexName = &lt;span class=&quot;string&quot;&gt;&quot;person&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Getter&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Setter&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@JsonNaming&lt;/span&gt;(PropertyNamingStrategy.SnakeCaseStrategy.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Id&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String id;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; goodFace;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String goodAt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Repository中的自定义查询：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Repository&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PersonRepository&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ElasticsearchRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;Person&amp;gt; &lt;span class=&quot;title&quot;&gt;findByGoodFace&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isGoodFace)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;Person&amp;gt; &lt;span class=&quot;title&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法findByGoodFace是查询不出结果的，而findByName是ok的。&lt;/p&gt;
&lt;p&gt;为什么findByGoodFace不行而findByName可以呢，来探究一下。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="elasticsearch" scheme="http://fangjian0423.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之内置Servlet容器</title>
    <link href="http://fangjian0423.github.io/2017/05/22/springboot-embedded-servlet-container/"/>
    <id>http://fangjian0423.github.io/2017/05/22/springboot-embedded-servlet-container/</id>
    <published>2017-05-22T10:35:36.000Z</published>
    <updated>2017-05-22T12:51:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot内置了Servlet容器，这样项目的发布、部署就不需要额外的Servlet容器，直接启动jar包即可。SpringBoot官方文档上有一个小章节<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-embedded-container" target="_blank" rel="external">内置servlet容器支持</a>用于说明内置Servlet的相关问题。</p>
<p>在<a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a>文章中我们了解到如果是Web程序，那么会构造AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器，在<a href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/">SpringBoot源码分析之Spring容器的refresh过程</a>文章中我们知道AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器在refresh的过程中会在onRefresh方法中创建内置的Servlet容器。</p>
<p>接下来，我们分析一下内置的Servlet容器相关的知识点。</p>
<a id="more"></a>
<h2 id="内置Servlet容器相关的接口和类"><a href="#内置Servlet容器相关的接口和类" class="headerlink" title="内置Servlet容器相关的接口和类"></a>内置Servlet容器相关的接口和类</h2><p>SpringBoot对内置的Servlet容器做了一层封装：</p>
<pre><code>public interface EmbeddedServletContainer {
    // 启动内置的Servlet容器，如果容器已经启动，则不影响
    void start() throws EmbeddedServletContainerException;
    // 关闭内置的Servlet容器，如果容器已经关系，则不影响
    void stop() throws EmbeddedServletContainerException;
    // 内置的Servlet容器监听的端口
    int getPort();
}
</code></pre><p>它目前有3个实现类，分别是JettyEmbeddedServletContainer、TomcatEmbeddedServletContainer和UndertowEmbeddedServletContainer，分别对应Jetty、Tomcat和Undertow这3个Servlet容器。</p>
<p>EmbeddedServletContainerFactory接口是一个工厂接口，用于生产EmbeddedServletContainer：</p>
<pre><code>public interface EmbeddedServletContainerFactory {
    // 获得一个已经配置好的内置Servlet容器，但是这个容器还没有监听端口。需要手动调用内置Servlet容器的start方法监听端口
    // 参数是一群ServletContextInitializer，Servlet容器启动的时候会遍历这些ServletContextInitializer，并调用onStartup方法
    EmbeddedServletContainer getEmbeddedServletContainer(
            ServletContextInitializer... initializers);
}
</code></pre><p>ServletContextInitializer表示Servlet初始化器，用于设置ServletContext中的一些配置，在使用EmbeddedServletContainerFactory接口的getEmbeddedServletContainer方法获取Servlet内置容器并且容器启动的时候调用onStartup方法：</p>
<pre><code>public interface ServletContextInitializer {
    void onStartup(ServletContext servletContext) throws ServletException;
}
</code></pre><p>EmbeddedServletContainerFactory是在EmbeddedServletContainerAutoConfiguration这个自动化配置类中被注册到Spring容器中的(前期是Spring容器中不存在EmbeddedServletContainerFactory类型的bean，可以自己定义EmbeddedServletContainerFactory类型的bean)：</p>
<pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication // 在Web环境下才会起作用
@Import(BeanPostProcessorsRegistrar.class) // 会Import一个内部类BeanPostProcessorsRegistrar
public class EmbeddedServletContainerAutoConfiguration {

    @Configuration
    // Tomcat类和Servlet类必须在classloader中存在
    @ConditionalOnClass({ Servlet.class, Tomcat.class })
    // 当前Spring容器中不存在EmbeddedServletContainerFactory类型的实例
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedTomcat {

        @Bean
        public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
          // 上述条件注解成立的话就会构造TomcatEmbeddedServletContainerFactory这个EmbeddedServletContainerFactory
            return new TomcatEmbeddedServletContainerFactory();
        }

    }

    @Configuration
    // Server类、Servlet类、Loader类以及WebAppContext类必须在classloader中存在
    @ConditionalOnClass({ Servlet.class, Server.class, Loader.class,
            WebAppContext.class })
    // 当前Spring容器中不存在EmbeddedServletContainerFactory类型的实例
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedJetty {

        @Bean
        public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {
            // 上述条件注解成立的话就会构造JettyEmbeddedServletContainerFactory这个EmbeddedServletContainerFactory
            return new JettyEmbeddedServletContainerFactory();
        }

    }

    @Configuration
    // Undertow类、Servlet类、以及SslClientAuthMode类必须在classloader中存在
    @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
    // 当前Spring容器中不存在EmbeddedServletContainerFactory类型的实例
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedUndertow {

        @Bean
        public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {
            // 上述条件注解成立的话就会构造JettyEmbeddedServletContainerFactory这个EmbeddedServletContainerFactory
            return new UndertowEmbeddedServletContainerFactory();
        }

    }
    // 在EmbeddedServletContainerAutoConfiguration自动化配置类中被导入，实现了BeanFactoryAware接口(BeanFactory会被自动注入进来)和ImportBeanDefinitionRegistrar接口(会被ConfigurationClassBeanDefinitionReader解析并注册到Spring容器中)
    public static class EmbeddedServletContainerCustomizerBeanPostProcessorRegistrar
              implements ImportBeanDefinitionRegistrar, BeanFactoryAware {

          private ConfigurableListableBeanFactory beanFactory;

          @Override
          public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
              if (beanFactory instanceof ConfigurableListableBeanFactory) {
                  this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
              }
          }

          @Override
          public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
                  BeanDefinitionRegistry registry) {
              if (this.beanFactory == null) {
                  return;
              }
              // 如果Spring容器中不存在EmbeddedServletContainerCustomizerBeanPostProcessor类型的bean
              if (ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(
                      EmbeddedServletContainerCustomizerBeanPostProcessor.class, true,
                      false))) {
                  // 注册一个EmbeddedServletContainerCustomizerBeanPostProcessor
                  registry.registerBeanDefinition(
                          &quot;embeddedServletContainerCustomizerBeanPostProcessor&quot;,
                          new RootBeanDefinition(
                                  EmbeddedServletContainerCustomizerBeanPostProcessor.class));

              }
          }

      }

}
</code></pre><p>EmbeddedServletContainerCustomizerBeanPostProcessor是一个BeanPostProcessor，它在postProcessBeforeInitialization过程中去寻找Spring容器中EmbeddedServletContainerCustomizer类型的bean，并依次调用EmbeddedServletContainerCustomizer接口的customize方法做一些定制化：</p>
<pre><code>@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
    throws BeansException {
  // 在Spring容器中寻找ConfigurableEmbeddedServletContainer类型的bean，SpringBoot内部的3种内置Servlet容器工厂都实现了这个接口，该接口的作用就是进行Servlet容器的配置
  // 比如添加Servlet初始化器addInitializers、添加错误页addErrorPages、设置session超时时间setSessionTimeout、设置端口setPort等等
  if (bean instanceof ConfigurableEmbeddedServletContainer) {
    postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
  }
  return bean;
}

private void postProcessBeforeInitialization(
    ConfigurableEmbeddedServletContainer bean) {
  for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
    // 遍历获取的每个定制化器，并调用customize方法进行一些定制
    customizer.customize(bean);
  }
}

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {
  if (this.customizers == null) {
    this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
        // 找出Spring容器中EmbeddedServletContainerCustomizer类型的bean
        this.applicationContext
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                false, false)
            .values());
    // 定制化器做排序
    Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
    // 设置定制化器到属性中
    this.customizers = Collections.unmodifiableList(this.customizers);
  }
  return this.customizers;
}
</code></pre><p>SpringBoot内置了一些EmbeddedServletContainerCustomizer，比如ErrorPageCustomizer、ServerProperties、TomcatWebSocketContainerCustomizer等。</p>
<p>定制器比如ServerProperties表示服务端的一些配置，以server为前缀，比如有server.port、server.contextPath、server.displayName等，它同时也实现了EmbeddedServletContainerCustomizer接口，其中customize方法的一部分代码如下：</p>
<pre><code>@Override
public void customize(ConfigurableEmbeddedServletContainer container) {
  // 3种ServletContainerFactory都实现了ConfigurableEmbeddedServletContainer接口，所以下面的这些设置相当于对ServletContainerFactory进行设置
  // 如果配置了端口信息
  if (getPort() != null) {
    container.setPort(getPort());
  }
  ...
  // 如果配置了displayName
  if (getDisplayName() != null) {
    container.setDisplayName(getDisplayName());
  }
  // 如果配置了server.session.timeout，session超时时间。注意：这里的Session指的是ServerProperties的内部静态类Session
  if (getSession().getTimeout() != null) {
    container.setSessionTimeout(getSession().getTimeout());
  }
  ...
  // 如果使用的是Tomcat内置Servlet容器，设置对应的Tomcat配置
  if (container instanceof TomcatEmbeddedServletContainerFactory) {
    getTomcat().customizeTomcat(this,
        (TomcatEmbeddedServletContainerFactory) container);
  }
  // 如果使用的是Jetty内置Servlet容器，设置对应的Tomcat配置
  if (container instanceof JettyEmbeddedServletContainerFactory) {
    getJetty().customizeJetty(this,
        (JettyEmbeddedServletContainerFactory) container);
  }
  // 如果使用的是Undertow内置Servlet容器，设置对应的Tomcat配置
  if (container instanceof UndertowEmbeddedServletContainerFactory) {
    getUndertow().customizeUndertow(this,
        (UndertowEmbeddedServletContainerFactory) container);
  }
  // 添加SessionConfiguringInitializer这个Servlet初始化器
  // SessionConfiguringInitializer初始化器的作用是基于ServerProperties的内部静态类Session设置Servlet中session和cookie的配置
  container.addInitializers(new SessionConfiguringInitializer(this.session));
  // 添加InitParameterConfiguringServletContextInitializer初始化器
  // InitParameterConfiguringServletContextInitializer初始化器的作用是基于ServerProperties的contextParameters配置设置到ServletContext的init param中
  container.addInitializers(new InitParameterConfiguringServletContextInitializer(
      getContextParameters()));
}
</code></pre><p>ErrorPageCustomizer在ErrorMvcAutoConfiguration自动化配置里定义，是个内部静态类：</p>
<pre><code>@Bean
public ErrorPageCustomizer errorPageCustomizer() {
    return new ErrorPageCustomizer(this.properties);
}

private static class ErrorPageCustomizer
          implements EmbeddedServletContainerCustomizer, Ordered {

        private final ServerProperties properties;

        protected ErrorPageCustomizer(ServerProperties properties) {
            this.properties = properties;
        }

        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            // 添加错误页ErrorPage，这个ErrorPage对应的路径是 /error
            // 可以通过配置修改 ${servletPath} + ${error.path}
            container.addErrorPages(new ErrorPage(this.properties.getServletPrefix()
                    + this.properties.getError().getPath()));
        }

        @Override
        public int getOrder() {
            return 0;
        }

   }
</code></pre><h2 id="DispatcherServlet的构造"><a href="#DispatcherServlet的构造" class="headerlink" title="DispatcherServlet的构造"></a>DispatcherServlet的构造</h2><p>DispatcherServlet是SpringMVC中的核心分发器。它是在DispatcherServletAutoConfiguration这个自动化配置类里构造的(如果Spring容器内没有自定义的DispatcherServlet)，并且还会被加到Servlet容器中(通过ServletRegistrationBean完成)。</p>
<p>DispatcherServletAutoConfiguration这个自动化配置类存在2个条件注解@ConditionalOnWebApplication和@ConditionalOnClass(DispatcherServlet.class)都满足条件，所以会被构造(存在@AutoConfigureAfter(EmbeddedServletContainerAutoConfiguration.class)注解，会在EmbeddedServletContainerAutoConfiguration自动化配置类构造后构造)：</p>
<pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(EmbeddedServletContainerAutoConfiguration.class)
public class DispatcherServletAutoConfiguration ...
</code></pre><p>DispatcherServletAutoConfiguration有个内部类DispatcherServletConfiguration，它会构造DispatcherServlet(使用了条件类DefaultDispatcherServletCondition，如果Spring容器已经存在自定义的DispatcherServlet类型的bean，该类就不会被构造，会直接使用自定义的DispatcherServlet)：</p>
<pre><code>@Configuration
// 条件类DefaultDispatcherServletCondition，是EmbeddedServletContainerAutoConfiguration的内部类
// DefaultDispatcherServletCondition条件类会去Spring容器中找DispatcherServlet类型的实例，如果找到了不会构造DispatcherServletConfiguration，否则就是构造DispatcherServletConfiguration，该类内部会构造DispatcherServlet
// 所以如果我们要自定义DispatcherServlet的话只需要自定义DispatcherServlet即可，这样DispatcherServletConfiguration内部就不会构造DispatcherServlet
@Conditional(DefaultDispatcherServletCondition.class)
// Servlet3.0开始才有的类，支持以编码的形式注册Servlet
@ConditionalOnClass(ServletRegistration.class)
// spring.mvc 为前缀的配置
@EnableConfigurationProperties(WebMvcProperties.class)
protected static class DispatcherServletConfiguration {

  @Autowired
  private ServerProperties server;

  @Autowired
  private WebMvcProperties webMvcProperties;

  @Autowired(required = false)
  private MultipartConfigElement multipartConfig;

  // Spring容器注册DispatcherServlet
  @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
  public DispatcherServlet dispatcherServlet() {
    // 直接构造DispatcherServlet，并设置WebMvcProperties中的一些配置
    DispatcherServlet dispatcherServlet = new DispatcherServlet();
    dispatcherServlet.setDispatchOptionsRequest(
        this.webMvcProperties.isDispatchOptionsRequest());
    dispatcherServlet.setDispatchTraceRequest(
        this.webMvcProperties.isDispatchTraceRequest());
    dispatcherServlet.setThrowExceptionIfNoHandlerFound(
        this.webMvcProperties.isThrowExceptionIfNoHandlerFound());
    return dispatcherServlet;
  }

  @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
  public ServletRegistrationBean dispatcherServletRegistration() {
    // 直接使用DispatcherServlet和server配置中的servletPath路径构造ServletRegistrationBean
    // ServletRegistrationBean实现了ServletContextInitializer接口，在onStartup方法中对应的Servlet注册到Servlet容器中
    // 所以这里DispatcherServlet会被注册到Servlet容器中，对应的urlMapping为server.servletPath配置
    ServletRegistrationBean registration = new ServletRegistrationBean(
        dispatcherServlet(), this.server.getServletMapping());
    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
    if (this.multipartConfig != null) {
      registration.setMultipartConfig(this.multipartConfig);
    }
    return registration;
  }

  @Bean // 构造文件上传相关的bean
  @ConditionalOnBean(MultipartResolver.class)
  @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
  public MultipartResolver multipartResolver(MultipartResolver resolver) {
    return resolver;
  }

}
</code></pre><p>ServletRegistrationBean实现了ServletContextInitializer接口，是个Servlet初始化器，onStartup方法代码：</p>
<pre><code>@Override
public void onStartup(ServletContext servletContext) throws ServletException {
  Assert.notNull(this.servlet, &quot;Servlet must not be null&quot;);
  String name = getServletName();
  if (!isEnabled()) {
    logger.info(&quot;Servlet &quot; + name + &quot; was not registered (disabled)&quot;);
    return;
  }
  logger.info(&quot;Mapping servlet: &apos;&quot; + name + &quot;&apos; to &quot; + this.urlMappings);
  // 把servlet添加到Servlet容器中，Servlet容器启动的时候会加载这个Servlet
  Dynamic added = servletContext.addServlet(name, this.servlet);
  if (added == null) {
    logger.info(&quot;Servlet &quot; + name + &quot; was not registered &quot;
        + &quot;(possibly already registered?)&quot;);
    return;
  }
  // 进行Servlet的一些配置，比如urlMapping，loadOnStartup等
  configure(added);
}
</code></pre><p>类似ServletRegistrationBean的还有ServletListenerRegistrationBean和FilterRegistrationBean，它们都是Servlet初始化器，分别都是在Servlet容器中添加Listener和Filter。</p>
<p>1个小漏洞：如果定义了一个名字为dispatcherServlet的bean，但是它不是DispatcherServlet类型，那么DispatcherServlet就不会被构造，@RestController和@Controller注解的控制器就没办法生效：</p>
<pre><code>@Bean(name = &quot;dispatcherServlet&quot;)
public Object test() {
    return new Object();
}
</code></pre><h2 id="内置Servlet容器的创建和启动"><a href="#内置Servlet容器的创建和启动" class="headerlink" title="内置Servlet容器的创建和启动"></a>内置Servlet容器的创建和启动</h2><p>web程序对应的Spring容器是AnnotationConfigEmbeddedWebApplicationContext，继承自EmbeddedWebApplicationContext。在onRefresh方法中会去创建内置Servlet容器：</p>
<pre><code>@Override
protected void onRefresh() {
  super.onRefresh();
  try {
    // 创建内置Servlet容器
    createEmbeddedServletContainer();
  }
  catch (Throwable ex) {
    throw new ApplicationContextException(&quot;Unable to start embedded container&quot;,
        ex);
  }
}

private void createEmbeddedServletContainer() {
      EmbeddedServletContainer localContainer = this.embeddedServletContainer;
      ServletContext localServletContext = getServletContext();
      // 内置Servlet容器和ServletContext都还没初始化的时候执行
      if (localContainer == null &amp;&amp; localServletContext == null) {
          // 从Spring容器中获取EmbeddedServletContainerFactory，如果EmbeddedServletContainerFactory不存在或者有多个的话会抛出异常中止程序
          EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();
          // 获取Servlet初始化器并创建Servlet容器，依次调用Servlet初始化器中的onStartup方法
          this.embeddedServletContainer = containerFactory
                  .getEmbeddedServletContainer(getSelfInitializer());
      }
      // 内置Servlet容器已经初始化但是ServletContext还没初始化的时候执行
      else if (localServletContext != null) {
          try {
      // 对已经存在的Servlet
      容器依次调用Servlet初始化器中的onStartup方法
              getSelfInitializer().onStartup(localServletContext);
          }
          catch (ServletException ex) {
              throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;,
                      ex);
          }
      }
      initPropertySources();
  }
</code></pre><p>getSelfInitializer方法获得的Servlet初始化器内部会去构造一个ServletContextInitializerBeans(Servlet初始化器的集合)，ServletContextInitializerBeans构造的时候会去Spring容器中查找ServletContextInitializer类型的bean，其中ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean会被找出(如果有定义)，这3种ServletContextInitializer会在onStartup方法中将Servlet、Filter、Listener添加到Servlet容器中(如果我们只定义了Servlet、Filter或者Listener，ServletContextInitializerBeans内部会调用addAdaptableBeans方法把它们包装成RegistrationBean)：</p>
<pre><code>// selfInitialize方法内部调用的getServletContextInitializerBeans方法获得ServletContextInitializerBeans
protected Collection&lt;ServletContextInitializer&gt; getServletContextInitializerBeans() {
  return new ServletContextInitializerBeans(getBeanFactory());
}

private void addServletContextInitializerBean(String beanName,
          ServletContextInitializer initializer, ListableBeanFactory beanFactory) {
      if (initializer instanceof ServletRegistrationBean) {
          Servlet source = ((ServletRegistrationBean) initializer).getServlet();
          addServletContextInitializerBean(Servlet.class, beanName, initializer,
                  beanFactory, source);
      }
      else if (initializer instanceof FilterRegistrationBean) {
          Filter source = ((FilterRegistrationBean) initializer).getFilter();
          addServletContextInitializerBean(Filter.class, beanName, initializer,
                  beanFactory, source);
      }
      else if (initializer instanceof DelegatingFilterProxyRegistrationBean) {
          String source = ((DelegatingFilterProxyRegistrationBean) initializer)
                  .getTargetBeanName();
          addServletContextInitializerBean(Filter.class, beanName, initializer,
                  beanFactory, source);
      }
      else if (initializer instanceof ServletListenerRegistrationBean) {
          EventListener source = ((ServletListenerRegistrationBean&lt;?&gt;) initializer)
                  .getListener();
          addServletContextInitializerBean(EventListener.class, beanName, initializer,
                  beanFactory, source);
      }
      else {
          addServletContextInitializerBean(ServletContextInitializer.class, beanName,
                  initializer, beanFactory, null);
      }
  }
</code></pre><p>Servlet容器创建完毕之后在finishRefresh方法中会去启动：</p>
<pre><code>@Override
protected void finishRefresh() {
  super.finishRefresh();
  // 调用startEmbeddedServletContainer方法
  EmbeddedServletContainer localContainer = startEmbeddedServletContainer();
  if (localContainer != null) {
    // 发布EmbeddedServletContainerInitializedEvent事件
    publishEvent(
        new EmbeddedServletContainerInitializedEvent(this, localContainer));
  }
}

private EmbeddedServletContainer startEmbeddedServletContainer() {
      // 先得到在onRefresh方法中构造的Servlet容器embeddedServletContainer
      EmbeddedServletContainer localContainer = this.embeddedServletContainer;
      if (localContainer != null) {
          // 启动
          localContainer.start();
      }
      return localContainer;
  }
</code></pre><h2 id="自定义Servlet、Filter、Listener"><a href="#自定义Servlet、Filter、Listener" class="headerlink" title="自定义Servlet、Filter、Listener"></a>自定义Servlet、Filter、Listener</h2><p>SpringBoot默认只会添加一个Servlet，也就是DispatcherServlet，如果我们想添加自定义的Servlet或者是Filter还是Listener，有以下几种方法。</p>
<p>1.在Spring容器中声明ServletRegistrationBean、FilterRegistrationBean或者ServletListenerRegistrationBean。原理在<strong>DispatcherServlet的构造</strong>章节中已经说明</p>
<pre><code>@Bean
public ServletRegistrationBean customServlet() {
    return new ServletRegistrationBean(new CustomServlet(), &quot;/custom&quot;);
}

private static class CustomServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(&quot;receive by custom servlet&quot;);
    }
}
</code></pre><p>2.@ServletComponentScan注解和@WebServlet、@WebFilter以及@WebListener注解配合使用。@ServletComponentScan注解启用ImportServletComponentScanRegistrar类，是个ImportBeanDefinitionRegistrar接口的实现类，会被Spring容器所解析。ServletComponentScanRegistrar内部会解析@ServletComponentScan注解，然后会在Spring容器中注册ServletComponentRegisteringPostProcessor，是个BeanFactoryPostProcessor，会去解析扫描出来的类是不是有@WebServlet、@WebListener、@WebFilter这3种注解，有的话把这3种类型的类转换成ServletRegistrationBean、FilterRegistrationBean或者ServletListenerRegistrationBean，然后让Spring容器去解析：</p>
<pre><code>@SpringBootApplication
@ServletComponentScan
public class EmbeddedServletApplication { ... }

@WebServlet(urlPatterns = &quot;/simple&quot;)
public class SimpleServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(&quot;receive by SimpleServlet&quot;);
    }

}
</code></pre><p>3.在Spring容器中声明Servlet、Filter或者Listener。因为在ServletContextInitializerBeans内部会去调用addAdaptableBeans方法把它们包装成ServletRegistrationBean：</p>
<pre><code>@Bean(name = &quot;dispatcherServlet&quot;)
public DispatcherServlet myDispatcherServlet() {
    return new DispatcherServlet();
}
</code></pre><h2 id="Whitelabel-Error-Page原理"><a href="#Whitelabel-Error-Page原理" class="headerlink" title="Whitelabel Error Page原理"></a>Whitelabel Error Page原理</h2><p>为什么SpringBoot的程序里Controller发生了错误，我们没有进行异常的捕捉，会跳转到Whitelabel Error Page页面，这是如何实现的？</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/embedded-servlet-container01.png" alt=""></p>
<p>SpringBoot內部提供了一个ErrorController叫做BasicErrorController，对应的@RequestMapping地址为 “server.error.path” 配置 或者 “error.path” 配置，这2个配置没配的话默认是/error，之前分析过ErrorPageCustomizer这个定制化器会把ErrorPage添加到Servlet容器中(这个ErrorPage的path就是上面说的那2个配置)，这样Servlet容器发生错误的时候就会访问ErrorPage配置的path，所以程序发生异常且没有被catch的话，就会走Servlet容器配置的ErrorPage。下面这段代码是BasicErrorController对应的处理请求方法：</p>
<pre><code>@RequestMapping(produces = &quot;text/html&quot;)
public ModelAndView errorHtml(HttpServletRequest request,
  HttpServletResponse response) {
    // 设置响应码
    response.setStatus(getStatus(request).value());
    // 设置一些信息，比如timestamp、statusCode、错误message等
    Map&lt;String, Object&gt; model = getErrorAttributes(request,
        isIncludeStackTrace(request, MediaType.TEXT_HTML));
    // 返回error视图
    return new ModelAndView(&quot;error&quot;, model);
}
</code></pre><p>这里名字为error视图会被BeanNameViewResolver这个视图解析器解析，它会去Spring容器中找出name为error的View，error这个bean在ErrorMvcAutoConfiguration自动化配置类里定义，它返回了一个SpelView视图，也就是刚才见到的Whitelabel Error Page(error.whitelabel.enabled配置需要是true，否则WhitelabelErrorViewConfiguration自动化配置类不会被注册)：</p>
<pre><code>@Configuration
@ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)
@Conditional(ErrorTemplateMissingCondition.class)
protected static class WhitelabelErrorViewConfiguration {

  // Whitelabel Error Page
  private final SpelView defaultErrorView = new SpelView(
      &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;
          + &quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;
          + &quot;&lt;div id=&apos;created&apos;&gt;${timestamp}&lt;/div&gt;&quot;
          + &quot;&lt;div&gt;There was an unexpected error (type=${error}, status=${status}).&lt;/div&gt;&quot;
          + &quot;&lt;div&gt;${message}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);

  @Bean(name = &quot;error&quot;) // bean的名字是error
  @ConditionalOnMissingBean(name = &quot;error&quot;) // 名字为error的bean不存在才会构造
  public View defaultErrorView() {
    return this.defaultErrorView;
  }

  @Bean
  @ConditionalOnMissingBean(BeanNameViewResolver.class)
  public BeanNameViewResolver beanNameViewResolver() {
    // BeanNameViewResolver会去Spring容器找对应bean的视图
    BeanNameViewResolver resolver = new BeanNameViewResolver();
    resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
    return resolver;
  }

}
</code></pre><p>如果自定义了error页面，比如使用freemarker模板的话存在/templates/error.ftl页面，使用thymeleaf模板的话存在/templates/error.html页面。那么Whitelabel Error Page就不会生效了，而是会跳到这些error页面。这又是如何实现的呢?</p>
<p>这是因为ErrorMvcAutoConfiguration自动化配置类里的内部类  WhitelabelErrorViewConfiguration自动化配置类里有个条件类ErrorTemplateMissingCondition，它的getMatchOutcome方法：</p>
<pre><code>@Override
public ConditionOutcome getMatchOutcome(ConditionContext context,
    AnnotatedTypeMetadata metadata) {
  // 从spring.factories文件中找出key为TemplateAvailabilityProvider为类，TemplateAvailabilityProvider用来查询视图是否可用
  List&lt;TemplateAvailabilityProvider&gt; availabilityProviders = SpringFactoriesLoader
      .loadFactories(TemplateAvailabilityProvider.class,
          context.getClassLoader());
  // 遍历各个TemplateAvailabilityProvider
  for (TemplateAvailabilityProvider availabilityProvider : availabilityProviders)
    // 如果error视图可用
    if (availabilityProvider.isTemplateAvailable(&quot;error&quot;,
        context.getEnvironment(), context.getClassLoader(),
        context.getResourceLoader())) {
      // 条件不生效。WhitelabelErrorViewConfiguration不会被构造
      return ConditionOutcome.noMatch(&quot;Template from &quot;
          + availabilityProvider + &quot; found for error view&quot;);
    }
  }
  // 条件生效。WhitelabelErrorViewConfiguration被构造
  return ConditionOutcome.match(&quot;No error template view detected&quot;);
}
</code></pre><p>比如FreeMarkerTemplateAvailabilityProvider这个TemplateAvailabilityProvider的逻辑如下：</p>
<pre><code>public class FreeMarkerTemplateAvailabilityProvider
        implements TemplateAvailabilityProvider {

    @Override
    public boolean isTemplateAvailable(String view, Environment environment,
            ClassLoader classLoader, ResourceLoader resourceLoader) {
        // 判断是否存在freemarker包中的Configuration类，存在的话才会继续
        if (ClassUtils.isPresent(&quot;freemarker.template.Configuration&quot;, classLoader)) {
            // 构造属性解析器
            RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,
                    &quot;spring.freemarker.&quot;);
            // 设置一些配置
            String loaderPath = resolver.getProperty(&quot;template-loader-path&quot;,
                    FreeMarkerProperties.DEFAULT_TEMPLATE_LOADER_PATH);
            String prefix = resolver.getProperty(&quot;prefix&quot;,
                    FreeMarkerProperties.DEFAULT_PREFIX);
            String suffix = resolver.getProperty(&quot;suffix&quot;,
                    FreeMarkerProperties.DEFAULT_SUFFIX);
            // 查找对应的资源文件是否存在
            return resourceLoader.getResource(loaderPath + prefix + view + suffix)
                    .exists();
        }
        return false;
    }

}
</code></pre><p>所以BeanNameViewResolver不会被构造，Whitelabel Error Page也不会构造，而是直接去找自定义的error视图。</p>
<p>一些测试代码： <a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-embedded-servlet-conatiner" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-embedded-servlet-conatiner</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot内置了Servlet容器，这样项目的发布、部署就不需要额外的Servlet容器，直接启动jar包即可。SpringBoot官方文档上有一个小章节&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-embedded-container&quot;&gt;内置servlet容器支持&lt;/a&gt;用于说明内置Servlet的相关问题。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/&quot;&gt;SpringBoot源码分析之SpringBoot的启动过程&lt;/a&gt;文章中我们了解到如果是Web程序，那么会构造AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器，在&lt;a href=&quot;http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/&quot;&gt;SpringBoot源码分析之Spring容器的refresh过程&lt;/a&gt;文章中我们知道AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器在refresh的过程中会在onRefresh方法中创建内置的Servlet容器。&lt;/p&gt;
&lt;p&gt;接下来，我们分析一下内置的Servlet容器相关的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之条件注解的底层实现</title>
    <link href="http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/"/>
    <id>http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/</id>
    <published>2017-05-16T11:40:13.000Z</published>
    <updated>2017-05-31T13:16:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot内部提供了特有的注解：条件注解(Conditional Annotation)。比如@ConditionalOnBean、@ConditionalOnClass、@ConditionalOnExpression、@ConditionalOnMissingBean等。</p>
<p>条件注解存在的意义在于动态识别(也可以说是代码自动化执行)。比如@ConditionalOnClass会检查类加载器中是否存在对应的类，如果有的话被注解修饰的类就有资格被Spring容器所注册，否则会被skip。</p>
<p>比如FreemarkerAutoConfiguration这个自动化配置类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; freemarker.template.Configuration.class,</div><div class="line">		FreeMarkerConfigurationFactory.class &#125;)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration.class)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(FreeMarkerProperties.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerAutoConfiguration</span></span></div></pre></td></tr></table></figure>
<p>这个自动化配置类被@ConditionalOnClass条件注解修饰，这个条件注解存在的意义在于判断类加载器中是否存在freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类，如果都存在的话会在Spring容器中加载这个FreeMarkerAutoConfiguration配置类；否则不会加载。</p>
<a id="more"></a>
<h2 id="条件注解内部的一些基础"><a href="#条件注解内部的一些基础" class="headerlink" title="条件注解内部的一些基础"></a>条件注解内部的一些基础</h2><p>在分析条件注解的底层实现之前，我们先来看一下这些条件注解的定义。以@ConditionalOnClass注解为例，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Conditional</span>(OnClassCondition.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnClass &#123;</div><div class="line">  Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 需要匹配的类</span></div><div class="line">  String[] name() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 需要匹配的类名</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它有2个属性，分别是类数组和字符串数组(作用一样，类型不一样)，而且被@Conditional注解所修饰，这个@Conditional注解有个名为values的Class&lt;? extends Condition&gt;[]类型的属性。 这个Condition是个接口，用于匹配组件是否有资格被容器注册，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">  <span class="comment">// ConditionContext内部会存储Spring容器、应用程序环境信息、资源加载器、类加载器</span></div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说@Conditional注解属性中可以持有多个Condition接口的实现类，所有的Condition接口需要全部匹配成功后这个@Conditional修饰的组件才有资格被注册。</p>
<p>Condition接口有个子接口ConfigurationCondition：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurationCondition</span> <span class="keyword">extends</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">ConfigurationPhase <span class="title">getConfigurationPhase</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> ConfigurationPhase &#123;</div><div class="line"></div><div class="line">  	PARSE_CONFIGURATION,</div><div class="line"></div><div class="line">  	REGISTER_BEAN</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个子接口是一种特殊的条件接口，多了一个getConfigurationPhase方法，也就是条件注解的生效阶段。只有在ConfigurationPhase中定义的两种阶段下才会生效。</p>
<p>Condition接口有个实现抽象类SpringBootCondition，SpringBoot中所有条件注解对应的条件类都继承这个抽象类。它实现了matches方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context,</span></span></div><div class="line">		AnnotatedTypeMetadata metadata) &#123;</div><div class="line">  String classOrMethodName = getClassOrMethodName(metadata); <span class="comment">// 得到类名或者方法名(条件注解可以作用的类或者方法上)</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">  	ConditionOutcome outcome = getMatchOutcome(context, metadata); <span class="comment">// 抽象方法，具体子类实现。ConditionOutcome记录了匹配结果boolean和log信息</span></div><div class="line">  	logOutcome(classOrMethodName, outcome); <span class="comment">// log记录一下匹配信息</span></div><div class="line">  	recordEvaluation(context, classOrMethodName, outcome); <span class="comment">// 报告记录一下匹配信息</span></div><div class="line">  	<span class="keyword">return</span> outcome.isMatch(); <span class="comment">// 返回是否匹配</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (NoClassDefFoundError ex) &#123;</div><div class="line">  	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">  			<span class="string">"Could not evaluate condition on "</span> + classOrMethodName + <span class="string">" due to "</span></div><div class="line">  					+ ex.getMessage() + <span class="string">" not "</span></div><div class="line">  					+ <span class="string">"found. Make sure your own configuration does not rely on "</span></div><div class="line">  					+ <span class="string">"that class. This can also happen if you are "</span></div><div class="line">  					+ <span class="string">"@ComponentScanning a springframework package (e.g. if you "</span></div><div class="line">  					+ <span class="string">"put a @ComponentScan in the default package by mistake)"</span>,</div><div class="line">  			ex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (RuntimeException ex) &#123;</div><div class="line">  	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">  			<span class="string">"Error processing condition on "</span> + getName(metadata), ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基于Class的条件注解"><a href="#基于Class的条件注解" class="headerlink" title="基于Class的条件注解"></a>基于Class的条件注解</h2><p>SpringBoot提供了两个基于Class的条件注解：@ConditionalOnClass(类加载器中存在指明的类)或者@ConditionalOnMissingClass(类加载器中不存在指明的类)。</p>
<p>@ConditionalOnClass或者@ConditionalOnMissingClass注解对应的条件类是OnClassCondition，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE) <span class="comment">// 优先级、最高级别</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnClassCondition</span> <span class="keyword">extends</span> <span class="title">SpringBootCondition</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></div><div class="line">  		AnnotatedTypeMetadata metadata) &#123;</div><div class="line"></div><div class="line">  	StringBuffer matchMessage = <span class="keyword">new</span> StringBuffer(); <span class="comment">// 记录匹配信息</span></div><div class="line"></div><div class="line">  	MultiValueMap&lt;String, Object&gt; onClasses = getAttributes(metadata,</div><div class="line">  			ConditionalOnClass.class); <span class="comment">// 得到@ConditionalOnClass注解的属性</span></div><div class="line">  	<span class="keyword">if</span> (onClasses != <span class="keyword">null</span>) &#123; <span class="comment">// 如果属性存在</span></div><div class="line">  		List&lt;String&gt; missing = getMatchingClasses(onClasses, MatchType.MISSING,</div><div class="line">  				context); <span class="comment">// 得到在类加载器中不存在的类</span></div><div class="line">  		<span class="keyword">if</span> (!missing.isEmpty()) &#123; <span class="comment">// 如果存在类加载器中不存在对应的类，返回一个匹配失败的ConditionalOutcome</span></div><div class="line">  			<span class="keyword">return</span> ConditionOutcome</div><div class="line">  					.noMatch(<span class="string">"required @ConditionalOnClass classes not found: "</span></div><div class="line">  							+ StringUtils.collectionToCommaDelimitedString(missing));</div><div class="line">  		&#125;</div><div class="line">                <span class="comment">// 如果类加载器中存在对应的类的话，匹配信息进行记录</span></div><div class="line">  		matchMessage.append(<span class="string">"@ConditionalOnClass classes found: "</span></div><div class="line">  				+ StringUtils.collectionToCommaDelimitedString(</div><div class="line">  						getMatchingClasses(onClasses, MatchType.PRESENT, context)));</div><div class="line">  	&#125;</div><div class="line">        <span class="comment">// 对@ConditionalOnMissingClass注解做相同的逻辑处理(说明@ConditionalOnClass和@ConditionalOnMissingClass可以一起使用)</span></div><div class="line">  	MultiValueMap&lt;String, Object&gt; onMissingClasses = getAttributes(metadata,</div><div class="line">  			ConditionalOnMissingClass.class);</div><div class="line">  	<span class="keyword">if</span> (onMissingClasses != <span class="keyword">null</span>) &#123;</div><div class="line">  		List&lt;String&gt; present = getMatchingClasses(onMissingClasses, MatchType.PRESENT,</div><div class="line">  				context);</div><div class="line">  		<span class="keyword">if</span> (!present.isEmpty()) &#123;</div><div class="line">  			<span class="keyword">return</span> ConditionOutcome</div><div class="line">  					.noMatch(<span class="string">"required @ConditionalOnMissing classes found: "</span></div><div class="line">  							+ StringUtils.collectionToCommaDelimitedString(present));</div><div class="line">  		&#125;</div><div class="line">  		matchMessage.append(matchMessage.length() == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">" "</span>);</div><div class="line">  		matchMessage.append(<span class="string">"@ConditionalOnMissing classes not found: "</span></div><div class="line">  				+ StringUtils.collectionToCommaDelimitedString(getMatchingClasses(</div><div class="line">  						onMissingClasses, MatchType.MISSING, context)));</div><div class="line">  	&#125;</div><div class="line">        <span class="comment">// 返回全部匹配成功的ConditionalOutcome</span></div><div class="line">  	<span class="keyword">return</span> ConditionOutcome.match(matchMessage.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">enum</span> MatchType &#123; <span class="comment">// 枚举：匹配类型。用于查询类名在对应的类加载器中是否存在。</span></div><div class="line"></div><div class="line">  	PRESENT &#123; <span class="comment">// 匹配成功</span></div><div class="line">  		<span class="meta">@Override</span></div><div class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ConditionContext context)</span> </span>&#123;</div><div class="line">  			<span class="keyword">return</span> ClassUtils.isPresent(className, context.getClassLoader());</div><div class="line">  		&#125;</div><div class="line">  	&#125;,</div><div class="line"></div><div class="line">  	MISSING &#123; <span class="comment">// 匹配不成功</span></div><div class="line">  		<span class="meta">@Override</span></div><div class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ConditionContext context)</span> </span>&#123;</div><div class="line">  			<span class="keyword">return</span> !ClassUtils.isPresent(className, context.getClassLoader());</div><div class="line">  		&#125;</div><div class="line">  	&#125;;</div><div class="line"></div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ConditionContext context)</span></span>;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如FreemarkerAutoConfiguration中的@ConditionalOnClass注解中有value属性是freemarker.template.Configuration.class和FreeMarkerConfigurationFactory.class。在OnClassCondition执行过程中得到的最终ConditionalOutcome中的log message如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnClass</span> classes found: freemarker.template.Configuration,org.springframework.ui.freemarker.FreeMarkerConfigurationFactory</div></pre></td></tr></table></figure>
<h2 id="基于Bean的条件注解"><a href="#基于Bean的条件注解" class="headerlink" title="基于Bean的条件注解"></a>基于Bean的条件注解</h2><p>@ConditionalOnBean(Spring容器中存在指明的bean)、@ConditionalOnMissingBean(Spring容器中不存在指明的bean)以及ConditionalOnSingleCandidate(Spring容器中存在且只存在一个指明的bean)都是基于Bean的条件注解，它们对应的条件类是ConditionOnBean。</p>
<p>@ConditionOnBean注解定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Conditional</span>(OnBeanCondition.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnBean &#123;</div><div class="line">  Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean类型</span></div><div class="line">  String[] type() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean类型的类名</span></div><div class="line">  Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean注解</span></div><div class="line">  String[] name() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean的名字</span></div><div class="line">  <span class="function">SearchStrategy <span class="title">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL</span>; <span class="comment">// 搜索策略。提供CURRENT(只在当前容器中找)、PARENTS(只在所有的父容器中找；但是不包括当前容器)和ALL(CURRENT和PARENTS的组合)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OnBeanCondition条件类的匹配代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></div><div class="line">    AnnotatedTypeMetadata metadata) &#123;</div><div class="line">  StringBuffer matchMessage = <span class="keyword">new</span> StringBuffer(); <span class="comment">// 记录匹配信息</span></div><div class="line">  <span class="keyword">if</span> (metadata.isAnnotated(ConditionalOnBean.class.getName())) &#123;</div><div class="line">    BeanSearchSpec spec = <span class="keyword">new</span> BeanSearchSpec(context, metadata,</div><div class="line">        ConditionalOnBean.class); <span class="comment">// 构造一个BeanSearchSpec，会从@ConditionalOnBean注解中获取属性，然后设置到BeanSearchSpec中</span></div><div class="line">    List&lt;String&gt; matching = getMatchingBeans(context, spec); <span class="comment">// 从BeanFactory中根据策略找出所有匹配的bean</span></div><div class="line">    <span class="keyword">if</span> (matching.isEmpty()) &#123; <span class="comment">// 如果没有匹配的bean，返回一个没有匹配成功的ConditionalOutcome</span></div><div class="line">      <span class="keyword">return</span> ConditionOutcome</div><div class="line">          .noMatch(<span class="string">"@ConditionalOnBean "</span> + spec + <span class="string">" found no beans"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果找到匹配的bean，匹配信息进行记录</span></div><div class="line">    matchMessage.append(</div><div class="line">        <span class="string">"@ConditionalOnBean "</span> + spec + <span class="string">" found the following "</span> + matching);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123; <span class="comment">// 相同的逻辑，针对@ConditionalOnSingleCandidate注解</span></div><div class="line">    BeanSearchSpec spec = <span class="keyword">new</span> SingleCandidateBeanSearchSpec(context, metadata,</div><div class="line">        ConditionalOnSingleCandidate.class);</div><div class="line">    List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class="line">    <span class="keyword">if</span> (matching.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(</div><div class="line">          <span class="string">"@ConditionalOnSingleCandidate "</span> + spec + <span class="string">" found no beans"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matching)) &#123; <span class="comment">// 多了一层判断，判断是否只有一个bean</span></div><div class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(<span class="string">"@ConditionalOnSingleCandidate "</span> + spec</div><div class="line">          + <span class="string">" found no primary candidate amongst the"</span> + <span class="string">" following "</span></div><div class="line">          + matching);</div><div class="line">    &#125;</div><div class="line">    matchMessage.append(<span class="string">"@ConditionalOnSingleCandidate "</span> + spec + <span class="string">" found "</span></div><div class="line">        + <span class="string">"a primary candidate amongst the following "</span> + matching);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123; <span class="comment">// 相同的逻辑，针对@ConditionalOnMissingBean注解</span></div><div class="line">    BeanSearchSpec spec = <span class="keyword">new</span> BeanSearchSpec(context, metadata,</div><div class="line">        ConditionalOnMissingBean.class);</div><div class="line">    List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class="line">    <span class="keyword">if</span> (!matching.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(<span class="string">"@ConditionalOnMissingBean "</span> + spec</div><div class="line">          + <span class="string">" found the following "</span> + matching);</div><div class="line">    &#125;</div><div class="line">    matchMessage.append(matchMessage.length() == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">" "</span>);</div><div class="line">    matchMessage.append(<span class="string">"@ConditionalOnMissingBean "</span> + spec + <span class="string">" found no beans"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ConditionOutcome.match(matchMessage.toString()); <span class="comment">//返回匹配成功的ConditonalOutcome</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpringBoot还提供了其他比如ConditionalOnJava、ConditionalOnNotWebApplication、ConditionalOnWebApplication、ConditionalOnResource、ConditionalOnProperty、ConditionalOnExpression等条件注解，有兴趣的读者可以自行查看它们的底层处理逻辑。</p>
<h2 id="各种条件注解的总结"><a href="#各种条件注解的总结" class="headerlink" title="各种条件注解的总结"></a>各种条件注解的总结</h2><table>
<thead>
<tr>
<th>条件注解</th>
<th>对应的Condition处理类</th>
<th>处理逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnBean</td>
<td>OnBeanCondition</td>
<td>Spring容器中是否存在对应的实例。可以通过实例的类型、类名、注解、昵称去容器中查找(可以配置从当前容器中查找或者父容器中查找或者两者一起查找)这些属性都是数组，通过”与”的关系进行查找</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>OnClassCondition</td>
<td>类加载器中是否存在对应的类。可以通过Class指定(value属性)或者Class的全名指定(name属性)。如果是多个类或者多个类名的话，关系是”与”关系，也就是说这些类或者类名都必须同时在类加载器中存在</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>OnExpressionCondition</td>
<td>判断SpEL 表达式是否成立</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>OnJavaCondition</td>
<td>指定Java版本是否符合要求。内部有2个属性value和range。value表示一个枚举的Java版本，range表示比这个老或者新于等于指定的Java版本(默认是新于等于)。内部会基于某些jdk版本特有的类去类加载器中查询，比如如果是jdk9，类加载器中需要存在java.security.cert.URICertStoreParameters；如果是jdk8，类加载器中需要存在java.util.function.Function；如果是jdk7，类加载器中需要存在java.nio.file.Files；如果是jdk6，类加载器中需要存在java.util.ServiceLoader</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>OnBeanCondition</td>
<td>Spring容器中是否缺少对应的实例。可以通过实例的类型、类名、注解、昵称去容器中查找(可以配置从当前容器中查找或者父容器中查找或者两者一起查找)这些属性都是数组，通过”与”的关系进行查找。还多了2个属性ignored(类名)和ignoredType(类名)，匹配的过程中会忽略这些bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>OnClassCondition</td>
<td>跟ConditionalOnClass的处理逻辑一样，只是条件相反，在类加载器中不存在对应的类</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>OnWebApplicationCondition</td>
<td>应用程序是否是非Web程序，没有提供属性，只是一个标识。会从判断Web程序特有的类是否存在，环境是否是Servlet环境，容器是否是Web容器等</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>OnPropertyCondition</td>
<td>应用环境中的屬性是否存在。提供prefix、name、havingValue以及matchIfMissing属性。prefix表示属性名的前缀，name是属性名，havingValue是具体的属性值，matchIfMissing是个boolean值，如果属性不存在，这个matchIfMissing为true的话，会继续验证下去，否则属性不存在的话直接就相当于匹配不成功</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>OnResourceCondition</td>
<td>是否存在指定的资源文件。只有一个属性resources，是个String数组。会从类加载器中去查询对应的资源文件是否存在</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>OnBeanCondition</td>
<td>Spring容器中是否存在且只存在一个对应的实例。只有3个属性value、type、search。跟ConditionalOnBean中的这3种属性值意义一样</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>OnWebApplicationCondition</td>
<td>应用程序是否是Web程序，没有提供属性，只是一个标识。会从判断Web程序特有的类是否存在，环境是否是Servlet环境，容器是否是Web容器等</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>例子</th>
<th>例子意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnBean(javax.sql.DataSource.class)</td>
<td>Spring容器或者所有父容器中需要存在至少一个javax.sql.DataSource类的实例</td>
</tr>
<tr>
<td>@ConditionalOnClass<br>({ Configuration.class,<br>FreeMarkerConfigurationFactory.class })</td>
<td>类加载器中必须存在Configuration和FreeMarkerConfigurationFactory这两个类</td>
</tr>
<tr>
<td>@ConditionalOnExpression<br>(“‘${server.host}’==’localhost’”)</td>
<td>server.host配置项的值需要是localhost</td>
</tr>
<tr>
<td>ConditionalOnJava(JavaVersion.EIGHT)</td>
<td>Java版本至少是8</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</td>
<td>Spring当前容器中不存在ErrorController类型的bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass<br>(“GenericObjectPool”)</td>
<td>类加载器中不能存在GenericObjectPool这个类</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>必须在非Web应用下才会生效</td>
</tr>
<tr>
<td>@ConditionalOnProperty(prefix = “spring.aop”, name = “auto”, havingValue = “true”, matchIfMissing = true)</td>
<td>应用程序的环境中必须有spring.aop.auto这项配置，且它的值是true或者环境中不存在spring.aop.auto配置(matchIfMissing为true)</td>
</tr>
<tr>
<td>@ConditionalOnResource<br>(resources=”mybatis.xml”)</td>
<td>类加载路径中必须存在mybatis.xml文件</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate<br>(PlatformTransactionManager.class)</td>
<td>Spring当前或父容器中必须存在PlatformTransactionManager这个类型的实例，且只有一个实例</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>必须在Web应用下才会生效</td>
</tr>
</tbody>
</table>
<h2 id="SpringBoot条件注解的激活机制"><a href="#SpringBoot条件注解的激活机制" class="headerlink" title="SpringBoot条件注解的激活机制"></a>SpringBoot条件注解的激活机制</h2><p>分析完了条件注解的执行逻辑之后，接下来的问题就是SpringBoot是如何让这些条件注解生效的？</p>
<p>SpringBoot使用ConditionEvaluator这个内部类完成条件注解的解析和判断。</p>
<p>在Spring容器的refresh过程中，只有跟解析或者注册bean有关系的类都会使用ConditionEvaluator完成条件注解的判断，这个过程中一些类不满足条件的话就会被skip。这些类比如有AnnotatedBeanDefinitionReader、ConfigurationClassBeanDefinitionReader、ConfigurationClassParse、ClassPathScanningCandidateComponentProvider等。</p>
<p>比如ConfigurationClassParser的构造函数会初始化内部属性conditionEvaluator：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConfigurationClassParser</span><span class="params">(MetadataReaderFactory metadataReaderFactory,</span></span></div><div class="line">    ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,</div><div class="line">    BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.metadataReaderFactory = metadataReaderFactory;</div><div class="line">  <span class="keyword">this</span>.problemReporter = problemReporter;</div><div class="line">  <span class="keyword">this</span>.environment = environment;</div><div class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</div><div class="line">  <span class="keyword">this</span>.registry = registry;</div><div class="line">  <span class="keyword">this</span>.componentScanParser = <span class="keyword">new</span> ComponentScanAnnotationParser(</div><div class="line">      resourceLoader, environment, componentScanBeanNameGenerator, registry);</div><div class="line">  <span class="comment">// 构造ConditionEvaluator用于处理条件注解</span></div><div class="line">  <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, resourceLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConfigurationClassParser对每个配置类进行解析的时候都会使用ConditionEvaluator：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConditionEvaluator的skip方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果这个类没有被@Conditional注解所修饰，不会skip</span></div><div class="line">  <span class="keyword">if</span> (metadata == <span class="keyword">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 如果参数中沒有设置条件注解的生效阶段</span></div><div class="line">  <span class="keyword">if</span> (phase == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// 是配置类的话直接使用PARSE_CONFIGURATION阶段</span></div><div class="line">    <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> AnnotationMetadata &amp;&amp;</div><div class="line">        ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</div><div class="line">      <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 否则使用REGISTER_BEAN阶段</span></div><div class="line">    <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 要解析的配置类的条件集合</span></div><div class="line">  List&lt;Condition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;Condition&gt;();</div><div class="line">  <span class="comment">// 获取配置类的条件注解得到条件数据，并添加到集合中</span></div><div class="line">  <span class="keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</div><div class="line">    <span class="keyword">for</span> (String conditionClass : conditionClasses) &#123;</div><div class="line">      Condition condition = getCondition(conditionClass, <span class="keyword">this</span>.context.getClassLoader());</div><div class="line">      conditions.add(condition);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 对条件集合做个排序</span></div><div class="line">  AnnotationAwareOrderComparator.sort(conditions);</div><div class="line">  <span class="comment">// 遍历条件集合</span></div><div class="line">  <span class="keyword">for</span> (Condition condition : conditions) &#123;</div><div class="line">    ConfigurationPhase requiredPhase = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> ConfigurationCondition) &#123;</div><div class="line">      requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行</span></div><div class="line">    <span class="keyword">if</span> (requiredPhase == <span class="keyword">null</span> || requiredPhase == phase) &#123;</div><div class="line">      <span class="comment">// 阶段一致切不满足条件的话，返回true并跳过这个bean的解析</span></div><div class="line">      <span class="keyword">if</span> (!condition.matches(<span class="keyword">this</span>.context, metadata)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpringBoot在条件注解的解析log记录在了ConditionEvaluationReport类中，可以通过BeanFactory获取(BeanFactory是有父子关系的；每个BeanFactory都存有一份ConditionEvaluationReport，互不相干)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ConditionEvaluationReport conditionEvaluationReport = beanFactory.getBean(<span class="string">"autoConfigurationReport"</span>, ConditionEvaluationReport.class);</div><div class="line">Map&lt;String, ConditionEvaluationReport.ConditionAndOutcomes&gt; result = conditionEvaluationReport.getConditionAndOutcomesBySource();</div><div class="line"><span class="keyword">for</span>(String key : result.keySet()) &#123;</div><div class="line">    ConditionEvaluationReport.ConditionAndOutcomes conditionAndOutcomes = result.get(key);</div><div class="line">    Iterator&lt;ConditionEvaluationReport.ConditionAndOutcome&gt; iterator = conditionAndOutcomes.iterator();</div><div class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">        ConditionEvaluationReport.ConditionAndOutcome conditionAndOutcome = iterator.next();</div><div class="line">        System.out.println(key + <span class="string">" -- "</span> + conditionAndOutcome.getCondition().getClass().getSimpleName() + <span class="string">" -- "</span> + conditionAndOutcome.getOutcome());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印出条件注解下的类加载信息：</p>
<pre><code>.......
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: freemarker.template.Configuration,org.springframework.ui.freemarker.FreeMarkerConfigurationFactory
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: groovy.text.markup.MarkupTemplateEngine
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: com.google.gson.Gson
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: org.h2.server.web.WebServlet
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: org.springframework.hateoas.Resource,org.springframework.plugin.core.Plugin
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: com.hazelcast.core.HazelcastInstance
.......
</code></pre><p>一些测试的例子代码在 <a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-conditional" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-conditional</a> 上</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot内部提供了特有的注解：条件注解(Conditional Annotation)。比如@ConditionalOnBean、@ConditionalOnClass、@ConditionalOnExpression、@ConditionalOnMissingBean等。&lt;/p&gt;
&lt;p&gt;条件注解存在的意义在于动态识别(也可以说是代码自动化执行)。比如@ConditionalOnClass会检查类加载器中是否存在对应的类，如果有的话被注解修饰的类就有资格被Spring容器所注册，否则会被skip。&lt;/p&gt;
&lt;p&gt;比如FreemarkerAutoConfiguration这个自动化配置类的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@ConditionalOnClass&lt;/span&gt;(&amp;#123; freemarker.template.Configuration.class,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		FreeMarkerConfigurationFactory.class &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@AutoConfigureAfter&lt;/span&gt;(WebMvcAutoConfiguration.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;(FreeMarkerProperties.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FreeMarkerAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个自动化配置类被@ConditionalOnClass条件注解修饰，这个条件注解存在的意义在于判断类加载器中是否存在freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类，如果都存在的话会在Spring容器中加载这个FreeMarkerAutoConfiguration配置类；否则不会加载。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之Spring容器的refresh过程</title>
    <link href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/"/>
    <id>http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/</id>
    <published>2017-05-10T11:55:21.000Z</published>
    <updated>2017-05-31T13:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们分析了SpringBoot的启动过程：构造SpringApplication并调用它的run方法。其中构造SpringApplication的时候会初始化一些监听器和初始化器；run方法调用的过程中会有对应的监听器监听，并且会创建Spring容器。</p>
<p>Spring容器创建之后，会调用它的refresh方法，refresh的时候会做很多事情：比如完成配置类的解析、各种BeanFactoryPostProcessor和BeanPostProcessor的注册、国际化配置的初始化、web内置容器的构造等等。</p>
<p>我们来分析一下这个refresh过程。</p>
<a id="more"></a>
<p>还是以web程序为例，那么对应的Spring容器为AnnotationConfigEmbeddedWebApplicationContext。它的refresh方法调用了父类AbstractApplicationContext的refresh方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">  <span class="comment">// refresh过程只能一个线程处理，不允许并发执行</span></div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">    prepareRefresh();</div><div class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line">    prepareBeanFactory(beanFactory);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      postProcessBeanFactory(beanFactory);</div><div class="line">      invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">      registerBeanPostProcessors(beanFactory);</div><div class="line">      initMessageSource();</div><div class="line">      initApplicationEventMulticaster();</div><div class="line">      onRefresh();</div><div class="line">      registerListeners();</div><div class="line">      finishBeanFactoryInitialization(beanFactory);</div><div class="line">      finishRefresh();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</div><div class="line">            <span class="string">"cancelling refresh attempt: "</span> + ex);</div><div class="line">      &#125;</div><div class="line">      destroyBeans();</div><div class="line">      cancelRefresh(ex);</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">      resetCommonCaches();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="prepareRefresh方法"><a href="#prepareRefresh方法" class="headerlink" title="prepareRefresh方法"></a>prepareRefresh方法</h2><p>表示在真正做refresh操作之前需要准备做的事情：</p>
<ol>
<li>设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。</li>
<li>初始化属性源信息(Property)</li>
<li>验证环境信息里一些必须存在的属性</li>
</ol>
<h2 id="prepareBeanFactory方法"><a href="#prepareBeanFactory方法" class="headerlink" title="prepareBeanFactory方法"></a>prepareBeanFactory方法</h2><p>从Spring容器获取BeanFactory(Spring Bean容器)并进行相关的设置为后续的使用做准备：</p>
<ol>
<li>设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)</li>
<li>添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。因为ApplicationContextAwareProcessor把这5个接口的实现工作做了</li>
<li>设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器</li>
<li>注入一些其它信息的bean，比如environment、systemProperties等</li>
</ol>
<h2 id="postProcessBeanFactory方法"><a href="#postProcessBeanFactory方法" class="headerlink" title="postProcessBeanFactory方法"></a>postProcessBeanFactory方法</h2><p>BeanFactory设置之后再进行后续的一些BeanFactory操作。</p>
<p>不同的Spring容器做不同的操作。比如GenericWebApplicationContext容器会在BeanFactory中添加ServletContextAwareProcessor用于处理ServletContextAware类型的bean初始化的时候调用setServletContext或者setServletConfig方法(跟ApplicationContextAwareProcessor原理一样)。</p>
<p>AnnotationConfigEmbeddedWebApplicationContext对应的postProcessBeanFactory方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">  <span class="comment">// 调用父类EmbeddedWebApplicationContext的实现</span></div><div class="line">  <span class="keyword">super</span>.postProcessBeanFactory(beanFactory);</div><div class="line">  <span class="comment">// 查看basePackages属性，如果设置了会使用ClassPathBeanDefinitionScanner去扫描basePackages包下的bean并注册</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.basePackages != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.basePackages.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.basePackages);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 查看annotatedClasses属性，如果设置了会使用AnnotatedBeanDefinitionReader去注册这些bean</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.annotatedClasses != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.annotatedClasses.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.reader.register(<span class="keyword">this</span>.annotatedClasses);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>父类EmbeddedWebApplicationContext的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">  beanFactory.addBeanPostProcessor(</div><div class="line">      <span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</div><div class="line">  beanFactory.ignoreDependencyInterface(ServletContextAware.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="invokeBeanFactoryPostProcessors方法"><a href="#invokeBeanFactoryPostProcessors方法" class="headerlink" title="invokeBeanFactoryPostProcessors方法"></a>invokeBeanFactoryPostProcessors方法</h2><p>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。</p>
<p>介绍两个接口：</p>
<ol>
<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>
<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>
</ol>
<p>基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：</p>
<pre><code>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
</code></pre><p>invokeBeanFactoryPostProcessors方法处理BeanFactoryPostProcessor的逻辑如下：</p>
<p>从Spring容器中找出BeanDefinitionRegistryPostProcessor类型的bean(这些processor是在容器刚创建的时候通过构造AnnotatedBeanDefinitionReader的时候注册到容器中的)，然后按照优先级分别执行，优先级的逻辑如下：</p>
<ol>
<li>实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor先全部找出来，然后排序后依次执行</li>
<li>实现Ordered接口的BeanDefinitionRegistryPostProcessor找出来，然后排序后依次执行</li>
<li>没有实现PriorityOrdered和Ordered接口的BeanDefinitionRegistryPostProcessor找出来执行并依次执行</li>
</ol>
<p>接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。</p>
<p>这里需要说明的是ConfigurationClassPostProcessor这个processor是优先级最高的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用ConfigurationClassParser去解析这个类。ConfigurationClassParser内部有个Map<configurationclass, configurationclass="">类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中。</configurationclass,></p>
<p>这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。</p>
<p>在我们的程序中，只有主类RefreshContextApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser解析。解析过程如下：</p>
<ol>
<li>处理@PropertySources注解：进行一些配置信息的解析</li>
<li>处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析</li>
<li>处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：<ol>
<li>遍历这些@Import注解内部的属性类集合</li>
<li>如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第6步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理</li>
<li>如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中</li>
<li>其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类</li>
</ol>
</li>
<li>处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中</li>
<li>处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中</li>
<li>处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理</li>
</ol>
<p>这里@SpringBootApplication注解被@EnableAutoConfiguration修饰，@EnableAutoConfiguration注解被@Import(EnableAutoConfigurationImportSelector.class)修饰，所以在第3步会找出这个@Import修饰的类EnableAutoConfigurationImportSelector，这个类刚好实现了DeferredImportSelector接口，接着就会在第6步被执行。第6步selectImport得到的类就是自动化配置类。</p>
<p>EnableAutoConfigurationImportSelector的selectImport方法会在spring.factories文件中找出key为EnableAutoConfiguration对应的值，有81个，这81个就是所谓的自动化配置类(XXXAutoConfiguration)。</p>
<p>ConfigurationClassParser解析完成之后，被解析出来的类会放到configurationClasses属性中。然后使用ConfigurationClassBeanDefinitionReader去解析这些类。</p>
<p>这个时候这些bean只是被加载到了Spring容器中。下面这段代码是ConfigurationClassBeanDefinitionReader的解析bean过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</div><div class="line">  TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</div><div class="line">  <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</div><div class="line">    <span class="comment">// 对每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法</span></div><div class="line">    loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span></div><div class="line">    TrackedConditionEvaluator trackedConditionEvaluator) &#123;</div><div class="line">  <span class="comment">// 使用条件注解判断是否需要跳过这个配置类</span></div><div class="line">  <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</div><div class="line">    <span class="comment">// 跳过配置类的话在Spring容器中移除bean的注册</span></div><div class="line">    String beanName = configClass.getBeanName();</div><div class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</div><div class="line">      <span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.importRegistry.removeImportingClassFor(configClass.getMetadata().getClassName());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</div><div class="line">    <span class="comment">// 如果自身是被@Import注释所import的，注册自己</span></div><div class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 注册方法中被@Bean注解修饰的bean</span></div><div class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</div><div class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 注册@ImportResource注解注释的资源文件中的bean</span></div><div class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</div><div class="line">  <span class="comment">// 注册@Import注解中的ImportBeanDefinitionRegistrar接口的registerBeanDefinitions</span></div><div class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>invokeBeanFactoryPostProcessors方法总结来说就是从Spring容器中找出BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的实现类并按照一定的规则顺序进行执行。 其中ConfigurationClassPostProcessor这个BeanDefinitionRegistryPostProcessor优先级最高，它会对项目中的@Configuration注解修饰的类(@Component、@ComponentScan、@Import、@ImportResource修饰的类也会被处理)进行解析，解析完成之后把这些bean注册到BeanFactory中。需要注意的是这个时候注册进来的bean还没有实例化。</p>
<h2 id="registerBeanPostProcessors方法"><a href="#registerBeanPostProcessors方法" class="headerlink" title="registerBeanPostProcessors方法"></a>registerBeanPostProcessors方法</h2><p>从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中。之后bean被实例化的时候会调用这个BeanPostProcessor。</p>
<p>该方法委托给了PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法执行。这里的过程跟invokeBeanFactoryPostProcessors类似：</p>
<ol>
<li>先找出实现了PriorityOrdered接口的BeanPostProcessor并排序后加到BeanFactory的BeanPostProcessor集合中</li>
<li>找出实现了Ordered接口的BeanPostProcessor并排序后加到BeanFactory的BeanPostProcessor集合中</li>
<li>没有实现PriorityOrdered和Ordered接口的BeanPostProcessor加到BeanFactory的BeanPostProcessor集合中</li>
</ol>
<p>这些已经存在的BeanPostProcessor在postProcessBeanFactory方法中已经说明，都是由AnnotationConfigUtils的registerAnnotationConfigProcessors方法注册的。这些BeanPostProcessor包括有AutowiredAnnotationBeanPostProcessor(处理被@Autowired注解修饰的bean并注入)、RequiredAnnotationBeanPostProcessor(处理被@Required注解修饰的方法)、CommonAnnotationBeanPostProcessor(处理@PreDestroy、@PostConstruct、@Resource等多个注解的作用)等。</p>
<p>如果是自定义的BeanPostProcessor，已经被ConfigurationClassPostProcessor注册到容器内。</p>
<p>这些BeanPostProcessor会在这个方法内被实例化(通过调用BeanFactory的getBean方法，如果没有找到实例化的类，就会去实例化)。</p>
<h2 id="initMessageSource方法"><a href="#initMessageSource方法" class="headerlink" title="initMessageSource方法"></a>initMessageSource方法</h2><p>在Spring容器中初始化一些国际化相关的属性。</p>
<h2 id="initApplicationEventMulticaster方法"><a href="#initApplicationEventMulticaster方法" class="headerlink" title="initApplicationEventMulticaster方法"></a>initApplicationEventMulticaster方法</h2><p>在Spring容器中初始化事件广播器，事件广播器用于事件的发布。</p>
<p>在<a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a>中分析过，EventPublishingRunListener这个SpringApplicationRunListener会监听事件，其中发生contextPrepared事件的时候EventPublishingRunListener会把事件广播器注入到BeanFactory中。</p>
<p>所以initApplicationEventMulticaster不再需要再次注册，只需要拿出BeanFactory中的事件广播器然后设置到Spring容器的属性中即可。如果没有使用SpringBoot的话，Spring容器得需要自己初始化事件广播器。</p>
<h2 id="onRefresh方法"><a href="#onRefresh方法" class="headerlink" title="onRefresh方法"></a>onRefresh方法</h2><p>一个模板方法，不同的Spring容器做不同的事情。</p>
<p>比如web程序的容器AnnotationConfigEmbeddedWebApplicationContext中会调用createEmbeddedServletContainer方法去创建内置的Servlet容器。</p>
<p>目前SpringBoot只支持3种内置的Servlet容器：</p>
<ol>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ol>
<h2 id="registerListeners方法"><a href="#registerListeners方法" class="headerlink" title="registerListeners方法"></a>registerListeners方法</h2><p>把Spring容器内的时间监听器和BeanFactory中的时间监听器都添加的事件广播器中。</p>
<p>然后如果存在early event的话，广播出去。</p>
<h2 id="finishBeanFactoryInitialization方法"><a href="#finishBeanFactoryInitialization方法" class="headerlink" title="finishBeanFactoryInitialization方法"></a>finishBeanFactoryInitialization方法</h2><p>实例化BeanFactory中已经被注册但是未实例化的所有实例(懒加载的不需要实例化)。</p>
<p>比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。</p>
<p>实例化的过程各种BeanPostProcessor开始起作用。</p>
<h2 id="finishRefresh方法"><a href="#finishRefresh方法" class="headerlink" title="finishRefresh方法"></a>finishRefresh方法</h2><p>refresh做完之后需要做的其他事情。</p>
<ol>
<li>初始化生命周期处理器，并设置到Spring容器中(LifecycleProcessor)</li>
<li>调用生命周期处理器的onRefresh方法，这个方法会找出Spring容器中实现了SmartLifecycle接口的类并进行start方法的调用</li>
<li>发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</li>
<li>调用LiveBeansView的registerApplicationContext方法：如果设置了JMX相关的属性，则就调用该方法</li>
<li>发布EmbeddedServletContainerInitializedEvent事件告知对应的ApplicationListener进行响应的操作</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring容器的refresh过程就是上述11个方法的介绍。内容还是非常多的，本文也只是说了个大概，像bean的实例化过程没有具体去分析，这方面的内容以后会看情况去做分析。</p>
<p>这篇文章也是为之后的文章比如内置Servlet容器的创建启动、条件注解的使用等打下基础。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>写了一个例子用来验证容器的refresh过程，包括bean解析，processor的使用、Lifecycle的使用等。</p>
<p>可以启动项目debug去看看对应的过程，这样对Spring容器会有一个更好的理解。</p>
<p>地址在：<a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-refresh-context" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-refresh-context</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，我们分析了SpringBoot的启动过程：构造SpringApplication并调用它的run方法。其中构造SpringApplication的时候会初始化一些监听器和初始化器；run方法调用的过程中会有对应的监听器监听，并且会创建Spring容器。&lt;/p&gt;
&lt;p&gt;Spring容器创建之后，会调用它的refresh方法，refresh的时候会做很多事情：比如完成配置类的解析、各种BeanFactoryPostProcessor和BeanPostProcessor的注册、国际化配置的初始化、web内置容器的构造等等。&lt;/p&gt;
&lt;p&gt;我们来分析一下这个refresh过程。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之SpringBoot的启动过程</title>
    <link href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/"/>
    <id>http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/</id>
    <published>2017-04-30T12:33:33.000Z</published>
    <updated>2017-05-31T13:20:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot的启动很简单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(MyApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。</p>
<p>因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。</p>
<p>我们以上述这段代码为例，分析SpringBoot的启动过程。</p>
<a id="more"></a>
<h2 id="SpringApplication的构造过程"><a href="#SpringApplication的构造过程" class="headerlink" title="SpringApplication的构造过程"></a>SpringApplication的构造过程</h2><p>SpringApplication构造的时候内部会调用一个private方法initialize：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Object... sources)</span> </span>&#123;</div><div class="line">  initialize(sources); <span class="comment">// sources目前是一个MyApplication的class对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.sources.addAll(Arrays.asList(sources)); <span class="comment">// 把sources设置到SpringApplication的sources属性中，目前只是一个MyApplication类对象</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.webEnvironment = deduceWebEnvironment(); <span class="comment">// 判断是否是web程序(javax.servlet.Servlet和org.springframework.web.context.ConfigurableWebApplicationContext都必须在类加载器中存在)，并设置到webEnvironment属性中</span></div><div class="line">  <span class="comment">// 从spring.factories文件中找出key为ApplicationContextInitializer的类并实例化后设置到SpringApplication的initializers属性中。这个过程也就是找出所有的应用程序初始化器</span></div><div class="line">  setInitializers((Collection) getSpringFactoriesInstances(</div><div class="line">      ApplicationContextInitializer.class));</div><div class="line">  <span class="comment">// 从spring.factories文件中找出key为ApplicationListener的类并实例化后设置到SpringApplication的listeners属性中。这个过程就是找出所有的应用程序事件监听器</span></div><div class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</div><div class="line">  <span class="comment">// 找出main类，这里是MyApplication类</span></div><div class="line">  <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ApplicationContextInitializer，应用程序初始化器，做一些初始化的工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ApplicationListener，应用程序事件(ApplicationEvent)监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的应用程序事件(ApplicationEvent)有应用程序启动事件(ApplicationStartedEvent)，失败事件(ApplicationFailedEvent)，准备事件(ApplicationPreparedEvent)等。</p>
<p>应用程序事件监听器跟监听事件是绑定的。比如ConfigServerBootstrapApplicationListener只跟ApplicationEnvironmentPreparedEvent事件绑定，LiquibaseServiceLocatorApplicationListener只跟ApplicationStartedEvent事件绑定，LoggingApplicationListener跟所有事件绑定等。</p>
<p>默认情况下，initialize方法从spring.factories文件中找出的key为ApplicationContextInitializer的类有：</p>
<ol>
<li>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer</li>
<li>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</li>
</ol>
<p>key为ApplicationListener的有：</p>
<ol>
<li>org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>org.springframework.boot.logging.LoggingApplicationListener</li>
<li>org.springframework.boot.logging.ClasspathLoggingApplicationListener</li>
<li>org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<h2 id="SpringApplication的执行"><a href="#SpringApplication的执行" class="headerlink" title="SpringApplication的执行"></a>SpringApplication的执行</h2><p>分析run方法之前，先看一下SpringApplication中的一些事件和监听器概念。</p>
<p>首先是SpringApplicationRunListeners类和SpringApplicationRunListener类的介绍。</p>
<p>SpringApplicationRunListeners内部持有SpringApplicationRunListener集合和1个Log日志类。用于SpringApplicationRunListener监听器的批量执行。</p>
<p>SpringApplicationRunListener看名字也知道用于监听SpringApplication的run方法的执行。</p>
<p>它定义了5个步骤：</p>
<ol>
<li>started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartedEvent)</li>
<li>environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent)</li>
<li>contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件)</li>
<li>contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent)</li>
<li>finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent)</li>
</ol>
<p>SpringApplicationRunListener目前只有一个实现类EventPublishingRunListener，它把监听的过程封装成了SpringApplicationEvent事件并让内部属性(属性名为multicaster)ApplicationEventMulticaster接口的实现类SimpleApplicationEventMulticaster广播出去，广播出去的事件对象会被SpringApplication中的listeners属性进行处理。</p>
<p>所以说SpringApplicationRunListener和ApplicationListener之间的关系是通过ApplicationEventMulticaster广播出去的SpringApplicationEvent所联系起来的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/startup2.jpg" alt=""></p>
<p>SpringApplication的run方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch(); <span class="comment">// 构造一个任务执行观察器</span></div><div class="line">  stopWatch.start(); <span class="comment">// 开始执行，记录开始时间</span></div><div class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</div><div class="line">  configureHeadlessProperty();</div><div class="line">  <span class="comment">// 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener</span></div><div class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</div><div class="line">  <span class="comment">// 上面分析过，会封装成SpringApplicationEvent事件然后广播出去给SpringApplication中的listeners所监听</span></div><div class="line">  <span class="comment">// 这里接受ApplicationStartedEvent事件的listener会执行相应的操作</span></div><div class="line">  listeners.started();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 构造一个应用程序参数持有类</span></div><div class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</div><div class="line">        args);</div><div class="line">    <span class="comment">// 创建Spring容器</span></div><div class="line">    context = createAndRefreshContext(listeners, applicationArguments);</div><div class="line">    <span class="comment">// 容器创建完成之后执行额外一些操作</span></div><div class="line">    afterRefresh(context, applicationArguments);</div><div class="line">    <span class="comment">// 广播出ApplicationReadyEvent事件给相应的监听器执行</span></div><div class="line">    listeners.finished(context, <span class="keyword">null</span>);</div><div class="line">    stopWatch.stop(); <span class="comment">// 执行结束，记录执行时间</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</div><div class="line">          .logStarted(getApplicationLog(), stopWatch);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> context; <span class="comment">// 返回Spring容器</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    handleRunFailure(context, listeners, ex); <span class="comment">// 这个过程报错的话会执行一些异常操作、然后广播出ApplicationFailedEvent事件给相应的监听器执行</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建容器的方法createAndRefreshContext如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title">createAndRefreshContext</span><span class="params">(</span></span></div><div class="line">    SpringApplicationRunListeners listeners,</div><div class="line">    ApplicationArguments applicationArguments) &#123;</div><div class="line">  ConfigurableApplicationContext context; <span class="comment">// 定义Spring容器</span></div><div class="line">  <span class="comment">// 创建应用程序的环境信息。如果是web程序，创建StandardServletEnvironment；否则，创建StandardEnvironment</span></div><div class="line">  ConfigurableEnvironment environment = getOrCreateEnvironment();</div><div class="line">  <span class="comment">// 配置一些环境信息。比如profile，命令行参数</span></div><div class="line">  configureEnvironment(environment, applicationArguments.getSourceArgs());</div><div class="line">  <span class="comment">// 广播出ApplicationEnvironmentPreparedEvent事件给相应的监听器执行</span></div><div class="line">  listeners.environmentPrepared(environment);</div><div class="line">  <span class="comment">// 环境信息的校对</span></div><div class="line">  <span class="keyword">if</span> (isWebEnvironment(environment) &amp;&amp; !<span class="keyword">this</span>.webEnvironment) &#123;</div><div class="line">    environment = convertToStandardEnvironment(environment);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode != Banner.Mode.OFF) &#123; <span class="comment">// 是否在控制台上打印自定义的banner</span></div><div class="line">    printBanner(environment);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create, load, refresh and run the ApplicationContext</span></div><div class="line">  context = createApplicationContext(); <span class="comment">// 创建Spring容器</span></div><div class="line">  context.setEnvironment(environment); <span class="comment">// 设置Spring容器的环境信息</span></div><div class="line">  postProcessApplicationContext(context); <span class="comment">// 回调方法，Spring容器创建之后做一些额外的事</span></div><div class="line">  applyInitializers(context); <span class="comment">// SpringApplication的的初始化器开始工作</span></div><div class="line">  <span class="comment">// 遍历调用SpringApplicationRunListener的contextPrepared方法。目前只是将这个事件广播器注册到Spring容器中</span></div><div class="line">  listeners.contextPrepared(context);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</div><div class="line">    logStartupProfileInfo(context);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 把应用程序参数持有类注册到Spring容器中，并且是一个单例</span></div><div class="line">  context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</div><div class="line">      applicationArguments);</div><div class="line"></div><div class="line">  Set&lt;Object&gt; sources = getSources();</div><div class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</div><div class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[sources.size()]));</div><div class="line">  <span class="comment">// 广播出ApplicationPreparedEvent事件给相应的监听器执行</span></div><div class="line">  listeners.contextLoaded(context);</div><div class="line"></div><div class="line">  <span class="comment">// Spring容器的刷新</span></div><div class="line">  refresh(context);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      context.registerShutdownHook();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</div><div class="line">      <span class="comment">// Not allowed in some environments.</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器的创建createApplicationContext方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</div><div class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 如果是web程序，那么构造org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext容器</span></div><div class="line">      <span class="comment">// 否则构造org.springframework.context.annotation.AnnotationConfigApplicationContext容器</span></div><div class="line">      contextClass = Class.forName(<span class="keyword">this</span>.webEnvironment</div><div class="line">          ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">          <span class="string">"Unable create a default ApplicationContext, "</span></div><div class="line">              + <span class="string">"please specify an ApplicationContextClass"</span>,</div><div class="line">          ex);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器创建之后有个回调方法postProcessApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessApplicationContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.webEnvironment) &#123; <span class="comment">// 如果是web程序</span></div><div class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123; <span class="comment">// 并且也是Spring Web容器</span></div><div class="line">			ConfigurableWebApplicationContext configurableContext = (ConfigurableWebApplicationContext) context;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123; <span class="comment">// 如果SpringApplication设置了是实例命名生成器，注册到Spring容器中</span></div><div class="line">				configurableContext.getBeanFactory().registerSingleton(</div><div class="line">						AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</div><div class="line">						<span class="keyword">this</span>.beanNameGenerator);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123; <span class="comment">// 如果SpringApplication设置了资源加载器，设置到Spring容器中</span></div><div class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> GenericApplicationContext) &#123;</div><div class="line">			((GenericApplicationContext) context)</div><div class="line">					.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> DefaultResourceLoader) &#123;</div><div class="line">			((DefaultResourceLoader) context)</div><div class="line">					.setClassLoader(<span class="keyword">this</span>.resourceLoader.getClassLoader());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化器做的工作，比如ContextIdApplicationContextInitializer会设置应用程序的id；AutoConfigurationReportLoggingInitializer会给应用程序添加一个条件注解解析器报告等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class="line">  <span class="comment">// 遍历每个初始化器，对调用对应的initialize方法</span></div><div class="line">  <span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</div><div class="line">    Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</div><div class="line">        initializer.getClass(), ApplicationContextInitializer.class);</div><div class="line">    Assert.isInstanceOf(requiredType, context, <span class="string">"Unable to call initializer."</span>);</div><div class="line">    initializer.initialize(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器的刷新refresh方法内部会做很多很多的事情：比如BeanFactory的设置，BeanFactoryPostProcessor接口的执行、BeanPostProcessor接口的执行、自动化配置类的解析、条件注解的解析、国际化的初始化等等。这部分内容会在之后的文章中进行讲解。</p>
<p>run方法中的Spring容器创建完成之后会调用afterRefresh方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context,</span></span></div><div class="line">     ApplicationArguments args) &#123;</div><div class="line">   afterRefresh(context, args.getSourceArgs()); <span class="comment">// 目前是个空实现</span></div><div class="line">   callRunners(context, args); <span class="comment">// 调用Spring容器中的ApplicationRunner和CommandLineRunner接口的实现类</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</div><div class="line">	List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line">   <span class="comment">// 找出Spring容器中ApplicationRunner接口的实现类</span></div><div class="line">	runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</div><div class="line">   <span class="comment">// 找出Spring容器中CommandLineRunner接口的实现类</span></div><div class="line">	runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</div><div class="line">   <span class="comment">// 对runners进行排序</span></div><div class="line">	AnnotationAwareOrderComparator.sort(runners);</div><div class="line">   <span class="comment">// 遍历runners依次执行</span></div><div class="line">	<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</div><div class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123; <span class="comment">// 如果是ApplicationRunner，进行ApplicationRunner的run方法调用</span></div><div class="line">			callRunner((ApplicationRunner) runner, args);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123; <span class="comment">// 如果是CommandLineRunner，进行CommandLineRunner的run方法调用</span></div><div class="line">			callRunner((CommandLineRunner) runner, args);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样run方法执行完成之后。Spring容器也已经初始化完成，各种监听器和初始化器也做了相应的工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SpringBoot启动的时候，不论调用什么方法，都会构造一个SpringApplication的实例，然后调用这个实例的run方法，这样就表示启动SpringBoot。</p>
<p>在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：</p>
<ol>
<li>把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数。本文的例子中这个sources就是MyApplication的class对象</li>
<li>判断是否是web程序，并设置到webEnvironment这个boolean属性中</li>
<li>找出所有的初始化器，默认有5个，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，默认有9个，设置到listeners属性中</li>
<li>找出运行的主类(main class)</li>
</ol>
<p>SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：</p>
<ol>
<li>构造一个StopWatch，观察SpringApplication的执行</li>
<li>找出所有的SpringApplicationRunListener并封装到SpringApplicationRunListeners中，用于监听run方法的执行。监听的过程中会封装成事件并广播出去让初始化过程中产生的应用程序监听器进行监听</li>
<li>构造Spring容器(ApplicationContext)，并返回<br>3.1 创建Spring容器的判断是否是web环境，是的话构造AnnotationConfigEmbeddedWebApplicationContext，否则构造AnnotationConfigApplicationContext<br>3.2 初始化过程中产生的初始化器在这个时候开始工作<br>3.3 Spring容器的刷新(完成bean的解析、各种processor接口的执行、条件注解的解析等等)</li>
<li>从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>写了一个例子用来验证分析的启动逻辑，包括自定义的初始化器、监听器、ApplicationRunner和CommandLineRunner。</p>
<p>地址在：<a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-startup" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-startup</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot的启动很简单，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyApplication&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        SpringApplication.run(MyApplication.class, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。&lt;/p&gt;
&lt;p&gt;因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。&lt;/p&gt;
&lt;p&gt;我们以上述这段代码为例，分析SpringBoot的启动过程。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>记录自己理解的一些设计模式</title>
    <link href="http://fangjian0423.github.io/2017/03/26/design-pattern/"/>
    <id>http://fangjian0423.github.io/2017/03/26/design-pattern/</id>
    <published>2017-03-26T07:33:29.000Z</published>
    <updated>2017-03-26T07:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下自己理解的一些设计模式，并尽量使用表达清楚的例子进行讲解。</p>
<a id="more"></a>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式应该是最基础的一个设计模式，它是对行为的一个抽象。jdk中的Comparator比较器就是一个使用策略设计模式的策略。</p>
<p>比如有一个Student学生类，有name和age两个属性。如果有个需求需要打印学生名单，并按照字母顺序排序，可以使用Comparator接口并在内部使用name进行比较即可。 如果哪一天需要按照年龄进行排序，那么只需要修改Comparator即可，也就是使用一个新的策略，其它完全不变。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式的意义在于对象的创建、管理可以使用工厂去管理，而不是创建者自身。最典型的工厂模式使用者就是Spring，Spring内部的容器就是一个工厂，所有的bean都由这个容器管理，包括它们的创建、销毁、注入都被这个容器管理。</p>
<p>工厂模式分简单工厂和抽象工厂。它们的区别在于抽象工厂抽象程度更高，把工厂也抽象成了一个接口，这样可以再每添加一个新的对象的时候而不需要修改工厂的代码。</p>
<p>比如有个Repository接口，用于存储数据，有DatabaseRepository，CacheRepository，FileRepository分别在数据库，缓存，文件中存储数据，定义如下：</p>
<pre><code>public interface Repository {
    void save(Object obj);
}

class DatabaseRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in database&quot;);
    }
}
class CacheRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in cache&quot;);
    }
}
class FileRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in file&quot;);
    }
}
</code></pre><h3 id="简单工厂的使用"><a href="#简单工厂的使用" class="headerlink" title="简单工厂的使用"></a>简单工厂的使用</h3><pre><code>public class RepositoryFactory {

    public Repository create(String type) {
        Repository repository = null;
        switch (type) {
            case &quot;db&quot;:
                repository = new DatabaseRepository();
                break;
            case &quot;cache&quot;:
                repository = new CacheRepository();
                break;
            case &quot;file&quot;:
                repository = new FileRepository();
                break;
        }
        return repository;
    }

    public static void main(String[] args) {
        RepositoryFactory factory = new RepositoryFactory();
        factory.create(&quot;db&quot;).save(new Object());
        factory.create(&quot;cache&quot;).save(new Object());
        factory.create(&quot;file&quot;).save(new Object());
    }
}
</code></pre><p>简单工厂的弊端在于每添加一个新的Repository，都必须修改RepositoryFactory中的代码</p>
<h3 id="抽象工厂的使用"><a href="#抽象工厂的使用" class="headerlink" title="抽象工厂的使用"></a>抽象工厂的使用</h3><pre><code>public interface RepositoryFactoryProvider {
    Repository create();
}

class DatabaseRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new DatabaseRepository();
    }
}
class CacheRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new CacheRepository();
    }
}
class FileRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new FileRepository();
    }
}
</code></pre><p>抽象工厂的测试：</p>
<pre><code>RepositoryFactoryProvider dbProvider = new DatabaseRepositoryFactory();
dbProvider.create().save(new Object());
RepositoryFactoryProvider cacheProvider = new CacheRepositoryFactory();
cacheProvider.create().save(new Object());
RepositoryFactoryProvider fileProvider = new FileRepositoryFactory();
fileProvider.create().save(new Object());
</code></pre><p>抽象工厂把工厂也进行了抽象话，所以添加一个新的Repository的话，只需要新增一个RepositoryFactory即可，原有代码不需要修改。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式的作用就在于它可以在不改变原有类的基础上动态地给类添加新的功能。之前写过一篇<a href="http://www.cnblogs.com/fangjian0423/p/mybatis-cache.html" target="_blank" rel="external">通过源码分析MyBatis的缓存</a>文章，mybatis中的query就是使用了装饰者设计模式。</p>
<p>用一段简单的代码来模拟一下mybatis中query的实现原理：</p>
<pre><code>@Data
@AllArgsConstructor
@ToString
class Result { // 查询结果类，相当于一个domain
  private Object obj;
  private String sql;
}

public interface Query { // 查询接口，有简单查询和缓存查询
  Result query(String sql);
}

public class SimpleQuery implements Query { // 简单查询，相当于直接查询数据库，这里直接返回Result，相当于是数据库查询的结果
  @Override
  public Result query(String sql) {
      return new Result(new Object(), sql);
  }
}

public class CacheQuery implements Query { // 缓存查询，如果查询相同的sql，不直接查询数据库，而是返回map中存在的Result
  private Query query;
  private Map&lt;String, Result&gt; cache = new HashMap&lt;&gt;();
  public CacheQuery(Query query) {
      this.query = query;
  }
  @Override
  public Result query(String sql) {
      if(cache.containsKey(sql)) {
          return cache.get(sql);
      }
      Result result = query.query(sql);
      cache.put(sql, result);
      return result;
  }
}
</code></pre><p>测试：</p>
<pre><code>Query simpleQuery = new SimpleQuery();
System.out.println(simpleQuery.query(&quot;select * from t_student&quot;) == simpleQuery.query(&quot;select * from t_student&quot;)); // false
Query cacheQuery = new CacheQuery(simpleQuery);
System.out.println(cacheQuery.query(&quot;select * from t_student&quot;) == cacheQuery.query(&quot;select * from t_student&quot;)); // true
</code></pre><p>这里CacheQuery就是一个装饰类，SimpleQuery是一个被装饰者。我们通过装饰者设计模式动态地给SimpleQuery添加了缓存功能，而不需要修改SimpleQuery的代码。</p>
<p>当然，装饰者模式也有缺点，就是会存在太多的类。</p>
<p>如果我们需要添加一个过滤的查询(sql中有敏感字的就直接返回null，而不查询数据库)，只需要可以添加一个FilterQuery装饰者即可：</p>
<pre><code>public class FilterQuery implements Query {
    private Query query;
    private List&lt;String&gt; words = new ArrayList&lt;&gt;();
    public FilterQuery(Query query) {
        this.query = query;
        words.add(&quot;fuck&quot;);
        words.add(&quot;sex&quot;);
    }
    @Override
    public Result query(String sql) {
        for(String word : words) {
            if(sql.contains(word)) return null;
        }
        return query.query(sql);
    }
}

Query filterQuery = new FilterQuery(simpleQuery);
System.out.println(filterQuery.query(&quot;select * from t_student where name = &apos;fuck&apos;&quot;));  // null
System.out.println(filterQuery.query(&quot;select * from t_student where name = &apos;format&apos;&quot;)); // Result(obj=java.lang.Object@1b4fb997, sql=select * from t_student where name = &apos;format&apos;)
</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的作用是使用一个代理类来代替原先类进行操作。比较常见的就是aop中就是使用代理模式完成事务的处理。</p>
<p>代理模式分静态代理和动态代理，静态代理的原理就是对目标对象进行封装，最后调用目标对象的方法即可。</p>
<p>动态代理跟静态代理的区别就是动态代理中的代理类是程序运行的时候生成的。Spring中对于接口的代理使用jdk内置的Proxy和InvocationHandler实现，对于类的代理使用cglib完成。</p>
<p>以1个UserService为例，使用jdk自带的代理模式完成计算方法调用时间的需求：</p>
<pre><code>// UserService接口
public interface IUserService {
    void printAll();
}
// UserService实现类
class UserService implements IUserService {
    @Override
    public void printAll() {
        System.out.println(&quot;print all users&quot;);
    }
}
// InvocationHandler策略，这里打印了方法调用前后的时间
@AllArgsConstructor
class UserInvocationHandler implements InvocationHandler {
    private IUserService userService;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;start : &quot; + System.currentTimeMillis());
        Object result = method.invoke(userService, args);
        System.out.println(&quot;end : &quot; + System.currentTimeMillis());
        return result;
    }
}
</code></pre><p>测试：</p>
<pre><code>IUserService userService = new UserService();
UserInvocationHandler uih = new UserInvocationHandler(userService);
IUserService proxy = (IUserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), new Class[] {IUserService.class}, uih);
proxy.printAll(); // 打印出start : 1489665566456  print all users  end : 1489665566457
</code></pre><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式经常跟策略模式配合使用，用来组合所有的策略，并遍历这些策略找出满足条件的策略。之前写过一篇<a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html" target="_blank" rel="external">SpringMVC关于json、xml自动转换的原理研究</a>文章，里面springmvc把返回的返回值映射给用户的response做了一层抽象，封装到了HandlerMethodReturnValueHandler策略接口中。</p>
<p>在HandlerMethodReturnValueHandlerComposite类中，使用存在的HandlerMethodReturnValueHandler对返回值进行处理，在HandlerMethodReturnValueHandlerComposite内部的代码如下：</p>
<pre><code>// 策略集合
private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;HandlerMethodReturnValueHandler&gt;();

@Override
public void handleReturnValue(Object returnValue, MethodParameter returnType,
    ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    // 调用selectHandler方法
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) {
      throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
    }
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); // 使用找到的handler进行处理
}

private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {
    boolean isAsyncValue = isAsyncReturnValue(value, returnType);
    // 遍历存在的HandlerMethodReturnValueHandler
    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
      if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
        continue;
      }
      if (handler.supportsReturnType(returnType)) { // 找到匹配的handler
        return handler;
      }
    }
    return null;
}
</code></pre><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>跟策略模式类似，模板模式会先定义好实现的逻辑步骤，但是具体的实现方式由子类完成，跟策略模式的区别就是模板模式是有逻辑步骤的。比如要给院系里的学生排序，并取出排名第一的学生。这里就有2个步骤，分别是排序和取出第一名学生。</p>
<p>一段伪代码：</p>
<pre><code>public abstract class AbstractStudentGetter {
    public final Student getStudent(List&lt;Student&gt; students) {
        sort(students); // 第一步
        if(!CollectionUtils.isEmpty(students)) {
            return students.get(0);  // 第二步
        }
        return null;
    }
    abstract public void sort(List&lt;Student&gt; students);
}
class AgeStudentGetter extends AbstractStudentGetter { // 取出年纪最大的学生
    @Override
    public void sort(List&lt;Student&gt; students) {
        students.sort(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student s1, Student s2) {
                return s2.getAge() - s1.getAge();
            }
        });
    }
}
class NameStudentGetter extends AbstractStudentGetter { // 按照名字字母排序取出第一个学生
    @Override
    public void sort(List&lt;Student&gt; students) {
        students.sort(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student s1, Student s2) {
                return s2.getName().compareTo(s1.getName());
            }
        });
    }
}
</code></pre><p>测试：</p>
<pre><code>AbstractStudentGetter ageGetter = new AgeStudentGetter();
AbstractStudentGetter nameGetter = new NameStudentGetter();

List&lt;Student&gt; students = new ArrayList&lt;&gt;();
students.add(new Student(&quot;jim&quot;, 22));
students.add(new Student(&quot;format&quot;, 25));

System.out.println(ageGetter.getStudent(students)); // Student(name=format, age=25)
System.out.println(nameGetter.getStudent(students)); // Student(name=jim, age=22)
</code></pre><h2 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h2><p>观察者设计模式主要的使用场景在于一个对象变化之后，依赖该对象的对象会收到通知。典型的例子就是rss的订阅，当订阅了博客的rss之后，当博客更新之后，订阅者就会收到新的订阅信息。</p>
<p>jdk内置提供了Observable和Observer，用来实现观察者模式：</p>
<pre><code>// 定义一个Observable
public class MetricsObserable extends Observable {
    private Map&lt;String, Long&gt; counterMap = new HashMap&lt;&gt;();
    public void updateCounter(String key, Long value) {
        counterMap.put(key, value);
        setChanged();
        notifyObservers(counterMap);
    }
}
// Observer
public class AdminA implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;adminA: &quot; + arg);
    }
}
public class AdminB implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;adminB: &quot; + arg);
    }
}
</code></pre><p>测试：</p>
<pre><code>MetricsObserable metricsObserable = new MetricsObserable();
metricsObserable.addObserver(new AdminA());
metricsObserable.addObserver(new AdminB());
metricsObserable.updateCounter(&quot;request-count&quot;, 100l);
</code></pre><p>打印出：</p>
<pre><code>adminB: {request-count=100}
adminA: {request-count=100}
</code></pre><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>线程池中会构造几个核心线程用于处理，这些线程会去取阻塞队列里的任务然后进行执行。这些线程就是会被共享、且被重复使用的。因为线程的创建、销毁、调度都是需要消耗资源的，没有必要每次创建新的线程，而是共用一些线程。这就是享元模式的使用。类似的还有jdbc连接池，对象池等。</p>
<p>之前有一次面试被问到：</p>
<pre><code>Integer.valueOf(&quot;1&quot;) == Integer.valueOf(&quot;1&quot;) // true还是false
</code></pre><p>当时回答的是false，后来翻了下Integer的源码发现Integer里面有个内部类IntegerCache，用于缓存一些共用的Integer。这个缓存的范围可以在jvm启动的时候进行设置。</p>
<p>其实后来想想也应该这么做，我们没有必要每次使用对象的时候都返回新的对象，可以共享这些对象，因为新对象的创建都是需要消耗内存的。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式比较好理解。像生活中插线口的插头有2个口的，也有3个口的。如果电脑的电源插口只有3个口的，但是我们需要一个2个口的插口的话，这个时候就需要使用插座来外接这个3个口的插头，插座上有2个口的插头。</p>
<p>这个例子跟我们编程一样，当用户系统的接口跟我们系统内部的接口不一致时，我们可以使用适配器来完成接口的转换。</p>
<p>使用继承的方式实现类的适配：</p>
<pre><code>public class Source {
    public void method() {
        System.out.println(&quot;source method&quot;);
    }
}
interface Targetable {
    void method();
    void newMethod();
}
class Adapter extends Source implements Targetable {
    @Override
    public void newMethod() {
        System.out.println(&quot;new method&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>Targetable targetable = new Adapter();
targetable.method(); // source method
targetable.newMethod(); // new method
</code></pre><p>上述方式是用接口和继承的方式实现适配器模式。当然我们也可以使用组合的方式实现(把Source当成属性放到Adapter中)。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式比较好理解，Spring就是典型的例子。被Spring中的容器管理的对象都有对应的scope，配置成singleton说明这个对象就是单例，也就是在Spring容器的生命周期中，这个类只有1个实例。</p>
<p>java中单例模式的写法也有好多种。比如懒汉式、饿汉式、内部类方式、枚举方式等。</p>
<p>需要注意的如果使用dcl的话需要初始化过程，这篇<a href="http://cmsblogs.com/?p=2161&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="external">Java内存模型之从JMM角度分析DCL</a>文章中说明了dcl的正确用法。</p>
<p>Effectice java中推荐的单例方式写法是使用枚举类型的方式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式用来包装一组接口用于方便使用。 比如系统中分10个模块，有个功能需要组合使用所有的模块，这个时候就需要一个包装类包装这10个接口，然后进行业务逻辑的调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下自己理解的一些设计模式，并尽量使用表达清楚的例子进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://fangjian0423.github.io/categories/architecture/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="architecture" scheme="http://fangjian0423.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud网关服务zuul介绍</title>
    <link href="http://fangjian0423.github.io/2017/02/22/springcloud-zuul/"/>
    <id>http://fangjian0423.github.io/2017/02/22/springcloud-zuul/</id>
    <published>2017-02-22T13:33:22.000Z</published>
    <updated>2017-05-31T13:55:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/zuul" target="_blank" rel="external">Zuul</a>是Netflix开发的一款提供动态路由、监控、弹性、安全的网关服务。</p>
<p>使用Zuul网关服务带来的好处是统一向外系统提供REST API，并额外提供了权限控制、负载均衡等功能，并且这些功能是从原先的服务中抽离出来并单独存在的。</p>
<p>Zuul提供了不同类型的filter用于处理请求，这些filter可以让我们实现以下功能：</p>
<ol>
<li>权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求</li>
<li>监控：监控请求信息</li>
<li>动态路由：根据需要动态地路由请求到后台的不同集群</li>
<li>压力测试</li>
<li>负载均衡</li>
<li>静态资源处理：直接在zuul处理静态资源的响应而不需要转发这些请求到内部集群中</li>
</ol>
<a id="more"></a>
<h2 id="Zuul的执行过程介绍"><a href="#Zuul的执行过程介绍" class="headerlink" title="Zuul的执行过程介绍"></a>Zuul的执行过程介绍</h2><p>Zuul基于Servlet实现，它封装了Servlet提供的相关接口，并提供了一个全新的api。</p>
<p><strong>ZuulFilter</strong>是一个基础的抽象类，定义了一些抽象方法：</p>
<ol>
<li>filterType方法: filter的类型，有”pre”, “route”, “post”, “error”, “static”</li>
<li>filterOrder方法：优先级，级别越高，越快被执行</li>
<li>shouldFilter方法：开关，如果是true，run方法会执行，否则不会执行</li>
<li>run方法：filter执行的逻辑操作</li>
</ol>
<p><strong>ZuulServlet</strong>是一个继承自HttpServlet的子类，使用Zuul所有的请求都会被这个Servlet接收并处理。</p>
<p>ZuulServlet覆盖了HttpServlet的service方法，所以不论是get/post/put/delete等方法都会执行相同的操作：</p>
<pre><code>@Override
public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException {
    try {
        init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse); // 初始化ZuulRunner，也就是包装request和response，并设置到RequestContext中，RequestContext使用ThreadLocal获得，每个线程独立保存一份，用于存储各种信息，比如request，response，监控信息，异常信息，成功信息，执行时间等等

        // Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets
        // explicitly bound in web.xml, for which requests will not have the same data attached
        RequestContext context = RequestContext.getCurrentContext();
        context.setZuulEngineRan();

        try {
            preRoute(); // 执行 pre 类型的filter
        } catch (ZuulException e) {
            error(e); // pre 类型的filter执行报错的话执行 error 类型的filter
            postRoute(); // 执行 post 类型的filter
            return;
        }
        try {
            route(); // pre 类型的filter执行成功后，执行 route 类型的filter
        } catch (ZuulException e) {
            error(e); //route 类型的filter执行报错的话执行 error 类型的filter
            postRoute(); // 执行 post 类型的filter
            return;
        }
        try {
            postRoute(); // route 类型的filter执行成功后，执行 post 类型的filter
        } catch (ZuulException e) {
            error(e); //post 类型的filter执行报错的话执行 error 类型的filter
            return;
        }

    } catch (Throwable e) {
        error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName())); // 发生其他没有catch的错误的话，执行 error 类型的filter
    } finally {
        RequestContext.getCurrentContext().unset();
    }
}
</code></pre><p>下图是<a href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_blank" rel="external">zuul wiki</a>上对filter的执行过程说明。</p>
<p><img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="filter"></p>
<p>从上面的service方法中我们也可以得出：先执行pre类型的filter；如果pre filter执行失败那么执行error和post类型的filter，pre filter执行成功的话执行route类型的filter；如果route filter执行失败那么执行error和post类型的filter，route filter执行成功的话执行post filter；如果post filter执行失败那么执行error类型的filter，post filter执行成功的话，结束。上述过程中执行失败指的是ZuulException被catch，如果是其他Exception的话，那么执行error类型的filter，然后结束。</p>
<p>ZuulServlet里的preRoute(), route(), postRoute(), error()方法详情：</p>
<pre><code>ZuulRunner.java
public void preRoute() throws ZuulException {
    FilterProcessor.getInstance().preRoute();
}

FilterProcessor.java
public void preRoute() throws ZuulException {
    try {
        runFilters(&quot;pre&quot;);
    } catch (Throwable e) {
        if (e instanceof ZuulException) {
            throw (ZuulException) e;
        }
        throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());
    }
}

public Object runFilters(String sType) throws Throwable {
    if (RequestContext.getCurrentContext().debugRouting()) {
        Debug.addRoutingDebug(&quot;Invoking {&quot; + sType + &quot;} type filters&quot;);
    }
    boolean bResult = false;
    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType); // 获得对应类型的filter集合
    if (list != null) {
        for (int i = 0; i &lt; list.size(); i++) { // 遍历这些类型的filter集合
            ZuulFilter zuulFilter = list.get(i);
            Object result = processZuulFilter(zuulFilter); // 调用processZuulFilter方法
            if (result != null &amp;&amp; result instanceof Boolean) {
                bResult |= ((Boolean) result);
            }
        }
    }
    return bResult;
}

public Object processZuulFilter(ZuulFilter filter) throws ZuulException {

    RequestContext ctx = RequestContext.getCurrentContext();
    boolean bDebug = ctx.debugRouting();
    final String metricPrefix = &quot;zuul.filter-&quot;;
    long execTime = 0; // 执行时间
    String filterName = &quot;&quot;;
    try {
        long ltime = System.currentTimeMillis(); // 执行前的时间
        filterName = filter.getClass().getSimpleName(); // 获取filter名字

        RequestContext copy = null;
        Object o = null;
        Throwable t = null;

        if (bDebug) {
            Debug.addRoutingDebug(&quot;Filter &quot; + filter.filterType() + &quot; &quot; + filter.filterOrder() + &quot; &quot; + filterName);
            copy = ctx.copy();
        }

        ZuulFilterResult result = filter.runFilter(); // 调用ZuulFilter的runFilter方法得到ZuulFilterResult，这个类是对filter执行结果的包装，包括返回值、异常信息、状态
        ExecutionStatus s = result.getStatus(); // 得到ZuulFilterResult的状态信息
        execTime = System.currentTimeMillis() - ltime; // 得到filter的执行时间

        switch (s) { // 针对不同的ZuulFilterResult的状态做不同处理
            case FAILED: // 如果是FAILED状态，说错run方法执行失败了
                t = result.getException(); // 得到失败的异常
                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime); // 失败信息加到RequestContext中
                break;
            case SUCCESS: // 如果是SUCCESS状态，说明run方法正确执行完毕
                o = result.getResult(); // 得到run方法返回的结果
                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime); // 成功信息加到RequestContext中
                if (bDebug) {
                    Debug.addRoutingDebug(&quot;Filter {&quot; + filterName + &quot; TYPE:&quot; + filter.filterType() + &quot; ORDER:&quot; + filter.filterOrder() + &quot;} Execution time = &quot; + execTime + &quot;ms&quot;);
                    Debug.compareContextState(filterName, copy);
                }
                break;
            default: // 其他状态的话不做处理
                break;
        }

        if (t != null) throw t; // 如果是FAILED状态，抛出这个Exception

        usageNotifier.notify(filter, s); // 记录监控信息
        return o;

    } catch (Throwable e) { // 如果发生了一些其它没有catch的异常
        if (bDebug) {
            Debug.addRoutingDebug(&quot;Running Filter failed &quot; + filterName + &quot; type:&quot; + filter.filterType() + &quot; order:&quot; + filter.filterOrder() + &quot; &quot; + e.getMessage());
        }
        usageNotifier.notify(filter, ExecutionStatus.FAILED); // 记录监控信息
        if (e instanceof ZuulException) {
            throw (ZuulException) e;
        } else { // 封装成ZuulException并抛出
            ZuulException ex = new ZuulException(e, &quot;Filter threw Exception&quot;, 500, filter.filterType() + &quot;:&quot; + filterName);
            ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);
            throw ex;
        }
    }
}

ZuulFilter.java
public ZuulFilterResult runFilter() {
    ZuulFilterResult zr = new ZuulFilterResult();
    if (!isFilterDisabled()) { // 如果对应的zuul filter没有被disable
        if (shouldFilter()) { // shouldFilter开关是否开启
            Tracer t = TracerFactory.instance().startMicroTracer(&quot;ZUUL::&quot; + this.getClass().getSimpleName()); // 设置监控信息
            try {
                Object res = run(); // 调用ZuulFilter的run方法
                zr = new ZuulFilterResult(res, ExecutionStatus.SUCCESS); // 把结果封装到ZuulFilterResult中，并设置状态为SUCCESS
            } catch (Throwable e) { // 如果发生了异常
                t.setName(&quot;ZUUL::&quot; + this.getClass().getSimpleName() + &quot; failed&quot;); // 完善监控信息
                zr = new ZuulFilterResult(ExecutionStatus.FAILED); // 把ZuulFilterResult状态设置为FAILED
                zr.setException(e); // 设置异常信息
            } finally {
                t.stopAndLog();
            }
        } else {
            zr = new ZuulFilterResult(ExecutionStatus.SKIPPED); // zuul filter被disable的话，把ZuulFilterResult状态设置为SKIPPED
        }
    }
    return zr;
}
</code></pre><h2 id="在SpringCloud中使用Zuul"><a href="#在SpringCloud中使用Zuul" class="headerlink" title="在SpringCloud中使用Zuul"></a>在SpringCloud中使用Zuul</h2><p>在SpringCloud中使用Zuul，加上@EnableZuulProxy注解，这个注解会import ZuulProxyConfiguration配置类。ZuulProxyConfiguration配置类继承ZuulConfiguration类，ZuulConfiguration配置类使用zuul开头的配置。</p>
<p>在这个例子中，本地端口2222有了compute-service服务。这个zuul的服务地址暴露在7777端口下。</p>
<p>我们定义了一个规则：</p>
<pre><code>zuul.routes.api-a-url.path=/api-a-url/**
zuul.routes.api-a-url.url=http://localhost:2222/
</code></pre><p>这个routes对应的类型是Map<string, zuulroute="">，key为String，value是一个ZuulRoute。ZuulRoute中定义了一些属性，有：</string,></p>
<pre><code>private String id; // 标识一个路由规则
private String path; // 拦截路径，比如 /api-a-url/**
private String serviceId; // Eureka服务发现中的serviceId
private String url; //不使用服务发现中的服务，独立的一个url
private boolean stripPrefix = true;
private Boolean retryable; // 是否会retry
private Set&lt;String&gt; sensitiveHeaders = new LinkedHashSet&lt;&gt;();
</code></pre><p>上面的api-a-url就是对应map中的key，path和url对应ZuulRoute中的path和url属性。</p>
<p>在ZuulProxyConfiguration配置类中，构造了很多bean，比如有ZuulController、ZuulHandlerMapping、DiscoveryClientRouteLocator、各种filter等bean。</p>
<p>其中ZuulController内部使用了ZuulServlet处理http请求，DiscoveryClientRouteLocator使用ZuulProperties中的route解析路由规则，然后封装成org.springframework.cloud.netflix.zuul.filters.Route在getRoutes方法中返回，这个方法会在RoutesEndpoint和ZuulHandlerMapping中被调用。</p>
<p>另外DiscoveryClientRouteLocator会基于服务发现中心中的服务信息，再去寻找对应的路由规则。由于例子中有个本地端口为2222的compute-service服务。所以会被解析并放到路由规则里，这样路由规则里就有2个规则：</p>
<ol>
<li>path为/api-a-url/**，url为<a href="http://localhost:2222/" target="_blank" rel="external">http://localhost:2222/</a></li>
<li>path为/compute-service/**，serviceId为compute-service</li>
</ol>
<p>ZuulHandlerMapping是一个HandlerMapping，用于处理请求的映射关系。在SpringMVC中，默认是使用RequestMappingHandlerMapping处理，而在Zuul中，使用ZuulHandlerMapping处理地址映射关系。它内部有个注册handler方法：</p>
<pre><code>private void registerHandlers() {
  Collection&lt;Route&gt; routes = this.routeLocator.getRoutes(); // 得到路由规则
  if (routes.isEmpty()) {
    this.logger.warn(&quot;No routes found from RouteLocator&quot;);
  }
  else {
    for (Route route : routes) { // 注册路由规则中的地址，对应了handler是zuul属性，这个zuul也就是ZuulController
      registerHandler(route.getFullPath(), this.zuul);
    }
  }
}
</code></pre><p>例子中路由规则里对应的路径有2个，分别是/api-a-url/<strong>和/compute-service/</strong>，它们对应的handler都是ZuulController。</p>
<p>访问地址：</p>
<pre><code>http://localhost:7777/api-a-url/add?a=1&amp;b=2
</code></pre><p>在ZuulHandlerMapping中的规则路径中发现了/api-a-url/**，于是传递给ZuulController处理，ZuulController传递给ZuulServlet处理。</p>
<p>讲到这里，细心的读者可能会发现一个问题：<strong>我们前面讲了这么多关于filter的各种细节，但是真正的服务调用是在哪里执行的?</strong></p>
<p>Zuul把真正的服务调用也放在了filter中处理，并在产生的结果放在了RequestContext中。</p>
<p>其中有route类型的filter中使用HttpClient执行，执行结果的stream放到了RequestContext。</p>
<p>post类型的filter读取这个stream并使用response write出去。</p>
<p>我们来简单看下这个过程中一些filter的各自实现。</p>
<p>SimpleHostRoutingFilter这个route类型的filter的shouldFilter方法：</p>
<pre><code>@Override
public boolean shouldFilter() {
  // 如果对应的地址是使用host方式，才会生效
  return RequestContext.getCurrentContext().getRouteHost() != null
      &amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();
}
</code></pre><p>run方法：</p>
<pre><code>@Override
public Object run() {
  RequestContext context = RequestContext.getCurrentContext();
  HttpServletRequest request = context.getRequest();
  MultiValueMap&lt;String, String&gt; headers = this.helper
      .buildZuulRequestHeaders(request);
  MultiValueMap&lt;String, String&gt; params = this.helper
      .buildZuulRequestQueryParams(request);
  String verb = getVerb(request);
  InputStream requestEntity = getRequestBody(request);
  if (request.getContentLength() &lt; 0) {
    context.setChunkedRequestBody();
  }

  String uri = this.helper.buildZuulRequestURI(request);
  this.helper.addIgnoredHeaders();

  try {
    HttpResponse response = forward(this.httpClient, verb, uri, request, headers,
        params, requestEntity); // 使用HttpClient调用remoteHost
    setResponse(response); // 设置remoteHost调用的结果
  }
  catch (Exception ex) {
    context.set(&quot;error.status_code&quot;,
        HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    context.set(&quot;error.exception&quot;, ex);
  }
  return null;
}

// setResponse方法会把response中的stream放到RequestContext中
context.setResponseDataStream(entity);
</code></pre><p>RibbonRoutingFilter跟SimpleHostRoutingFilter类似，区别就是它的shouldFilter方法里不是判断host方式，而是判断路由规则里是否存在serviceId。它的run方法也是使用HttpClient完成服务的调用，但是它是使用ribbon完成的。</p>
<p>访问地址：</p>
<pre><code>http://localhost:7777/compute-service/add?a=1&amp;b=2
</code></pre><p>由于使用了serviceId的方式，所以会触发RibbonRoutingFilter并完成服务的调用。</p>
<p>当使用Eureka服务发现的时候，建议使用serviceId的方式，而不是直接host的方式。因为基于serviceId的方式会使用ribbon完成服务的调用，ribbon中又使用了hystrix和loadbalance等功能，有更好的健壮性。</p>
<p>SendResponseFilter是一个post类型的，它会写回服务调用产生的结果。</p>
<pre><code>@Override
public boolean shouldFilter() {
  // RibbonRoutingFilter和SimpleHostRoutingFilter都会写入stream数据到RequestContext中的responseDataStream中，所以这个filter会生效
  return !RequestContext.getCurrentContext().getZuulResponseHeaders().isEmpty()
      || RequestContext.getCurrentContext().getResponseDataStream() != null
      || RequestContext.getCurrentContext().getResponseBody() != null;
}

@Override
  public Object run() {
      try {
          addResponseHeaders();
    // 最终在RequestContext中使用response write这个stream
          writeResponse();
      }
      catch (Exception ex) {
          ReflectionUtils.rethrowRuntimeException(ex);
      }
      return null;
  }
</code></pre><p>SpringCloud默认还加了其它的一些拦截器，有兴趣的读者可以自行查看源代码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Zuul内部的处理使用ZuulServlet完成，ZuulServlet继承HttpServlet，重写了service方法，service方法内部分别是pre、route、post和error类型的filter进行调用。这里的不同类型的filter执行顺序文中已经说明。</p>
<p>要在SpringCloud中使用Zuul，需要加上@EnableZuulProxy注解。加上这个注解之后SpringCloud会构造一些bean，比如ZuulHandlerMapping、DiscoveryClientRouteLocator、各种filter等。其中DiscoveryClientRouteLocator是一个基于服务发现的路由规则生成器，它会基于zuul的配置构造路由规则。ZuulHandlerMapping是一个HandlerMapping的实现，它跟基于路由规则注册handler，其中key为路由规则对应的路径，handler都是ZuulController，ZuulController内部使用ZuulServlet进行请求的处理。</p>
<p>Zuul把真正的服务调用放在了filter中实现。它提供了SimpleHostRoutingFilter和RibbonRoutingFilter这2个route类型的filter用于执行服务。从名字也可以看出来，SimpleHostRoutingFilter用于执行基于host方式的调用url接口，RibbonRoutingFilter基于服务发现的方式调用服务。一般我们都建议使用RibbonRoutingFilter，因为它内部使用ribbon，更加健壮。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>RoutesEndpoint这个endpoint使用RouteLocator中提供的所有路由规则。</p>
<p>访问：</p>
<pre><code>http://localhost:7777/routes
</code></pre><p>得到路由规则：</p>
<pre><code>{
    /api-a-url/**: &quot;http://localhost:2222/&quot;,
    /compute-service/**: &quot;compute-service&quot;
}
</code></pre><p>Zuul声称自己可以使用static类型的filter用于处理静态资源，也提供了一个StaticResponseFilter的一个基类，但是查看ZuulServlet的源码发现没有哪段逻辑是处理静态资源的。 上了github发现专门有个<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1001" target="_blank" rel="external">issue</a>说明目前还不支持自定义的filter。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/Netflix/zuul/" target="_blank" rel="external">https://github.com/Netflix/zuul/</a></p>
<p><a href="https://github.com/Netflix/zuul/wiki" target="_blank" rel="external">https://github.com/Netflix/zuul/wiki</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/zuul&quot;&gt;Zuul&lt;/a&gt;是Netflix开发的一款提供动态路由、监控、弹性、安全的网关服务。&lt;/p&gt;
&lt;p&gt;使用Zuul网关服务带来的好处是统一向外系统提供REST API，并额外提供了权限控制、负载均衡等功能，并且这些功能是从原先的服务中抽离出来并单独存在的。&lt;/p&gt;
&lt;p&gt;Zuul提供了不同类型的filter用于处理请求，这些filter可以让我们实现以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求&lt;/li&gt;
&lt;li&gt;监控：监控请求信息&lt;/li&gt;
&lt;li&gt;动态路由：根据需要动态地路由请求到后台的不同集群&lt;/li&gt;
&lt;li&gt;压力测试&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;静态资源处理：直接在zuul处理静态资源的响应而不需要转发这些请求到内部集群中&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/tags/springcloud/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud使用Hystrix实现断路器</title>
    <link href="http://fangjian0423.github.io/2017/02/19/springcloud-hystrix/"/>
    <id>http://fangjian0423.github.io/2017/02/19/springcloud-hystrix/</id>
    <published>2017-02-19T04:11:39.000Z</published>
    <updated>2017-02-21T08:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">Hystrix</a>是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。</p>
<p>比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。</p>
<p>SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败。</p>
<p><img src="http://cloud.spring.io/spring-cloud-static/Brixton.SR7/images/HystrixFallback.png" alt="image"></p>
<a id="more"></a>
<h2 id="Hystrix的简单使用"><a href="#Hystrix的简单使用" class="headerlink" title="Hystrix的简单使用"></a>Hystrix的简单使用</h2><p>Hystrix使用了命令设计模式，只需要编写命令即可：</p>
<pre><code>public class CommandHelloWorld extends HystrixCommand&lt;String&gt; {

    private final String name;

    public CommandHelloWorld(String name) {
        super(HystrixCommandGroupKey.Factory.asKey(&quot;HelloWorld&quot;));
        this.name = name;
    }

    @Override
    protected String run() throws Exception { // 完成业务逻辑
        return &quot;Hello &quot; + name + &quot;!&quot;;
    }

    @Override
    protected String getFallback() { // run方法抛出异常的时候返回备用结果
        return &quot;Hello Failure &quot; + name + &quot;!&quot;;
    }

}
</code></pre><p>测试用例：</p>
<pre><code>@Test
public void test() {
    assertEquals(&quot;Hello World!&quot;, new CommandHelloWorld(&quot;World&quot;).execute());
    assertEquals(&quot;Hello Format!&quot;, new CommandHelloWorld(&quot;Format&quot;).execute());
}
</code></pre><p>可能有的人觉得写Command有点麻烦，Hystrix提供了一个类库<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica" target="_blank" rel="external">javanica</a>，可以使用@HystrixCommand注解完成命令的编写。</p>
<h2 id="在SpringCloud中使用Hystrix"><a href="#在SpringCloud中使用Hystrix" class="headerlink" title="在SpringCloud中使用Hystrix"></a>在SpringCloud中使用Hystrix</h2><p>要在SpringCloud中使用断路器，需要加上@EnableCircuitBreaker注解：</p>
<pre><code>...
@EnableCircuitBreaker
...
public class RibbonApplication { ... }
</code></pre><p>然后在对应的方法上加入@HystrixCommand注解实现断路器功能，当service方法对应的服务发生异常的时候，会跳转到serviceFallback方法执行：</p>
<pre><code>@HystrixCommand(fallbackMethod = &quot;serviceFallback&quot;) // 加入@HystrixCommand注解实现断路器功能
public String service() { // 原先的方法
    return restTemplate.getForEntity(&quot;...&quot;, String.class).getBody();
}

public String serviceFallback() { // fallback方法
    return &quot;error&quot;;
}
</code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>加上@EnableCircuitBreaker注解之后，就可以使用断路器功能，所以SpringCloud内部是如何整合Hystrix的话先从这个注解开始分析。</p>
<p>@EnableCircuitBreaker注解定义如下：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(EnableCircuitBreakerImportSelector.class)
public @interface EnableCircuitBreaker {

}
</code></pre><p>import了EnableCircuitBreakerImportSelector这个selector：</p>
<pre><code>public class EnableCircuitBreakerImportSelector extends
    SpringFactoryImportSelector&lt;EnableCircuitBreaker&gt; {

    @Override
    protected boolean isEnabled() {
        return new RelaxedPropertyResolver(getEnvironment()).getProperty(
            &quot;spring.cloud.circuit.breaker.enabled&quot;, Boolean.class, Boolean.TRUE);
    }

}
</code></pre><p>在之前的这篇<a href="http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/">SpringBoot自动化配置的注解开关原理</a>文章中分析过selector的原理，这个EnableCircuitBreakerImportSelector会加载spring.factories属性文件中key为org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker的类：</p>
<pre><code>org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\
    org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration
</code></pre><p>会加载HystrixCircuitBreakerConfiguration这个配置类。</p>
<p>这个配置类内部构造了一个aspect：</p>
<pre><code>@Bean
public HystrixCommandAspect hystrixCommandAspect() {
    return new HystrixCommandAspect();
}
</code></pre><p>这个aspect对应的pointcut如下，所以使用@HystrixCommand注解修饰的方法会被这个aspect处理：</p>
<pre><code>@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand) || @annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)
</code></pre><p>对应的aop处理方法：</p>
<pre><code>public Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint joinPoint) throws Throwable {
    Method method = getMethodFromTarget(joinPoint);  // 得到初始的方法
    Validate.notNull(method, &quot;failed to get method from joinPoint: %s&quot;, joinPoint);
    if (method.isAnnotationPresent(HystrixCommand.class) &amp;&amp; method.isAnnotationPresent(HystrixCollapser.class)) { // 如果使用@HystrixCommand注解和@HystrixCollapser注解同时修改，不允许
        throw new IllegalStateException(&quot;method cannot be annotated with HystrixCommand and HystrixCollapser &quot; +
                &quot;annotations at the same time&quot;);
    }
    MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));
    MetaHolder metaHolder = metaHolderFactory.create(joinPoint); // 创建一个MetaHolder，这个MetaHolder封装了方法中的一些以及Hystrix的一些信息
    HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder); // 根据这个metaHolder创建出一个HystrixInvokable，也就是一个HystrixCommand
    ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ?
            metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType(); // 得到执行类型，有3种类型：1. 异步 2. 同步  3. reactive
    Object result;
    try {
        result = CommandExecutor.execute(invokable, executionType, metaHolder);
    } catch (HystrixBadRequestException e) {
        throw e.getCause();
    }
    return result;
}
</code></pre><p>CommandExecutor的execute方法：</p>
<pre><code>public static Object execute(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {
    Validate.notNull(invokable);
    Validate.notNull(metaHolder);

    switch (executionType) {
        case SYNCHRONOUS: { // 同步方式的话，调用HystrixCommand的execute方法
            return castToExecutable(invokable, executionType).execute();
        }
        case ASYNCHRONOUS: { // 异步方式的话，调用HystrixCommand的queue方法
            HystrixExecutable executable = castToExecutable(invokable, executionType);
            if (metaHolder.hasFallbackMethodCommand()
                    &amp;&amp; ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()) {
                return new FutureDecorator(executable.queue());
            }
            return executable.queue();
        }
        case OBSERVABLE: { // reactive方式的话，调用HystrixCommand的observe或者toObservable方法
            HystrixObservable observable = castToObservable(invokable);
            return ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ? observable.observe() : observable.toObservable();
        }
        default:
            throw new RuntimeException(&quot;unsupported execution type: &quot; + executionType);
    }
}
</code></pre><p>根据metaHolder创建出HystrixCommand的过程在HystrixCommandBuilderFactory中：</p>
<pre><code>return HystrixCommandBuilder.builder()
            .setterBuilder(createGenericSetterBuilder(metaHolder))
            .commandActions(createCommandActions(metaHolder))
            .collapsedRequests(collapsedRequests)
            .cacheResultInvocationContext(createCacheResultInvocationContext(metaHolder))
            .cacheRemoveInvocationContext(createCacheRemoveInvocationContext(metaHolder))
            .ignoreExceptions(metaHolder.getHystrixCommand().ignoreExceptions())
            .executionType(metaHolder.getExecutionType())
            .build();
</code></pre><p>所以这个aspect的作用就是把一个普通的Java方法转换成HystrixCommand。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>HystrixCircuitBreakerConfiguration配置类中有个HystrixWebConfiguration内部配置类，它构造了一个HystrixStreamEndpoint这个endpoint，这个endpoint使用HystrixMetricsStreamServlet暴露出/hystrix.stream地址来获取hystrix的metrics信息。</p>
<p>Hystrix还提供了一个dashboard，这个dashboard可以查看各个断路器的健康状况，要使用这个dashboard，在项目中加入这些依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后在代码里加上开关：</p>
<pre><code>@EnableHystrixDashboard
...
</code></pre><p>启动项目，打开：</p>
<pre><code>http://localhost:3333/hystrix
</code></pre><p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hystrix01.png" alt="image"><br>输入：</p>
<pre><code>http://localhost:3333/hystrix.stream
</code></pre><p>我们使用wrk模拟请求：</p>
<pre><code>wrk -c 10 -t 10 -d 20s http://localhost:3333/add
</code></pre><p>然后dashboard中发生了变化：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/hystrix02.png" alt="image"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://cloud.spring.io/spring-cloud-static/Brixton.SR7/" target="_blank" rel="external">http://cloud.spring.io/spring-cloud-static/Brixton.SR7/</a></p>
<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="external">https://github.com/Netflix/Hystrix/wiki</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot;&gt;Hystrix&lt;/a&gt;是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。&lt;/p&gt;
&lt;p&gt;比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离机制，系统随时就有可能会挂掉，从而带来很大的风险。&lt;/p&gt;
&lt;p&gt;SpringCloud使用Hystrix组件提供断路器、资源隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cloud.spring.io/spring-cloud-static/Brixton.SR7/images/HystrixFallback.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/categories/springcloud/"/>
    
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/tags/springcloud/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Loadbalance的几种算法以及在ribbon中的使用</title>
    <link href="http://fangjian0423.github.io/2017/01/29/loadbalance/"/>
    <id>http://fangjian0423.github.io/2017/01/29/loadbalance/</id>
    <published>2017-01-29T11:32:16.000Z</published>
    <updated>2017-01-29T11:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。</p>
<p>像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。</p>
<p>使用负载均衡带来的好处很明显：</p>
<ol>
<li>当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用</li>
<li>使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升</li>
</ol>
<p>负载均衡有好几种实现策略，常见的有：</p>
<ol>
<li>随机 (Random)</li>
<li>轮询 (RoundRobin)</li>
<li>一致性哈希 (ConsistentHash)</li>
<li>哈希 (Hash)</li>
<li>加权（Weighted）</li>
</ol>
<a id="more"></a>
<p>我们以<a href="https://github.com/Netflix/ribbon" target="_blank" rel="external">ribbon</a>的实现为基础，看看其中的一些算法是如何实现的。</p>
<p>ribbon是一个为客户端提供负载均衡功能的服务，它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，比如有添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表等等。</p>
<p>还提供了一个叫做IRule的接口代表负载均衡策略：</p>
<pre><code>public interface IRule{
    public Server choose(Object key);
    public void setLoadBalancer(ILoadBalancer lb);
    public ILoadBalancer getLoadBalancer();    
}
</code></pre><p>IRule接口的实现类有以下几种：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/loadbalance01.png" alt="image"></p>
<p>其中RandomRule表示随机策略、RoundRobin表示轮询策略、WeightedResponseTimeRule表示加权策略、BestAvailableRule表示请求数最少策略等等。</p>
<p>随机策略很简单，就是从服务器中随机选择一个服务器，RandomRule的实现代码如下：</p>
<pre><code>public Server choose(ILoadBalancer lb, Object key) {
    if (lb == null) {
        return null;
    }
    Server server = null;

    while (server == null) {
        if (Thread.interrupted()) {
            return null;
        }
        List&lt;Server&gt; upList = lb.getReachableServers();
        List&lt;Server&gt; allList = lb.getAllServers();
        int serverCount = allList.size();
        if (serverCount == 0) {
            return null;
        }
        int index = rand.nextInt(serverCount); // 使用jdk内部的Random类随机获取索引值index
        server = upList.get(index); // 得到服务器实例

        if (server == null) {
            Thread.yield();
            continue;
        }

        if (server.isAlive()) {
            return (server);
        }

        server = null;
        Thread.yield();
    }
    return server;
}
</code></pre><p>RoundRobin轮询策略表示每次都取下一个服务器，比如一共有5台服务器，第1次取第1台，第2次取第2台，第3次取第3台，以此类推：</p>
<pre><code>public Server choose(ILoadBalancer lb, Object key) {
    if (lb == null) {
        log.warn(&quot;no load balancer&quot;);
        return null;
    }

    Server server = null;
    int count = 0;
    while (server == null &amp;&amp; count++ &lt; 10) { // retry 10 次
        List&lt;Server&gt; reachableServers = lb.getReachableServers();
        List&lt;Server&gt; allServers = lb.getAllServers();
        int upCount = reachableServers.size();
        int serverCount = allServers.size();

        if ((upCount == 0) || (serverCount == 0)) {
            log.warn(&quot;No up servers available from load balancer: &quot; + lb);
            return null;
        }

        int nextServerIndex = incrementAndGetModulo(serverCount); // incrementAndGetModulo方法内部使用nextServerCyclicCounter这个AtomicInteger属性原子递增对serverCount取模得到索引值
        server = allServers.get(nextServerIndex); // 得到服务器实例

        if (server == null) {
            Thread.yield();
            continue;
        }

        if (server.isAlive() &amp;&amp; (server.isReadyToServe())) {
            return (server);
        }

        server = null;
    }

    if (count &gt;= 10) {
        log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;
                + lb);
    }
    return server;
}
</code></pre><p>BestAvailableRule策略用来选取最少并发量请求的服务器：</p>
<pre><code>public Server choose(Object key) {
    if (loadBalancerStats == null) {
        return super.choose(key);
    }
    List&lt;Server&gt; serverList = getLoadBalancer().getAllServers(); // 获取所有的服务器列表
    int minimalConcurrentConnections = Integer.MAX_VALUE;
    long currentTime = System.currentTimeMillis();
    Server chosen = null;
    for (Server server: serverList) { // 遍历每个服务器
        ServerStats serverStats = loadBalancerStats.getSingleServerStat(server); // 获取各个服务器的状态
        if (!serverStats.isCircuitBreakerTripped(currentTime)) { // 没有触发断路器的话继续执行
            int concurrentConnections = serverStats.getActiveRequestsCount(currentTime); // 获取当前服务器的请求个数
            if (concurrentConnections &lt; minimalConcurrentConnections) { // 比较各个服务器之间的请求数，然后选取请求数最少的服务器并放到chosen变量中
                minimalConcurrentConnections = concurrentConnections;
                chosen = server;
            }
        }
    }
    if (chosen == null) { // 如果没有选上，调用父类ClientConfigEnabledRoundRobinRule的choose方法，也就是使用RoundRobinRule轮询的方式进行负载均衡        
        return super.choose(key);
    } else {
        return chosen;
    }
}
</code></pre><h2 id="实例验证Ribbon中的LoadBalance功能"><a href="#实例验证Ribbon中的LoadBalance功能" class="headerlink" title="实例验证Ribbon中的LoadBalance功能"></a>实例验证Ribbon中的LoadBalance功能</h2><p>ServerList中提供了3个instance，分别是：</p>
<pre><code>compute-service:2222
compute-service:2223
compute-service:2224
</code></pre><p>然后使用不同的IRule策略查看负载均衡的实现。</p>
<p>首先先使用ribbon提供的LoadBalanced注解加在RestTemplate上面，这个注解会自动构造LoadBalancerClient接口的实现类并注册到Spring容器中。</p>
<pre><code>@Bean
@LoadBalanced
RestTemplate restTemplate() {
    return new RestTemplate();
}
</code></pre><p>接下来使用RestTemplate进行rest操作的时候，会自动使用负载均衡策略，它内部会在RestTemplate中加入LoadBalancerInterceptor这个拦截器，这个拦截器的作用就是使用负载均衡。</p>
<p>例子中，我们的实例的name叫做compute-service，里面提供了一个方法add用于相加2个Integer类型的数值。</p>
<p>loadbalance的具体操作：</p>
<pre><code>public String loadbalance() {
    ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;compute-service&quot;);
    StringBuilder sb = new StringBuilder();
    sb.append(&quot;host: &quot;).append(serviceInstance.getHost()).append(&quot;, &quot;);
    sb.append(&quot;port: &quot;).append(serviceInstance.getPort()).append(&quot;, &quot;);
    sb.append(&quot;uri: &quot;).append(serviceInstance.getUri());
    return sb.toString();
}
</code></pre><h3 id="RandomRule随机策略"><a href="#RandomRule随机策略" class="headerlink" title="RandomRule随机策略"></a>RandomRule随机策略</h3><p>RandomRule：</p>
<pre><code>@Configuration
public class RibbonConfiguration {

    @Autowired
    private SpringClientFactory springClientFactory;

    @Bean
    public IRule ribbonRule() {
        return new RandomRule();
    }

}
</code></pre><p>测试结果如下，确实是随机获取的：</p>
<pre><code>host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223    
</code></pre><h3 id="RoundRobinRule轮询策略"><a href="#RoundRobinRule轮询策略" class="headerlink" title="RoundRobinRule轮询策略"></a>RoundRobinRule轮询策略</h3><p>RoundRobinRule：</p>
<pre><code>@Bean
public IRule ribbonRule() {
    return new RandomRule();
}
</code></pre><p>测试结果如下，确实是轮询每个服务器的：</p>
<pre><code>host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2222, uri: http://192.168.31.113:2222
host: 192.168.31.113, port: 2224, uri: http://192.168.31.113:2224
</code></pre><h3 id="BestAvailableRule最少并发数策略"><a href="#BestAvailableRule最少并发数策略" class="headerlink" title="BestAvailableRule最少并发数策略"></a>BestAvailableRule最少并发数策略</h3><p>BestAvailableRule：</p>
<pre><code>@Bean
public IRule ribbonRule() {
    return new BestAvailableRule();
}
</code></pre><p>如果直接访问浏览器的话，测试结果如下(因为每次访问完请求数都变成0，下次遍历永远都是2223这个端口的实例)：</p>
<pre><code>host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
host: 192.168.31.113, port: 2223, uri: http://192.168.31.113:2223
..
</code></pre><p>使用wrk模拟并发请求，结果会出现多个实例：</p>
<pre><code>wrk -c 1000 -t 10 -d 10s http://localhost:3333/test
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。&lt;/p&gt;
&lt;p&gt;像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。&lt;/p&gt;
&lt;p&gt;使用负载均衡带来的好处很明显：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用&lt;/li&gt;
&lt;li&gt;使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;负载均衡有好几种实现策略，常见的有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机 (Random)&lt;/li&gt;
&lt;li&gt;轮询 (RoundRobin)&lt;/li&gt;
&lt;li&gt;一致性哈希 (ConsistentHash)&lt;/li&gt;
&lt;li&gt;哈希 (Hash)&lt;/li&gt;
&lt;li&gt;加权（Weighted）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/categories/springcloud/"/>
    
    
      <category term="algorithm" scheme="http://fangjian0423.github.io/tags/algorithm/"/>
    
      <category term="springcloud" scheme="http://fangjian0423.github.io/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>2016总结</title>
    <link href="http://fangjian0423.github.io/2017/01/01/2016_end/"/>
    <id>http://fangjian0423.github.io/2017/01/01/2016_end/</id>
    <published>2017-01-01T14:28:04.000Z</published>
    <updated>2017-01-01T14:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2016年总结"><a href="#2016年总结" class="headerlink" title="2016年总结"></a>2016年总结</h2><p>2016年过去了，转眼已经毕业3年多了，时间过得很快。对自己有点失望，感觉技术还没有达到自己期望的那个3年水平。</p>
<p>有进步的地方：</p>
<ol>
<li>blog从每天的200-300pv增加到了500-600pv。2016年一年达到了9w4 pv，没有突破10w，有点小遗憾。不过这不是重点，写博客的初衷是为了自己对知识点的总结，并不在乎pv</li>
<li>补了一下java的基础知识；包括常用数据结构底层的实现，数组、链表、哈希表、红黑树、跳表等；aqs、juc包下的各个工具类实现原理；jvm的一些知识点。基础好真的很关键，不然看一些东西的时候，里面的一些知识点是基础知识，不了解的话还得重新去补基础知识</li>
<li>把springboot的实现原理看了一下，这样就可以知道官方或者一些第三方提供的starter底层到底做了什么事情。不然只能查阅官方文档，文档里如果又没写相关内容的话，还是得看源码解决。最后自己尝试着写了个starter练练手</li>
<li>熟悉了一下springcloud和dubbo这2个框架。以前rpc相关的只是用过hessian框架，发现dubbo很强大，封装地也很好，而且文档也很详细，是一个值得学习的好框架</li>
<li>学习了一下netty和nio相关的内容，由于工作中没有用到，算是自我补充了知识点</li>
<li>把flume的一些组件的源码看了一遍，发现了有不合理的地方，但是进行改进的话也会引入其他的一些问题。flume的实现还是有缺陷的，需要配合一些额外的操作才能把数据收集这块做得更好。比如实时报错，错误数据重跑，重启策略等</li>
<li>写了spark相关的计算，由于精力有限，并没有深入地研究spark的东西</li>
<li>看了分布式相关的一些内容，比如一致性哈希、心跳检测、分布式锁、cap原理等</li>
</ol>
<p>懂了一些道理：</p>
<ol>
<li>自己觉得对的事情，一定要尽早去做，不然可能会来不及，如果错过后，就会很后悔</li>
<li>拥有的时候，一定要珍惜。等到失去后，会很后悔</li>
<li>要有耐心地听别人说话，不能显得很不耐烦</li>
<li>对自己说的话要负责，话说出去就收不回来了</li>
<li>做决定前，要冷静。伤害了别人也等于伤害了自己</li>
<li>换位思考。对别人做的事，别人反过来也对你这么做，自己是什么感受</li>
</ol>
<p>2017年的计划还没有想过，最近发生了很多事，等稳定下来后再去定计划。</p>
]]></content>
    
    <summary type="html">
    
      2016年总结
    
    </summary>
    
      <category term="总结" scheme="http://fangjian0423.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="杂事" scheme="http://fangjian0423.github.io/tags/%E6%9D%82%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot编写自定义的starter</title>
    <link href="http://fangjian0423.github.io/2016/11/16/springboot-custom-starter/"/>
    <id>http://fangjian0423.github.io/2016/11/16/springboot-custom-starter/</id>
    <published>2016-11-15T17:40:32.000Z</published>
    <updated>2016-11-23T07:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们分析过SpringBoot内部的<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">自动化配置原理</a>和<a href="http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/">自动化配置注解开关原理</a>。</p>
<p>我们先简单分析一下<a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="external">mybatis starter</a>的编写，然后再编写自定义的starter。</p>
<p>mybatis中的autoconfigure模块中使用了一个叫做MybatisAutoConfiguration的自动化配置类。</p>
<p>这个MybatisAutoConfiguration需要在这些Condition条件下才会执行：</p>
<ol>
<li>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })。需要SqlSessionFactory和SqlSessionFactoryBean在classpath中都存在</li>
<li>@ConditionalOnBean(DataSource.class)。 spring factory中需要存在一个DataSource的bean</li>
<li>@AutoConfigureAfter(DataSourceAutoConfiguration.class)。需要在DataSourceAutoConfiguration自动化配置之后进行配置，因为mybatis需要数据源的支持</li>
</ol>
<p>同时在META-INF目录下有个spring.factories这个properties文件，而且它的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，这样才会被springboot加载：</p>
<pre><code># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
</code></pre><p>有了这些东西之后，mybatis相关的配置会被自动加入到spring container中，只要在maven中加入starter即可：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><a id="more"></a>
<h2 id="编写自定义的starter"><a href="#编写自定义的starter" class="headerlink" title="编写自定义的starter"></a>编写自定义的starter</h2><p>接下来，我们来编写自定义的starter：log-starter。</p>
<p>这个starter内部定义了一个注解，使用这个注解修饰方法之后，该方法的调用会在日志中被打印并且还会打印出方法的耗时。starter支持exclude配置，在exclude中出现的方法不会进行计算。</p>
<p>pom文件：</p>
<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>定义修饰方法的注解@Log：</p>
<pre><code>package me.format.springboot.log.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;    

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Log { }
</code></pre><p>然后是配置类：</p>
<pre><code>package me.format.springboot.log.autoconfigure;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.util.StringUtils;

import javax.annotation.PostConstruct;

@ConfigurationProperties(prefix = &quot;mylog&quot;)
public class LogProperties {

    private String exclude;

    private String[] excludeArr;

    @PostConstruct
    public void init() {
        this.excludeArr = StringUtils.split(exclude, &quot;,&quot;);
    }

    public String getExclude() {
        return exclude;
    }

    public void setExclude(String exclude) {
        this.exclude = exclude;
    }

    public String[] getExcludeArr() {
        return excludeArr;
    }
}
</code></pre><p>接下来是AutoConfiguration：</p>
<pre><code>package me.format.springboot.log.autoconfigure;

import me.format.springboot.log.annotation.Log;
import me.format.springboot.log.aop.LogMethodInterceptor;
import org.aopalliance.aop.Advice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Pointcut;
import org.springframework.aop.support.AbstractPointcutAdvisor;
import org.springframework.aop.support.annotation.AnnotationMatchingPointcut;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;

@Configuration
@EnableConfigurationProperties(LogProperties.class)
public class LogAutoConfiguration extends AbstractPointcutAdvisor {

    private Logger logger = LoggerFactory.getLogger(LogAutoConfiguration.class);

    private Pointcut pointcut;

    private Advice advice;

    @Autowired
    private LogProperties logProperties;

    @PostConstruct
    public void init() {
        logger.info(&quot;init LogAutoConfiguration start&quot;);
        this.pointcut = new AnnotationMatchingPointcut(null, Log.class);
        this.advice = new LogMethodInterceptor(logProperties.getExcludeArr());
        logger.info(&quot;init LogAutoConfiguration end&quot;);
    }

    @Override
    public Pointcut getPointcut() {
        return this.pointcut;
    }

    @Override
    public Advice getAdvice() {
        return this.advice;
    }

}
</code></pre><p>由于计算方法调用的时候需要使用aop相关的lib，所以我们的AutoConfiguration继承了AbstractPointcutAdvisor。这样就有了Pointcut和Advice。Pointcut是一个支持注解的修饰方法的Pointcut，Advice则自己实现：</p>
<pre><code>package me.format.springboot.log.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;

public class LogMethodInterceptor implements MethodInterceptor {
    private Logger logger = LoggerFactory.getLogger(LogMethodInterceptor.class);
    private List&lt;String&gt; exclude;
    public LogMethodInterceptor(String[] exclude) {
        this.exclude = Arrays.asList(exclude);
    }
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        String methodName = invocation.getMethod().getName();
        if(exclude.contains(methodName)) {
            return invocation.proceed();
        }
        long start = System.currentTimeMillis();
        Object result = invocation.proceed();
        long end = System.currentTimeMillis();
        logger.info(&quot;====method({}), cost({}) &quot;, methodName, (end - start));
        return result;
    }
}
</code></pre><p>最后resources/META-INF/spring.factories中加入这个AutoConfiguration：</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
me.format.springboot.log.autoconfigure.LogAutoConfiguration
</code></pre><p>我们在项目中使用这个log-starter：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;me.format.springboot&lt;/groupId&gt;
    &lt;artifactId&gt;log-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>使用配置：</p>
<pre><code>mylog.exclude=core,log
</code></pre><p>然后编写一个简单的Service：</p>
<pre><code>@Service
public class SimpleService {

    @Log
    public void test(int num) {
        System.out.println(&quot;----test---- &quot; + num);
    }

    @Log
    public void core(int num) {
        System.out.println(&quot;----core---- &quot; + num);
    }

    public void work(int num) {
        System.out.println(&quot;----work---- &quot; + num);
    }

}
</code></pre><p>使用单元测试分别调用这3个方法，由于work方法没有加上@Log注解，core方法虽然加上了@Log注解，但是在配置中被exclude了，只有test方法可以正常计算耗时：</p>
<pre><code>----test---- 666
2016-11-16 01:29:32.255  INFO 41010 --- [           main] m.f.s.log.aop.LogMethodInterceptor       : ====method(test),     cost(36) 
----work---- 666
----core---- 666
</code></pre><p>总结：</p>
<p>自定义springboot的starter，注意这两点。</p>
<ol>
<li>如果自动化配置类需要在程序启动的时候就加载，可以在META-INF/spring.factories文件中定义。如果本次加载还需要其他一些lib的话，可以使用ConditionalOnClass注解协助</li>
<li>如果自动化配置类要在使用自定义注解后才加载，可以使用自定义注解+@Import注解或@ImportSelector注解完成</li>
</ol>
<p>参考：</p>
<p><a href="http://www.jianshu.com/p/85460c1d835a" target="_blank" rel="external">http://www.jianshu.com/p/85460c1d835a</a></p>
<p><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，我们分析过SpringBoot内部的&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;自动化配置原理&lt;/a&gt;和&lt;a href=&quot;http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/&quot;&gt;自动化配置注解开关原理&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们先简单分析一下&lt;a href=&quot;https://github.com/mybatis/spring-boot-starter&quot;&gt;mybatis starter&lt;/a&gt;的编写，然后再编写自定义的starter。&lt;/p&gt;
&lt;p&gt;mybatis中的autoconfigure模块中使用了一个叫做MybatisAutoConfiguration的自动化配置类。&lt;/p&gt;
&lt;p&gt;这个MybatisAutoConfiguration需要在这些Condition条件下才会执行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })。需要SqlSessionFactory和SqlSessionFactoryBean在classpath中都存在&lt;/li&gt;
&lt;li&gt;@ConditionalOnBean(DataSource.class)。 spring factory中需要存在一个DataSource的bean&lt;/li&gt;
&lt;li&gt;@AutoConfigureAfter(DataSourceAutoConfiguration.class)。需要在DataSourceAutoConfiguration自动化配置之后进行配置，因为mybatis需要数据源的支持&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同时在META-INF目录下有个spring.factories这个properties文件，而且它的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，这样才会被springboot加载：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这些东西之后，mybatis相关的配置会被自动加入到spring container中，只要在maven中加入starter即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动化配置的注解开关原理</title>
    <link href="http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/"/>
    <id>http://fangjian0423.github.io/2016/11/13/springboot-enable-annotation/</id>
    <published>2016-11-13T08:22:51.000Z</published>
    <updated>2016-11-23T07:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前我们分析<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">SpringBoot的自动化配置原理</a>的时候，分析了freemarker的自动化配置类FreeMarkerAutoConfiguration，这个自动化配置类需要classloader中的一些类需要存在并且在其他的一些配置类之后进行加载。</p>
<p>但是还存在一些自动化配置类，它们需要在使用一些注解开关的情况下才会生效。比如spring-boot-starter-batch里的@EnableBatchProcessing注解、@EnableCaching等。</p>
<a id="more"></a>
<h2 id="一个需求"><a href="#一个需求" class="headerlink" title="一个需求"></a>一个需求</h2><p>在分析这些开关的原理之前，我们来看一个需求：</p>
<pre><code>定义一个Annotation，让使用了这个Annotaion的应用程序自动化地注入一些类或者做一些底层的事情。
</code></pre><p>我们会使用Spring提供的@Import注解配合一个配置类来完成。</p>
<p>我们以一个最简单的例子来完成这个需求：定义一个注解EnableContentService，使用了这个注解的程序会自动注入ContentService这个bean。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import(ContentConfiguration.class)
public @interface EnableContentService {}

public interface ContentService {
    void doSomething();
}

public class SimpleContentService implements ContentService {
    @Override
    public void doSomething() {
        System.out.println(&quot;do some simple things&quot;);
    }
}
</code></pre><p>然后在应用程序的入口加上@EnableContentService注解。</p>
<p>这样的话，ContentService就被注入进来了。 SpringBoot也就是用这个完成的。只不过它用了更加高级点的ImportSelector。</p>
<h2 id="ImportSelector的使用"><a href="#ImportSelector的使用" class="headerlink" title="ImportSelector的使用"></a>ImportSelector的使用</h2><p>用了ImportSelector之后，我们可以在Annotation上添加一些属性，然后根据属性的不同加载不同的bean。</p>
<p>我们在@EnableContentService注解添加属性policy，同时Import一个Selector。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import(ContentImportSelector.class)
public @interface EnableContentService {
    String policy() default &quot;simple&quot;;
}
</code></pre><p>这个ContentImportSelector根据EnableContentService注解里的policy加载不同的bean。</p>
<pre><code>public class ContentImportSelector implements ImportSelector {

    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        Class&lt;?&gt; annotationType = EnableContentService.class;
        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(
                annotationType.getName(), false));
        String policy = attributes.getString(&quot;policy&quot;);
        if (&quot;core&quot;.equals(policy)) {
            return new String[] { CoreContentConfiguration.class.getName() };
        } else {
            return new String[] { SimpleContentConfiguration.class.getName() };
        }
    }

}
</code></pre><p>CoreContentService和CoreContentConfiguration如下：</p>
<pre><code>public class CoreContentService implements ContentService {
    @Override
    public void doSomething() {
        System.out.println(&quot;do some import things&quot;);
    }
}

public class CoreContentConfiguration {
    @Bean
    public ContentService contentService() {
        return new CoreContentService();
    }
}
</code></pre><p>这样的话，如果在@EnableContentService注解的policy中使用core的话，应用程序会自动加载CoreContentService，否则会加载SimpleContentService。</p>
<h2 id="ImportSelector在SpringBoot中的使用"><a href="#ImportSelector在SpringBoot中的使用" class="headerlink" title="ImportSelector在SpringBoot中的使用"></a>ImportSelector在SpringBoot中的使用</h2><p>SpringBoot里的ImportSelector是通过SpringBoot提供的@EnableAutoConfiguration这个注解里完成的。</p>
<p>这个@EnableAutoConfiguration注解可以显式地调用，否则它会在@SpringBootApplication注解中隐式地被调用。</p>
<p>@EnableAutoConfiguration注解中使用了EnableAutoConfigurationImportSelector作为ImportSelector。下面这段代码就是EnableAutoConfigurationImportSelector中进行选择的具体代码：</p>
<pre><code>@Override
public String[] selectImports(AnnotationMetadata metadata) {
    try {
        AnnotationAttributes attributes = getAttributes(metadata);
        List&lt;String&gt; configurations = getCandidateConfigurations(metadata,
                attributes);
        configurations = removeDuplicates(configurations); // 删除重复的配置
        Set&lt;String&gt; exclusions = getExclusions(metadata, attributes); // 去掉需要exclude的配置
        configurations.removeAll(exclusions);
        configurations = sort(configurations); // 排序
        recordWithConditionEvaluationReport(configurations, exclusions);
        return configurations.toArray(new String[configurations.size()]);
    }
    catch (IOException ex) {
        throw new IllegalStateException(ex);
    }
}
</code></pre><p>其中getCandidateConfigurations方法将获取配置类：</p>
<pre><code>protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,
        AnnotationAttributes attributes) {
    return SpringFactoriesLoader.loadFactoryNames(
            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
}
</code></pre><p>SpringFactoriesLoader.loadFactoryNames方法会根据FACTORIES_RESOURCE_LOCATION这个静态变量从所有的jar包中读取META-INF/spring.factories文件信息：</p>
<pre><code>public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    try {
        Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
        List&lt;String&gt; result = new ArrayList&lt;String&gt;();
        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
            String factoryClassNames = properties.getProperty(factoryClassName); // 只会过滤出key为factoryClassNames的值
            result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
        }
        return result;
    }
    catch (IOException ex) {
        throw new IllegalArgumentException(&quot;Unable to load [&quot; + factoryClass.getName() +
                &quot;] factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
    }
}
</code></pre><p>getCandidateConfigurations方法中的getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration.class，所以会过滤出key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值。</p>
<p>下面这段配置代码就是autoconfigure这个jar包里的spring.factories文件的一部分内容(有个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration，所以会得到这些AutoConfiguration)：</p>
<pre><code># Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\
</code></pre><p>当然了，这些AutoConfiguration不是所有都会加载的，会根据AutoConfiguration上的@ConditionalOnClass等条件判断是否加载。</p>
<p>上面这个例子说的读取properties文件的时候只会过滤出key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值。</p>
<p>SpringBoot内部还有一些其他的key用于过滤得到需要加载的类：</p>
<ul>
<li><p>org.springframework.test.context.TestExecutionListener</p>
</li>
<li><p>org.springframework.beans.BeanInfoFactory</p>
</li>
<li><p>org.springframework.context.ApplicationContextInitializer</p>
</li>
<li><p>org.springframework.context.ApplicationListener</p>
</li>
<li><p>org.springframework.boot.SpringApplicationRunListener</p>
</li>
<li><p>org.springframework.boot.env.EnvironmentPostProcessor</p>
</li>
<li><p>org.springframework.boot.env.PropertySourceLoader</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前我们分析&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;SpringBoot的自动化配置原理&lt;/a&gt;的时候，分析了freemarker的自动化配置类FreeMarkerAutoConfiguration，这个自动化配置类需要classloader中的一些类需要存在并且在其他的一些配置类之后进行加载。&lt;/p&gt;
&lt;p&gt;但是还存在一些自动化配置类，它们需要在使用一些注解开关的情况下才会生效。比如spring-boot-starter-batch里的@EnableBatchProcessing注解、@EnableCaching等。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBatch中的retry和skip机制实现分析</title>
    <link href="http://fangjian0423.github.io/2016/11/09/springbatch-retry-skip/"/>
    <id>http://fangjian0423.github.io/2016/11/09/springbatch-retry-skip/</id>
    <published>2016-11-09T00:15:22.000Z</published>
    <updated>2016-11-09T04:22:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://projects.spring.io/spring-batch/" target="_blank" rel="external">SpringBatch</a>是spring框架下的一个子模块，用于处理批处理的批次框架。</p>
<p>本文主要分析SpringBatch中的retry和skip机制的实现。</p>
<p>先简单说明下SpringBatch在SpringBoot中的使用。</p>
<p>如果要在springboot中使用batch的话，直接加入以下依赖即可：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后使用注解开启Batch模块：</p>
<pre><code>...
@EnableBatchProcessing
public class Application { ... }
</code></pre><p>之后就可以注入JobBuilderFactory和StepBuilderFactory：</p>
<pre><code>@Autowired
private JobBuilderFactory jobs;

@Autowired
private StepBuilderFactory steps;
</code></pre><p>有了这2个factory之后，就可以build job。</p>
<a id="more"></a>
<p>SpringBatch中的相关基础概念比如ItemReader、ItemWriter、Chunk等本文就不介绍了。</p>
<p>我们以FlatFileItemReader作为reader，一个自定义Writer用于打印reader中读取出来的数据。</p>
<p>这个定义的writer遇到good job这条数据的时候会报错，具体逻辑如下：</p>
<pre><code>@Override
public void write(List&lt;? extends String&gt; items) throws Exception {
    System.out.println(&quot;handle start =====&quot; + items);
    for(String a : items) {
        if(a.equals(&quot;good job&quot;)) {
            throw new Exception(&quot;custom exception&quot;);
        }
    }
    System.out.println(&quot;handle end.. -----&quot; + items);
}
</code></pre><p>其中reader中读取的文件中的数据如下：</p>
<pre><code>hello world
hello coder
good job
cool
66666
</code></pre><p>我们使用StepBuilderFactory构造Step，chunkSize设置为2。然后在job1中使用并执行：</p>
<pre><code>stepBuilderFactory.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).build();
</code></pre><p>执行job1后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
</code></pre><p>job1遇到了good job这条数据，writer抛出了异常，由于没有使用skip或者retry机制，导致整个流程停止。job1的处理流程底层在<strong>SimpleChunkProcessor</strong>这个类中完成，包括processor、writer的使用。</p>
<p>接下里我们构造一个job2，job2使用skip机制(其中skipLimit必须要和skip(Class&lt;? extends Throwable&gt; type)一起使用)，skip机制可以防止writer发生异常后不停止整个job，但是需要同时满足skip的限制次数和skip对应的Exception是发生异常的父类或自身关系条件才不会停止整个job，这里我们使用Exception作为异常和Integer.MAX_VALUE作为skip的限制次数为例：</p>
<pre><code>stepBuilderFactory.get.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).faultTolerant().skipLimit(Integer.MAX_VALUE).skip(Exception.class).build();
</code></pre><p>执行job2    后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
handle start =====[good job]
handle start =====[cool]
handle end.. -----[cool]
handle start =====[66666]
handle end.. -----[66666]
</code></pre><p>我们看到good job这条数据发生的异常被skip掉了，job完整的执行。</p>
<p>但是发现了另外一个问题，那就是处理 [good job, cool] 这批数据的时候，发生了异常，但是接下来执行了 [good job] 和 [cool] 这两批chunk为1的批次。这是在ItemWriter中执行的，它也会在ItemWriteListener中执行多次。</p>
<p><strong>换句话说，如果使用了skip功能，那么对于需要被skip的批次数据中会进行scan操作找出具体是哪1条数据的原因，这里的scan操作指的是一条一条数据的遍历。</strong></p>
<p>这个过程为什么叫scan呢?  在源码中，FaultTolerantChunkProcessor类(处理带有skip或者retry机制的处理器，跟SimpleChunkProcessor类似，只不过SimpleChunkProcessor处理简单的Job)里有个私有方法scan：</p>
<pre><code>private void scan(final StepContribution contribution, final Chunk&lt;I&gt; inputs, final Chunk&lt;O&gt; outputs,
        ChunkMonitor chunkMonitor, boolean recovery) throws Exception {

    ...

    Chunk&lt;I&gt;.ChunkIterator inputIterator = inputs.iterator();
    Chunk&lt;O&gt;.ChunkIterator outputIterator = outputs.iterator();

    List&lt;O&gt; items = Collections.singletonList(outputIterator.next()); // 拿出需要写的数据中的每一条数据
    inputIterator.next();
    try {
        writeItems(items); // 写每条数据
        doAfterWrite(items);
        contribution.incrementWriteCount(1);
        inputIterator.remove();
        outputIterator.remove();
    }
    catch (Exception e) { // 写的时候如果发生了异常
        doOnWriteError(e, items);
        if (!shouldSkip(itemWriteSkipPolicy, e, -1) &amp;&amp; !rollbackClassifier.classify(e)) {
            inputIterator.remove();
            outputIterator.remove();
        }
        else {
            // 具体的skip策略
            checkSkipPolicy(inputIterator, outputIterator, e, contribution, recovery);
        }
        if (rollbackClassifier.classify(e)) {
            throw e;
        }
    }
    chunkMonitor.incrementOffset();
    if (outputs.isEmpty()) { // 批次里的所有数据处理完毕之后 scanning 设置为false
        data.scanning(false);
        inputs.setBusy(false);
        chunkMonitor.resetOffset();
    }
}
</code></pre><p>这个scan方法触发的条件是UserData这个内部类里的scanning被设置为true，这里被设置为true是在处理批次数据出现异常后并且不能retry的情况下才会被设置的。</p>
<pre><code>try {
    batchRetryTemplate.execute(retryCallback, recoveryCallback, new DefaultRetryState(inputs,
            rollbackClassifier));
}
catch (Exception e) {
    RetryContext context = contextHolder.get();
     if (!batchRetryTemplate.canRetry(context)) {
         // 设置scanning为true
        data.scanning(true);
    }
    throw e;
}
</code></pre><p>这就是为什么skip机制在skip数据的时候会去scan批次中的每条数据，然后并找出需要被skip的数据的原理。</p>
<p>job3带有retry功能，retry的功能在于出现某个异常并且这个异常可以被retry所接受的话会进行retry，retry的次数可以进行配置，我们配置了3次retry：</p>
<pre><code>stepBuilderFactory.get.get(&quot;test-step&quot;).chunk(2).reader(reader).writer(writer).faultTolerant().skipLimit(Integer.MAX_VALUE).skip(Exception.class).retryLimit(3).retry(Exception.class).build();
</code></pre><p>执行 job3后console打印如下：</p>
<pre><code>handle start =====[hello world, hello coder]
handle end.. -----[hello world, hello coder]
handle start =====[good job, cool]
handle start =====[good job, cool]
handle start =====[good job, cool]
handle start =====[good job]
handle start =====[cool]
handle end.. -----[cool]
handle start =====[66666]
handle end.. -----[66666]
</code></pre><p>[good job, cool] 这批数据retry了3次，而且都失败了。失败之后进行了skip操作。</p>
<p>SpringBatch中的retry和skip都有对应的policy实现，默认的retry policy是SimpleRetryPolicy，可以设置retry次数和接收的exception。比如可以使用NeverRetryPolicy：</p>
<pre><code>.retryPolicy(new NeverRetryPolicy())
</code></pre><p>使用NeverRetryPolicy之后，便不再retry了，只会skip。SpringBatch内部的retry是使用Spring的<a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">retry模块</a>完成的。执行的时候可以设置RetryCallback和RecoveryCallback。</p>
<p>SpringBatch中默认的skip policy是LimitCheckingItemSkipPolicy。</p>
<p>参考资料: </p>
<p><a href="http://stackoverflow.com/questions/16567432/how-is-the-skipping-implemented-in-spring-batch" target="_blank" rel="external">http://stackoverflow.com/questions/16567432/how-is-the-skipping-implemented-in-spring-batch</a></p>
<p><a href="http://docs.spring.io/spring-batch/reference/html/retry.html" target="_blank" rel="external">http://docs.spring.io/spring-batch/reference/html/retry.html</a></p>
<p><a href="https://github.com/spring-projects/spring-retry" target="_blank" rel="external">https://github.com/spring-projects/spring-retry</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-batch/&quot;&gt;SpringBatch&lt;/a&gt;是spring框架下的一个子模块，用于处理批处理的批次框架。&lt;/p&gt;
&lt;p&gt;本文主要分析SpringBatch中的retry和skip机制的实现。&lt;/p&gt;
&lt;p&gt;先简单说明下SpringBatch在SpringBoot中的使用。&lt;/p&gt;
&lt;p&gt;如果要在springboot中使用batch的话，直接加入以下依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-batch&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后使用注解开启Batch模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
@EnableBatchProcessing
public class Application { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后就可以注入JobBuilderFactory和StepBuilderFactory：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
private JobBuilderFactory jobs;

@Autowired
private StepBuilderFactory steps;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了这2个factory之后，就可以build job。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://fangjian0423.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springbatch" scheme="http://fangjian0423.github.io/tags/springbatch/"/>
    
  </entry>
  
  <entry>
    <title>java Annotation的RetentionPolicy介绍</title>
    <link href="http://fangjian0423.github.io/2016/11/04/java-annotation-retentionpolicy/"/>
    <id>http://fangjian0423.github.io/2016/11/04/java-annotation-retentionpolicy/</id>
    <published>2016-11-03T16:01:06.000Z</published>
    <updated>2016-11-03T16:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java Annotation对应的Retention有3种，在RetentionPolicy中定义，有3种：</p>
<ol>
<li>SOURCE. 注解保留在源代码中，但是编译的时候会被编译器所丢弃。比如@Override, @SuppressWarnings</li>
<li>CLASS. 这是默认的policy。注解会被保留在class文件中，但是在运行时期间就不会识别这个注解。</li>
<li>RUNTIME. 注解会被保留在class文件中，同时运行时期间也会被识别。所以可以使用反射机制获取注解信息。比如@Deprecated</li>
</ol>
<a id="more"></a>
<h2 id="RUNTIME"><a href="#RUNTIME" class="headerlink" title="RUNTIME"></a>RUNTIME</h2><p>大部分情况下，我们都是使用RUNTIME这个Policy。</p>
<p>下面就是一个RUNTIME Annotation的例子。</p>
<p>先定义Annotation：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyClassRuntimeAnno {
    String name();
    int level() default 1;
}
</code></pre><p>然后在CLASS前面使用这个Annotation。</p>
<pre><code>@MyClassRuntimeAnno(name = &quot;simple&quot;, level = 10)
public class SimpleObj {
}
</code></pre><p>最后写一个testcase通过反射可以获取这个类的Annotation进行后续操作。</p>
<pre><code>@Test
public void testGetAnnotation() {
    Annotation[] annotations = SimpleObj.class.getAnnotations();
    System.out.println(Arrays.toString(annotations));
    MyClassRuntimeAnno myClassAnno = SimpleObj.class.getAnnotation(MyClassRuntimeAnno.class);
    System.out.println(myClassAnno.name() + &quot;, &quot; + myClassAnno.level());
    System.out.println(myClassAnno == annotations[0]);
}
</code></pre><h2 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE"></a>SOURCE</h2><p>SOURCE这个policy表示注解保留在源代码中，但是编译的时候会被编译器所丢弃。 由于在编译的过程中这个注解还被保留着，所以在编译过程中可以针对这个policy进行一些操作。比如在自动生成java代码的场景下使用。最常见的就是<a href="https://projectlombok.org/" target="_blank" rel="external">lombok</a>的使用了，可以自动生成field的get和set方法以及toString方法，构造器等；消除了冗长的java代码。</p>
<p>SOURCE这个policy可以使用jdk中的javax.annotation.processing.*包中的processor处理器进行注解的处理过程。</p>
<p>以1个编译过程中会打印类中的方法的例子来说明SOUCRE这个policy的作用：</p>
<p>首先定义一个Printer注解：</p>
<pre><code>@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.METHOD)
public @interface Printer {
}
</code></pre><p>然后一个类的方法使用这个注解：</p>
<pre><code>public class SimpleObject {

    @Printer
    public void methodA() {

    }

    public void methodB() {

    }

}
</code></pre><p>创建对应的Processor：</p>
<pre><code>@SupportedAnnotationTypes({&quot;me.format.annotaion.Printer&quot;})
public class PrintProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        Messager messager = processingEnv.getMessager();
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;start to use PrintProcessor ..&quot;);


        Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;root classes: &quot;);
        for(Element root : rootElements) {
            messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt; &quot; + root.toString());
        }
        messager.printMessage(Diagnostic.Kind.NOTE, &quot;annotation: &quot;);
        for(TypeElement te : annotations) {
            messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt;&gt; &quot; + te.toString());
            Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(te);
            for(Element ele : elements) {
                messager.printMessage(Diagnostic.Kind.NOTE, &quot;&gt;&gt;&gt;&gt; &quot; + ele.toString());
            }
        }

        return true;
    }
    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
}
</code></pre><p>然后先使用javac编译Printer和PrintProcessor：</p>
<pre><code>javac -d classes src/main/java/me/format/annotation/Printer.java src/main/java/me/format/annotation/PrintProcessor.java
</code></pre><p>最后再使用javac中的processor参数处理：</p>
<pre><code>javac -cp classes -processor me.format.annotation.PrintProcessor -d classes src/main/java/me/format/annotation/SimpleObject.java
</code></pre><p>控制台打印出：</p>
<pre><code>注: start to use PrintProcessor ..
注: root classes: 
注: &gt;&gt; hello.annotation.SimpleObject
注: annotation: 
注: &gt;&gt;&gt; hello.annotation.Printer
注: &gt;&gt;&gt;&gt; methodA()
</code></pre><h2 id="CLASS"><a href="#CLASS" class="headerlink" title="CLASS"></a>CLASS</h2><p>CLASS和RUNTIME的唯一区别是RUNTIME在运行时期间注解是存在的，而CLASS则不存在。</p>
<p>我们通过<a href="http://asm.ow2.org/" target="_blank" rel="external">asm</a>来获取class文件里的annotation。</p>
<p>首先定义注解：</p>
<p>policy为CLASS的注解。</p>
<pre><code>@Retention(RetentionPolicy.CLASS)
@Target(ElementType.TYPE)
public @interface Meta {

    String name();

}
</code></pre><p>policy为RUNTIME的注解。</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Header {

    int code();

}
</code></pre><p>使用注解：</p>
<pre><code>@Meta(name = &quot;obj&quot;)
@Header(code = 200)
public class AnnotationObject {

    private String val;

    public String getVal() {
        return val;
    }

    public void setVal(String val) {
        this.val = val;
    }
}
</code></pre><p>编译这3个java文件得到字节码文件AnnotationObject.class：</p>
<pre><code>javac -d classes src/main/java/me/format/annotaion/AnnotationObject.java src/main/java/me/format/annotation/Meta.java src/main/java/me/format/annotation/Header.java
</code></pre><p>使用asm获取字节码文件中的注解：</p>
<pre><code>ClassNode classNode = new ClassNode();

ClassReader cr = new ClassReader(new FileInputStream(&quot;classes/me/format/annotation/AnnotationObject.class&quot;));

cr.accept(classNode, 0);

System.out.println(&quot;Class Name: &quot; + classNode.name);
System.out.println(&quot;Source File: &quot; + classNode.sourceFile);

System.out.println(&quot;invisible: &quot;);
AnnotationNode anNode = null;
for (Object annotation : classNode.invisibleAnnotations) {
    anNode = (AnnotationNode) annotation;
    System.out.println(&quot;Annotation Descriptor : &quot; + anNode.desc);
    System.out.println(&quot;Annotation attribute pairs : &quot; + anNode.values);
}

System.out.println(&quot;visible: &quot;);
for (Object annotation : classNode.visibleAnnotations) {
    anNode = (AnnotationNode) annotation;
    System.out.println(&quot;Annotation Descriptor : &quot; + anNode.desc);
    System.out.println(&quot;Annotation attribute pairs : &quot; + anNode.values);
}
</code></pre><p>打印出：</p>
<pre><code>Class Name: me/format/annotation/AnnotationObject
Source File: AnnotationObject.java
invisible: 
Annotation Descriptor : Lme/format/annotation/Meta;
Annotation attribute pairs : [name, obj]
visible: 
Annotation Descriptor : Lme/format/annotation/Header;
Annotation attribute pairs : [code, 200]
</code></pre><p>其中policy为CLASS的注解编译完后不可见，而policy为RUNTIME的注解编译后可见。</p>
<p>同样，我们可以使用javap查看编译后的信息：</p>
<pre><code>javap -v me.format.annotation.AnnotationObject
</code></pre><p>会打印出注解的visible信息：</p>
<pre><code>#16 = Utf8               AnnotationObject.java
#17 = Utf8               RuntimeVisibleAnnotations
#18 = Utf8               Lhello/annotation/Header;
#19 = Utf8               code
#20 = Integer            200
#21 = Utf8               RuntimeInvisibleAnnotations
#22 = Utf8               Lhello/annotation/Meta;
#23 = Utf8               name
#24 = Utf8               obj
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Annotation对应的Retention有3种，在RetentionPolicy中定义，有3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SOURCE. 注解保留在源代码中，但是编译的时候会被编译器所丢弃。比如@Override, @SuppressWarnings&lt;/li&gt;
&lt;li&gt;CLASS. 这是默认的policy。注解会被保留在class文件中，但是在运行时期间就不会识别这个注解。&lt;/li&gt;
&lt;li&gt;RUNTIME. 注解会被保留在class文件中，同时运行时期间也会被识别。所以可以使用反射机制获取注解信息。比如@Deprecated&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Swagger在SpringBoot中的使用</title>
    <link href="http://fangjian0423.github.io/2016/10/09/springboot-swagger/"/>
    <id>http://fangjian0423.github.io/2016/10/09/springboot-swagger/</id>
    <published>2016-10-09T14:11:23.000Z</published>
    <updated>2016-10-09T13:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://swagger.io/" target="_blank" rel="external">Swagger</a>是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>在SpringBoot中要使用Swagger的话，可以使用<a href="https://github.com/springfox/springfox" target="_blank" rel="external">springfox</a>。</p>
<p>在sbt中添加依赖即可：</p>
<pre><code>libraryDependencies += &quot;io.springfox&quot; % &quot;springfox-swagger2&quot; % &quot;2.6.0&quot;
libraryDependencies += &quot;io.springfox&quot; % &quot;springfox-swagger-ui&quot; % &quot;2.6.0&quot;
</code></pre><p>查看springfox-swagger2中的源码，发现springfox并不是通过autoconfigure实现和swagger的整合的，而是基于Spring的方式Import各种bean构造Swagger。</p>
<p>所以本文指的Swagger在SpringBoot中的使用同样也可以在Spring中使用。</p>
<a id="more"></a>
<p>要整合Spring和Swagger的话需要这么做。</p>
<ol>
<li>加上@EnableSwagger2注解</li>
<li>构造一个Docket</li>
</ol>
<p>以下代码就是例子：</p>
<pre><code>@EnableSwagger2
@Configuration
public class SwaggerConfiguration {

    @Bean
    public Docket userDocket() {
        ApiInfo apiInfo = new ApiInfo(&quot;A Simple of SpringBoot-Swagger&quot;,// 大标题
                &quot;two controllers: UserController and DeptController&quot;,// 小标题
                &quot;1.0&quot;,// 版本
                &quot;NO terms of service&quot;,
                new Contact(&quot;format&quot;, &quot;fangjian0423.github.io&quot;, &quot;fangjian0423@gmail.com&quot;), // 作者信息
                &quot;The Apache License, Version 2.0&quot;,// 开源许可证
                &quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;// 许可证详情
        );
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .paths(Predicates.or(PathSelectors.regex(&quot;/user/.*&quot;), PathSelectors.regex(&quot;/dept/.*&quot;)))
                .build()
                .apiInfo(apiInfo);
    }

}
</code></pre><p>需要注意的是path方法表示要构造的url，这里使用了or连接了 /user/.*<em> 和 /dept/.*</em> 这2个地址，这里用的是正则的匹配方式。</p>
<p>UserController：</p>
<pre><code>@RestController
@RequestMapping(Array(&quot;/user&quot;))
class UserController {

  @ApiOperation(nickname = &quot;test method&quot;, value = &quot;just a test method&quot;)
  @RequestMapping(value = Array(&quot;/demo&quot;), method = Array(RequestMethod.POST, RequestMethod.GET))
  def demo(): String = {
    &quot;Hello Swagger&quot;
  }

  @RequestMapping(value = Array(&quot;/get/{id}&quot;), method = Array(RequestMethod.GET))
  def get(@PathVariable id: String): String = {
    s&quot;get ${id}&quot;
  }

  @RequestMapping(value = Array(&quot;/delete/{id}&quot;), method = Array(RequestMethod.POST))
  def delete(
              @ApiParam(name = &quot;id&quot;, value = &quot;the identity of user&quot;, required = true)
              @PathVariable id: String
              ): String = {
    s&quot;delete ${id}&quot;
  }

  @ApiImplicitParams(
    Array(
      new ApiImplicitParam(name = &quot;name&quot;, value = &quot;the name of user&quot;, required = true, paramType = &quot;form&quot;, dataType = &quot;string&quot;),
      new ApiImplicitParam(name = &quot;age&quot;, value = &quot;the age of user&quot;, required = true, paramType = &quot;form&quot;, dataType = &quot;int&quot;)
    )
  )

  @RequestMapping(value = Array(&quot;/add&quot;), method = Array(RequestMethod.POST))
  def add(req: HttpServletRequest): String = {
    s&quot;${req.getParameter(&quot;name&quot;)}-${req.getParameter(&quot;age&quot;)}&quot;
  }

}
</code></pre><p>Swagger默认会去找被@RequestMapping注解的方法。</p>
<p>@ApiOperation注解用于说明接口的作用，作用在方法上，如果没有使用这个注解，会去@RequestMapping中的value和method等属性。</p>
<p>@ApiParam注解用来额外说明参数的meta data。</p>
<p>@ApiImplicitParams注解也用来额外说明参数，当参数不在方法里声明的时候，可以使用这个注解。需要注意的是这个注解只能作用在方法上。</p>
<p>Swagger还提供了@ApiModel、@ApiResponse、@Example等诸多注解用于说明接口的作用。</p>
<p>另外一个Controller: </p>
<pre><code>@RestController
@RequestMapping(Array(&quot;/dept&quot;))
class DeptController {

  @ApiOperation(nickname = &quot;dept test method&quot;, value = &quot;dept just a test method&quot;)
  @RequestMapping(value = Array(&quot;/demo&quot;), method = Array(RequestMethod.POST, RequestMethod.GET))
  def demo(): String = {
    &quot;Hello Swagger&quot;
  }

}
</code></pre><p>Swagger展示如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/swagger01.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://swagger.io/&quot;&gt;Swagger&lt;/a&gt;是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。&lt;/p&gt;
&lt;p&gt;在SpringBoot中要使用Swagger的话，可以使用&lt;a href=&quot;https://github.com/springfox/springfox&quot;&gt;springfox&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在sbt中添加依赖即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;libraryDependencies += &amp;quot;io.springfox&amp;quot; % &amp;quot;springfox-swagger2&amp;quot; % &amp;quot;2.6.0&amp;quot;
libraryDependencies += &amp;quot;io.springfox&amp;quot; % &amp;quot;springfox-swagger-ui&amp;quot; % &amp;quot;2.6.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看springfox-swagger2中的源码，发现springfox并不是通过autoconfigure实现和swagger的整合的，而是基于Spring的方式Import各种bean构造Swagger。&lt;/p&gt;
&lt;p&gt;所以本文指的Swagger在SpringBoot中的使用同样也可以在Spring中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="swagger" scheme="http://fangjian0423.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的事务管理</title>
    <link href="http://fangjian0423.github.io/2016/10/07/springboot-transaction/"/>
    <id>http://fangjian0423.github.io/2016/10/07/springboot-transaction/</id>
    <published>2016-10-06T17:28:36.000Z</published>
    <updated>2016-10-06T17:33:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot内部提供的事务管理器是根据autoconfigure来进行决定的。</p>
<p>比如当使用jpa的时候，也就是pom中加入了spring-boot-starter-data-jpa这个starter之后(之前我们分析过<a href="http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/">springboot的自动化配置原理</a>)。</p>
<p>Springboot会构造一个JpaTransactionManager这个事务管理器。</p>
<p>而当我们使用spring-boot-starter-jdbc的时候，构造的事务管理器则是DataSourceTransactionManager。</p>
<p>这2个事务管理器都实现了spring中提供的PlatformTransactionManager接口，这个接口是spring的事务核心接口。</p>
<p>这个核心接口有以下这几个常用的实现策略：</p>
<ol>
<li>HibernateTransactionManager</li>
<li>DataSourceTransactionManager</li>
<li>JtaTransactionManager</li>
<li>JpaTransactionManager</li>
</ol>
<p>具体的PlatformTransactionManager继承关系如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/transactionmanager.png" alt=""></p>
<a id="more"></a>
<p>spring-boot-starter-data-jpa这个starter会触发HibernateJpaAutoConfiguration这个自动化配置类，HibernateJpaAutoConfiguration继承了JpaBaseConfiguration基础类。</p>
<p>在JpaBaseConfiguration中构造了事务管理器：</p>
<pre><code>@Bean
@ConditionalOnMissingBean(PlatformTransactionManager.class)
public PlatformTransactionManager transactionManager() {
    return new JpaTransactionManager();
}
</code></pre><p>spring-boot-starter-jdbc会触发DataSourceTransactionManagerAutoConfiguration这个自动化配置类，也会构造事务管理器：</p>
<pre><code>@Bean
@ConditionalOnMissingBean(PlatformTransactionManager.class)
@ConditionalOnBean(DataSource.class)
public DataSourceTransactionManager transactionManager() {
    return new DataSourceTransactionManager(this.dataSource);
}
</code></pre><p>Spring的事务管理器PlatformTransactionManager接口中定义了3个方法：</p>
<pre><code>// 基于事务的传播特性，返回一个已经存在的事务或者创建一个新的事务
TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

// 提交事务
void commit(TransactionStatus status) throws TransactionException;

// 回滚事务
void rollback(TransactionStatus status) throws TransactionException;
</code></pre><p>其中TransactionDefinition接口表示跟spring兼容的事务属性，比如传播行为、隔离级别、超时时间、是否只读等属性。</p>
<p>DefaultTransactionDefinition类是一个默认的TransactionDefinition实现，它的传播行为是PROPAGATION_REQUIRED(如果当前没事务，则创建一个，否则加入到当前事务中)，隔离级别是数据库默认级别。</p>
<p>TransactionStatus接口表示事务的状态，比如事务是否是一个刚构造的事务、事务是否已经完成等状态。</p>
<p>下面这段代码就是传统事务的常见写法：</p>
<pre><code>transaction.begin();
try {
    ...
    transaction.commit();
} catch(Exception e) {
    ...
    transaction.rollback();
} finally {

}
</code></pre><p>由于spring的事务操作被封装到了PlatformTransactionManager接口中，commit和rollback方法对应接口中的方法，begin方法在getTransaction方法中会被调用。</p>
<p>细心的读者发现文章前面构造事务管理器的时候都会加上这段注解：</p>
<pre><code>@ConditionalOnMissingBean(PlatformTransactionManager.class)
</code></pre><p>也就是说如果我们手动配置了事务管理器，Springboot就不会再为我们自动配置事务管理器。</p>
<p>如果要使用多个事务管理器的话，那么需要手动配置多个：</p>
<pre><code>@Configuration
public class DatabaseConfiguration {

    @Bean
    public PlatformTransactionManager transactionManager1(EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }

    @Bean
    public PlatformTransactionManager transactionManager2(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

}
</code></pre><p>然后使用Transactional注解的时候需要声明是哪个事务管理器：</p>
<pre><code>@Transactional(value=&quot;transactionManager1&quot;)
public void save() {
    doSave();
}
</code></pre><p>Spring给我们提供了一个TransactionManagementConfigurer接口，该接口只有一个方法返回PlatformTransactionManager。其中返回的PlatformTransactionManager就表示这是默认的事务处理器，这样在Transactional注解上就不需要声明是使用哪个事务管理器了。</p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/davidwang456/p/4309038.html" target="_blank" rel="external">http://www.cnblogs.com/davidwang456/p/4309038.html</a></p>
<p><a href="http://blog.csdn.net/chjttony/article/details/6528344" target="_blank" rel="external">http://blog.csdn.net/chjttony/article/details/6528344</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot内部提供的事务管理器是根据autoconfigure来进行决定的。&lt;/p&gt;
&lt;p&gt;比如当使用jpa的时候，也就是pom中加入了spring-boot-starter-data-jpa这个starter之后(之前我们分析过&lt;a href=&quot;http://fangjian0423.github.io/2016/06/12/springboot-autoconfig-analysis/&quot;&gt;springboot的自动化配置原理&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;Springboot会构造一个JpaTransactionManager这个事务管理器。&lt;/p&gt;
&lt;p&gt;而当我们使用spring-boot-starter-jdbc的时候，构造的事务管理器则是DataSourceTransactionManager。&lt;/p&gt;
&lt;p&gt;这2个事务管理器都实现了spring中提供的PlatformTransactionManager接口，这个接口是spring的事务核心接口。&lt;/p&gt;
&lt;p&gt;这个核心接口有以下这几个常用的实现策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HibernateTransactionManager&lt;/li&gt;
&lt;li&gt;DataSourceTransactionManager&lt;/li&gt;
&lt;li&gt;JtaTransactionManager&lt;/li&gt;
&lt;li&gt;JpaTransactionManager&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的PlatformTransactionManager继承关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/transactionmanager.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Netty的单元测试</title>
    <link href="http://fangjian0423.github.io/2016/09/03/netty-unittest/"/>
    <id>http://fangjian0423.github.io/2016/09/03/netty-unittest/</id>
    <published>2016-09-03T13:04:52.000Z</published>
    <updated>2016-09-03T12:47:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。</p>
<p>在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。</p>
<p>在<a href="https://book.douban.com/subject/24700704/" target="_blank" rel="external">Netty in Action</a>书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。</p>
<a id="more"></a>
<h2 id="EmbeddedChannel介绍"><a href="#EmbeddedChannel介绍" class="headerlink" title="EmbeddedChannel介绍"></a>EmbeddedChannel介绍</h2><p>EmbeddedChannel中提供了一些方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的inbound handler处理。如果可以从EmbeddedChannel的readInbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readInbound</td>
<td>读取在EmbeddedChannel上被所有inbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>writeInbound</td>
<td>写数据到Channel中，但是这些数据只会被ChannelPipeline中的outbound handler处理。如果可以从EmbeddedChannel的readOutbound方法中读取出数据的话，就返回true</td>
</tr>
<tr>
<td>readOutbound</td>
<td>读取在EmbeddedChannel上被所有outbound handler处理过的数据，如果已经没有数据可以读取就返回null</td>
</tr>
<tr>
<td>finish</td>
<td>标记EmbeddedChannel已经完成。如果可以从inbound或者outbound中返回数据，该方法就返回true。这个方法还会关闭Channel</td>
</tr>
</tbody>
</table>
<p>下图就是EmbeddedChannel的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty10.png" alt=""></p>
<p>使用writeInbound方法写入的数据，并经过Pipeline中所有的inbound handler，之后可以使用readInbound方法读取经过inbound handler之后的数据。</p>
<p>使用writeOutbound方法写入的数据，并经过Pipeline中所有的outbound handler，之后可以使用readOutbound方法读取经过outbound handler之后的数据。</p>
<p>调用finish方法可以标记EmbeddedChannel已经完成。</p>
<h2 id="Inbound-Handler的测试"><a href="#Inbound-Handler的测试" class="headerlink" title="Inbound Handler的测试"></a>Inbound Handler的测试</h2><p>Netty内部提供了一个FixedLengthFrameDecoder解码器用于把长度不固定的字节转换成固定长度的字节，处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty11.png" alt=""></p>
<p>针对这个Decoder编写单元测试。</p>
<p>由于是个Decoder，针对的是inbound中的数据，所以需要使用的方法是writeInbound和readInbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); // 构造heap buffer
for(int i = 0; i &lt; 9; i ++) { // 写入9个字节
    buf.writeByte(i);
}

ByteBuf input = buf.copy();

// 构造EmbeddedChannel，并在Pipeline中加入FixedLengthFrameDecoder
EmbeddedChannel channel = new EmbeddedChannel(new FixedLengthFrameDecoder(3));

// 使用writeInbound方法写入数据
Assert.assertTrue(channel.writeInbound(input));
// 标记EmbeddedChannel状态已经complete
Assert.assertTrue(channel.finish());

// 读取经过FixedLengthFrameDecoder处理过后的字节
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertEquals(buf.readBytes(3), channel.readInbound());
Assert.assertNull(channel.readInbound());
</code></pre><p>我们在<a href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/">使用Netty编写自定义的协议</a>文章中编写的自定义协议CustomProtocol的解码器，并最后通过一个server和client的编写完成了测试。</p>
<p>现在我们可以使用EmbeddedChannel进行Decoder的unit test：</p>
<pre><code>EmbeddedChannel channel = new EmbeddedChannel(new CustomProtocolDecoder());
String uuid = UUID.randomUUID().toString();
channel.writeInbound(new CustomProtocol(1024l, uuid, &quot;content content&quot;));
Assert.assertTrue(channel.finish());

CustomProtocol customProtocol = (CustomProtocol) channel.readInbound();
// 判断是否正确
Assert.assertEquals(1024l, customProtocol.getVersion());
Assert.assertEquals(uuid, customProtocol.getHeader());
Assert.assertEquals(&quot;content content&quot;, customProtocol.getContent());
Assert.assertNull(channel.readInbound());
</code></pre><h2 id="Outbound-Handler的测试"><a href="#Outbound-Handler的测试" class="headerlink" title="Outbound Handler的测试"></a>Outbound Handler的测试</h2><p>AbsIntegerEncoder对所有的int数据取绝对值。处理流过图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty12.png" alt=""></p>
<pre><code>public class AbsIntegerEncoder extends MessageToMessageEncoder&lt;ByteBuf&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception {
        while(msg.readableBytes() &gt;= 4) {
            int value = Math.abs(msg.readInt());
            out.add(value);
        }
    }
}
</code></pre><p>针对这个Encoder编写单元测试。</p>
<p>由于是个Encoder，针对的是outbound中的数据，所以需要使用的方法是writeOutbound和readOutbound：</p>
<pre><code>ByteBuf buf = Unpooled.buffer(); // 构造heap buffer
for(int i = 1; i &lt; 10; i ++) { // 写入10个负数
    buf.writeInt(i * -1);
}
// 构造EmbeddedChannel，并在Pipeline中加入AbsIntegerEncoder
EmbeddedChannel channel = new EmbeddedChannel(new AbsIntegerEncoder());
// 使用writeOutbound方法写入数据
Assert.assertTrue(channel.writeOutbound(buf));
// 标记EmbeddedChannel状态已经complete
Assert.assertTrue(channel.finish());

// 测试是否所有的int数据都取了绝对值
for(int i = 1; i &lt; 10; i ++) {
    Assert.assertEquals(i, (int)channel.readOutbound());
}
Assert.assertNull(channel.readOutbound());
</code></pre><p>同理我们可以使用EmbeddedChannel进行CustomProtocol的Encoder的unit test：</p>
<pre><code>EmbeddedChannel channel = new EmbeddedChannel(new CustomProtocolEncoder());
String uuid = UUID.randomUUID().toString();

channel.writeOutbound(new CustomProtocol(1024l, uuid, &quot;content content&quot;));
Assert.assertTrue(channel.finish());

ByteBuf buf = (ByteBuf) channel.readOutbound();
Assert.assertEquals(1024l, buf.readLong());
byte[] headerBytes = new byte[36];
buf.readBytes(headerBytes);
Assert.assertEquals(uuid, new String(headerBytes));
byte[] contentBytes = new byte[buf.readableBytes()];
buf.readBytes(contentBytes);
Assert.assertEquals(&quot;content content&quot;, new String(contentBytes));
Assert.assertNull(channel.readOutbound());
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在编写完Netty程序之后，会需要进行ChannelHandler的一些测试。&lt;/p&gt;
&lt;p&gt;在初学Netty的时候，我们都是直接起一个Server，然后再写一个Client去连接Server，看传输的数据和接收到的数据是否正确。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/24700704/&quot;&gt;Netty in Action&lt;/a&gt;书中的Transport和Unit-test your code这两章就提出了可以使用EmbeddedChannel进行ChanndlHandler的单元测试。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>使用Netty编写自定义的协议</title>
    <link href="http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/"/>
    <id>http://fangjian0423.github.io/2016/08/30/netty-custom-protocol/</id>
    <published>2016-08-30T14:04:52.000Z</published>
    <updated>2016-08-30T13:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。</p>
<p>Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。</p>
<p>在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。</p>
<p>比如我们的自定义协议CucstomProtocol结构如下：</p>
<pre><code>| version | header | content |
</code></pre><p>其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。</p>
<a id="more"></a>
<p>对应的POJO如下：</p>
<pre><code>public class CustomProtocol {
    private long version; // 版本
    private String header; // 头信息(UUID)
    private String content; // 具体内容
    // GET SET ...
    @Override
    public String toString() {
        return &quot;CustomProtocol{&quot; +
                &quot;version=&quot; + version +
                &quot;, header=&apos;&quot; + header + &apos;\&apos;&apos; +
                &quot;, content=&apos;&quot; + content + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}
</code></pre><p>解码器把byte转换成CustomProtocol，在server中使用：</p>
<pre><code>public class CustomProtocolDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
        long version = in.readLong(); // 读取version

        byte[] headerBytes = new byte[36];
        in.readBytes(headerBytes); // 读取header

        String header = new String(headerBytes);

        byte[] contentBytes = new byte[in.readableBytes()]; // 读取content
        in.readBytes(contentBytes);

        out.add(new CustomProtocol(version, header, new String(contentBytes)));
    }
}
</code></pre><p>编码器把CustomProtocol转换成byte，在client中使用：</p>
<pre><code>public class CustomProtocolEncoder extends MessageToByteEncoder&lt;CustomProtocol&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, CustomProtocol msg, ByteBuf out) throws Exception {
        out.writeLong(msg.getVersion());
        out.writeBytes(msg.getHeader().getBytes());
        out.writeBytes(msg.getContent().getBytes());
    }
}
</code></pre><p>server代码：</p>
<pre><code>ServerBootstrap serverBootstrap = new ServerBootstrap();
EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
EventLoopGroup childEventLoopGroup = new NioEventLoopGroup();

try {
    serverBootstrap
            .group(eventLoopGroup, childEventLoopGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer&lt;Channel&gt;() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(new CustomProtocolDecoder()); // 解码器
                    ch.pipeline().addLast(new ServerHandler()); // 打印数据
                }
            });

    ChannelFuture future = serverBootstrap.bind(&quot;localhost&quot;, 9999).sync();

    future.channel().closeFuture().sync();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        eventLoopGroup.shutdownGracefully().sync();
        childEventLoopGroup.shutdownGracefully().sync();
    } catch (Exception e1) {
        e1.printStackTrace();
    }
}
</code></pre><p>ServerHandler用于打印接收到的数据，并写数据回去给客户端表示接收到了数据：</p>
<pre><code>public class ServerHandler extends SimpleChannelInboundHandler&lt;CustomProtocol&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, CustomProtocol msg) throws Exception {
        System.out.println(&quot;server receive: &quot; + msg);
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;server get&quot;, CharsetUtil.UTF_8)).addListener(ChannelFutureListener.CLOSE);
    }
}
</code></pre><p>client代码：</p>
<pre><code>Bootstrap bootstrap = new Bootstrap();

EventLoopGroup eventLoopGroup = new NioEventLoopGroup();

try {
    bootstrap
            .group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer&lt;Channel&gt;() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    ch.pipeline().addLast(new CustomProtocolEncoder()); // 编码器
                    ch.pipeline().addLast(new ClientHandler()); // 接收服务端数据
                }
            });
    ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 9999).sync();

    channelFuture.channel().writeAndFlush(new CustomProtocol(1024l, UUID.randomUUID().toString(), &quot;content detail&quot;));

    channelFuture.channel().closeFuture().sync();
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        eventLoopGroup.shutdownGracefully().sync();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><p>ClientHandler用于接收服务端返回回来的数据：</p>
<pre><code>public class ClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
        System.out.println(&quot;send success, response is: &quot; + msg.toString(CharsetUtil.UTF_8));
    }
}
</code></pre><p>启动服务端和客户端之后，服务端收到客户端发来的CustomProtocol：</p>
<pre><code>server receive: CustomProtocol{version=1024, header=&apos;6ed7fa3d-7d54-4add-9081-d659d4b37d3f&apos;, content=&apos;content detail&apos;}
</code></pre><p>之后客户端也收到服务端成功接收数据的反馈：</p>
<pre><code>send success, response is: server get
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty内部提供的Codec用于处理消息的编解码问题，比如Http，Ftp，SMTP这些协议，都需要进行编解码。&lt;/p&gt;
&lt;p&gt;Netty内部直接提供了Http协议的Codec组件用于编解码Http协议。&lt;/p&gt;
&lt;p&gt;在开发过程中，有时候我们需要构建一些适应自己业务的应用层协议，Netty可以很方便地实现自定义协议。&lt;/p&gt;
&lt;p&gt;比如我们的自定义协议CucstomProtocol结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| version | header | content |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中version表示版本号，long类型；header是一个uuid，string类型，content则是具体的内容，string类型。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty in Action笔记(二)</title>
    <link href="http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/"/>
    <id>http://fangjian0423.github.io/2016/08/29/netty-in-action-note2/</id>
    <published>2016-08-29T12:36:52.000Z</published>
    <updated>2016-08-29T12:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。</p>
<a id="more"></a>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>介绍Netty中的Channel、ChannelHandler、ChannelHandlerContext以及ChannelPipeline。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>定义：一个Channel表示一个通道，跟io中的stream的角色一样，但是有几点不同。 1. stream是单向的，只支持读或者写，channel是双向的，既支持读也支持写。2. stream是阻塞的，channel是并行的。</p>
<p>其中Channel的生命周期状态如下：</p>
<table>
<thead>
<tr>
<th>状态说明</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelUnregistered</td>
<td>channel创建之后，还未注册到EventLoop</td>
</tr>
<tr>
<td>channelRegistered</td>
<td>channel注册到了对应的EventLoop</td>
</tr>
<tr>
<td>channelActive</td>
<td>channel处于活跃状态，活跃状态表示已经连接到了远程服务器，现在可以接收和发送数据</td>
</tr>
<tr>
<td>channelInactive</td>
<td>channel未连接到远程服务器</td>
</tr>
</tbody>
</table>
<p>一个Channel正常的生命周期如下：</p>
<p>channelRegistered -&gt; channelActice -&gt; channelInactive -&gt; channelUnregistered</p>
<p>在另外一种特殊情况下，会发生多次channelRegistered和channelUnregistered，这是因为用户可以从EventLoop上取消注册Channel来阻止事件的执行并在之后重新注册。状态变化如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty03.png" alt=""></p>
<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>ChannelHandler有2种类型：</p>
<ol>
<li>Inbound Handler: 处理inbound数据(接收到的数据)以及所有类型的channel状态修改事件</li>
<li>Outbound Handler: 处理outbound数据(发送出去的数据)并且可以拦截各种操作，比如bind、connect、disconnect、close、write等操作</li>
</ol>
<p>Inbound和Outbound Handler都属于ChannelHandler，它们都可以被添加到ChannelPipeline中，它们内部也提供了handlerAdded、handlerRemoved这两种方法分别在ChannelHandler添加到ChannelPipeline和ChannelHandler从ChannelPipeline中被删除的时候触发。</p>
<h4 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h4><p>ChannelInboundHandler方法在两种情况下触发：channel状态的改变和channel接收到数据。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>channelRegistered(..)</td>
<td>Channel注册到EventLoop，并且可以处理IO请求</td>
</tr>
<tr>
<td>channelUnregistered(…)</td>
<td>Channel从EventLoop中被取消注册，并且不能处理任何IO请求</td>
</tr>
<tr>
<td>channelActive(…)</td>
<td>Channel已经连接到远程服务器，并准备好了接收数据</td>
</tr>
<tr>
<td>channelInactive(…)</td>
<td>Channel还没有连接到远程服务器</td>
</tr>
<tr>
<td>channelReadComplete(…)</td>
<td>Channel的读取操作已经完成</td>
</tr>
<tr>
<td>channelRead(…)</td>
<td>有数据可以读取的时候触发</td>
</tr>
<tr>
<td>userEventTriggered(…)</td>
<td>当用户调用Channel.fireUserEventTriggered方法的时候触发，用户可以传递一个自定义的对象当这个方法里</td>
</tr>
</tbody>
</table>
<p>ChannelInboundHandler有一个实现ChannelInboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>ChannelInboundHandler中的channelRead方法中有读取的ByteBuf。由于Netty在ByteBuf的使用上使用了池的概念，当不需要这个ByteBuf的时候需要进行资源的释放以减少内存的消耗。</p>
<pre><code>@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
      // do something
      ReferenceCountUtil.release(msg);
}
</code></pre><p>Netty内部提供了一个SimpleChannelInboundHandler类，这个类读取数据会自动释放资源。它继承ChannelInboundHandlerAdapter并复写了channelRead方法，在channelRead方法里面finally代码里会自动release资源，并提供了channelRead0方法：</p>
<pre><code>@Override
public void channelRead0(ChannelHandlerContext ctx, Object msg) {
      // do something, do not need release
}
</code></pre><p>所以一般使用ChannelInboundHandler的话，有3种方法。 </p>
<ol>
<li>直接实现ChannelInBoundHandler接口 </li>
<li>继承ChannelInboundHandlerAdapter</li>
<li>继承SimpleChannelInboundHandler</li>
</ol>
<p>第1种基本不用，第3种用来处理接收消息，第2种用来处理事件状态的改变</p>
<h4 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h4><p>ChannelOutboundHandler方法在两种情况下触发：发送数据和拦截操作。</p>
<p>ChannelOutboundHandler有一个强大的功能，可以按需推迟一个操作，这使得处理请求可以用到更为复杂的策略。比如，如果写数据到远端被暂停，你可以推迟flush操作，稍后再试。</p>
<p>一些方法说明：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bind(..)</td>
<td>请求绑定channel到本地地址</td>
</tr>
<tr>
<td>connect(…)</td>
<td>channel连接到远程地址</td>
</tr>
<tr>
<td>disconnect(…)</td>
<td>channel从远程服务器上断开</td>
</tr>
<tr>
<td>close(…)</td>
<td>关闭channel</td>
</tr>
<tr>
<td>deregister(…)</td>
<td>取消channel在eventloop上的注册</td>
</tr>
<tr>
<td>read(…)</td>
<td>在channel中读数据</td>
</tr>
<tr>
<td>flush(…)</td>
<td>flush数据到远程服务器</td>
</tr>
<tr>
<td>write(…)</td>
<td>写数据到远程服务器</td>
</tr>
</tbody>
</table>
<p>ChannelOutboundHandler有一个实现ChannelOutboundHandlerAdapter，它实现了所有的方法，我们只需要继承这个类然后复写需要的方法即可。</p>
<p>在outboundhandler中有时候也需要释放资源，当消息被消费并且不再需要传递给下一个outbound handler的时候，调用ReferenceCountUtil.release(message)释放消息。</p>
<p>当消息被写回去或者channel关闭的时候，这个消息的资源会被自动释放，所以没有一个类似SimpleChannelInboundHandler的概念。</p>
<h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>当ChannelHandler被添加到ChannelPipeline中的时候，ChannelHandlerContext会被创建。<br>所以说ChannelHandlerContext属于ChannelHandler。</p>
<p>可以通过ChannelHandlerContext的channel方法得到Channel和pipeline方法得到ChannelPipeline。</p>
<p>ChannelHandlerContext可以被保留下来并且在其他地方进行调用，比如在其他线程，或者在handler外部进行调用。</p>
<p>可以使用以下方法保留ChannelHandlerContext：</p>
<pre><code>class WriterHandler extends ChannelHandlerAdapter {
  private ChannelHandlerContext ctx;

  @Override
  public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
      this.ctx = ctx;
  }

  public void send(String msg) {
      ctx.write(msg);
  }
}
</code></pre><p>Netty中提供了一个@Sharable注解用来将一个实例的ChannelHandler添加到多个ChannelPipeline中，如果不加上这个注解，被多个ChannelPipeline使用的话会抛出异常。</p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>多个ChannelHandler可以组成一个ChannelPipeline，里面的每个ChannelHandler可以转发给下一个ChannelHandler。</p>
<p>ChannelPipeline内部的所有ChannelHandler的处理流程图：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty01.png" alt=""></p>
<p>ChannelPipeline提供了多种方法用于添加或删除或代替ChannelHandler，比如addLast, addFirst, remove, replace等方法。</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>介绍Netty中的编码器、解码器。我们知道网络中传输的是字节-ByteBuf。我们需要对ByteBuf进行一些解码用于解码成熟悉的POJO，对ByteBuf进行编码用于网络传输。</p>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>解码器，针对的是inbound的数据，也就是读取数据的解码。</p>
<p>2种类型：</p>
<ol>
<li>bytes到message的解码(ByteToMessageDecoder和ReplayingDecoder)</li>
<li>message到message的解码(MessageToMessageDecoder)</li>
</ol>
<p>decoders的作用是把inbound中读取的数据从一种格式转换成另一种格式，由于decoders处理的是inbound中的数据，所以它也是ChannelInboundHandler的一种实现类。</p>
<p>ByteToMessageDecoder和ReplayingDecoder属于bytes到message的解码。</p>
<p>一个ByteToMessageDecoder例子，将byte转换成integer：</p>
<pre><code>public class ToIntegerDecoder extends ByteToMessageDecoder {
    @Override  protected void decode(ChannelHandlerContext ctx, ByteBuf in,     List&lt;Object&gt; out) throws Exception {
        if(in.readableBytes() &gt;= 4) {
            out.add(in.readInt());
        }
    }    
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty04.png" alt=""></p>
<p>如果使用ReplayingDecoder，不需要进行可读字节的判断，直接添加到List里即可。跟ToIntegerDecoder实现一样的功能，ReplayingDecoder只需要这样即可。(但是有一定的局限性：1.不是所有的操作都被ByteBuf支持 2.ByteBuf.readableBytes方法大部分时间不会返回期望的值)</p>
<pre><code>public class ToIntegerDecoder2 extends ReplayingDecoder&lt;Void&gt; {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;     out) throws Exception {
        out.add(in.readInt());
    }
}
</code></pre><p>一个MessageToMessageDecoder例子，将integer转换成string：</p>
<pre><code>public class IntegerToStringDecoder extends MessageToMessageDecoder&lt;Integer&gt; {
    @Override
    protected void decode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception {
        out.add(String.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty05.png" alt=""></p>
<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>编码器，针对的是outbound的数据，也就是发送出去的数据的编码。</p>
<p>2种类型：</p>
<ol>
<li>message到message的编码(MessageToMessageEncoder)</li>
<li>message到byte的编码(MessageToByteEncoder)</li>
</ol>
<p>decoders的作用是把outbound中发送出去的数据从一种格式转换成另一种格式，由于eecoders处理的是outbound中的数据，所以它也是ChannelOutboundHandler的一种实现类。</p>
<p>一个MessageToByteEncoder例子，将integer转换成byte：</p>
<pre><code>public class IntegerToByteEncoder extends MessageToByteEncoder&lt;Integer&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception {
        out.writeInt(msg);
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty06.png" alt=""></p>
<p>一个MessageToMessageEncoder例子，将integer转换成string：</p>
<pre><code>public class IntegerToStringEncoder extends MessageToMessageEncoder&lt;Integer&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception {
        out.add(String.valueOf(msg));
    }
}
</code></pre><p>处理流程图如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty07.png" alt=""></p>
<h3 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h3><p>编解码器，既支持编码器的功能，也支持解码器的功能。</p>
<p>2种类型：</p>
<ol>
<li>ByteToMessageCodec：message到byte的编解码</li>
<li>MessageToMessageCodec：message到message的编解码</li>
</ol>
<h3 id="CombinedChannelDuplexHandler"><a href="#CombinedChannelDuplexHandler" class="headerlink" title="CombinedChannelDuplexHandler"></a>CombinedChannelDuplexHandler</h3><p>结合解码器和编码器在一起可能会牺牲可重用性。为了避免这种方式，可以使用CombinedChannelDuplexHandler。</p>
<p>CombinedChannelDuplexHandler也就是codec的另外一种方式，如果已经有个encoder和decoder，不需要重新写了codec，直接使用CombinedChannelDuplexHandler整合这个encoder和decoder即可。</p>
<p>上面的ToIntegerDecoder和IntegerToByteEncoder就可以构成一个编解码器，直接使用CombinedChannelDuplexHandler即可。</p>
<pre><code>public class CombinedByteIntegerCodec extends CombinedChannelDuplexHandler&lt;ToIntegerDecoder, IntegerToByteEncoder&gt; {
    public CombinedByteIntegerCodec() {
        super(new ToIntegerDecoder(), new IntegerToByteEncoder());
    }
}
</code></pre><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>主要说明jetty内置的一些ChannelHandler和Codec。</p>
<p>使用SSL/TLS加密Netty程序的话，可以使用内置的SslHandler。</p>
<p>要构建Http应用的话，可以使用HttpClientCodec/HttpServerCodec(http客户端和服务端的编解码)以及HttpObjectAggregator(Http的消息聚合)。</p>
<p>可以使用HttpContentDecompressor和HttpContentCompressor对http的内容进行解压和压缩。</p>
<p>还有一些WebSocket、SPDY，一些空置链接、超时链接等处理的内置解决方案。</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>主要讲解Bootstrap中Netty中的作用。</p>
<p>之前分析过各种ChannelHandler，各种Codec，以及把这两个东西添加到Channel 的ChannelPipeline中。有了这些东西之后，该用什么把他们整合起来呢，那就是Bootstrap。</p>
<p>Bootstrap分别ServerBootstrap(服务端)和Bootstrap(客户端)，它们都继承AbstractBootstrap。</p>
<h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>客户端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置Bootstrap使用的EventLoopGroup，用来处理Channel的IO操作</td>
</tr>
<tr>
<td>channel(..)</td>
<td>Channel的类型，比如有NioSocketChannel, OioSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果Channel没有没有参数的构造函数，需要使用ChannelFactory构造Channel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>Channel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的Bootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>remoteAddress()..)</td>
<td>设置远程地址，也可以在调用connect方法的时候设置</td>
</tr>
<tr>
<td>connect()..)</td>
<td>链接到远程地址</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>需要注意的是如果EventLoopGroup选择的是NioEventLoopGroup，那么对应的channel需要选择NioSocketChannel，否则会抛出兼容性的错误异常。</p>
<h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><p>服务端服务启动类，内部提供的一些方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(..)</td>
<td>设置ServerBootstrap使用的EventLoopGroup，用来处理ServerChannel的IO操作并接收Channel</td>
</tr>
<tr>
<td>channel(..)</td>
<td>ServerChannel的类型，比如有NioServerSocketChannel, OioServerSocketChannel等</td>
</tr>
<tr>
<td>channelFactory(..)</td>
<td>如果ServerChannel没有没有参数的构造函数，需要使用ChannelFactory构造ServerChannel</td>
</tr>
<tr>
<td>localAddress(..)</td>
<td>ServerChannel需要绑定的地址和端口，可以不调用，使用connect或者bind再进行设置</td>
</tr>
<tr>
<td>option(..)</td>
<td>一些ServerChannel可选的设置，使用ChannelOptions完成。比如keep-alive时间，超时时间</td>
</tr>
<tr>
<td>childOption(..)</td>
<td>被ServerChannel接收的Channel的可选的设置，使用ChannelOptions完成</td>
</tr>
<tr>
<td>handler(..)</td>
<td>设置ServerChannel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>childHandler(..)</td>
<td>设置被ServerChannel接收的Channel的ChannelHandler处理事件</td>
</tr>
<tr>
<td>clone(..)</td>
<td>复制一个新的ServerBootstrap，AbstractBootstrap实现了Cloneable接口</td>
</tr>
<tr>
<td>bind()..)</td>
<td>绑定本地端口</td>
</tr>
</tbody>
</table>
<p>ServerBootstrap的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty08.png" alt=""></p>
<p>ServerBootstrap调用bind绑定地址和端口的时候，会创建ServerChannel。这个ServerChannel会接收客户的各个链接，针对各个链接创建Channel。</p>
<p>handler方法就是为ServerChannel服务的，而childHandler是给被ServerChannel接收的Channel服务器的。所以说只要服务器已起来，handler中的ChannelHandler就会触发，而有链接被ServerChannel接收之后childHandler中的ChannelHandler才会触发。</p>
<h3 id="从一个已经存在的Channel中使用Bootstrap启动客户端"><a href="#从一个已经存在的Channel中使用Bootstrap启动客户端" class="headerlink" title="从一个已经存在的Channel中使用Bootstrap启动客户端"></a>从一个已经存在的Channel中使用Bootstrap启动客户端</h3><p>在ServerBootstrap接收到新的Channel的时候准备启动Bootstrap客户端的时候，可以使用一个全新的EventLoop用于处理Channel的IO模型。</p>
<p>但是没有必要，可以跟ServerBootstrap共享同一个EventLoop，因为一个EventLoop是跟一个线程绑定的，如果使用了多个EventLoop的话，那就相当于需要进行线程的上下文切换，需要消耗一定的资源。</p>
<p>1个在ServerBootstrap接收到链接之后，使用Bootstrap链接另外一个地址的处理过程：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/netty09.png" alt=""></p>
<p>其中第3点就是ServerChannel接收到的新的Channel，第5点是Bootstrap创建的连接到远程服务器的Channel，它们使用同一个EventLoop。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录ChannelHandler、Codec以及Bootstrap的作用，还有Netty内置的一些ChannelHandler、Codec，以及Bootstrap的分类。&lt;/p&gt;
    
    </summary>
    
      <category term="netty" scheme="http://fangjian0423.github.io/categories/netty/"/>
    
    
      <category term="nio" scheme="http://fangjian0423.github.io/tags/nio/"/>
    
      <category term="netty" scheme="http://fangjian0423.github.io/tags/netty/"/>
    
  </entry>
  
</feed>
