<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Format&#39;s Notes</title>
  <subtitle>吃饭睡觉撸代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fangjian0423.github.io/"/>
  <updated>2017-08-24T15:00:40.000Z</updated>
  <id>http://fangjian0423.github.io/</id>
  
  <author>
    <name>Format</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot源码分析之日志系统的构造</title>
    <link href="http://fangjian0423.github.io/2017/08/23/springboot-logging-system/"/>
    <id>http://fangjian0423.github.io/2017/08/23/springboot-logging-system/</id>
    <published>2017-08-23T07:32:34.000Z</published>
    <updated>2017-08-24T15:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot对日志的配置和加载进行了封装，让我们可以很方便地使用一些日志框架，只需要定义对应日志框架的配置文件，比如LogBack、Log4j、Log4j2等，代码内部便可以直接使用。</p>
<p>比如我们在resources目录下定义了一个logback.xml文件，文件内容是logback相关的配置，然后就可以直接在代码在使用Logger记录日志啦。</p>
<p>下图是SpringBoot对日志功能的封装：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/logging-system.png" alt=""></p>
<a id="more"></a>
<h2 id="LoggingSystem内部结构"><a href="#LoggingSystem内部结构" class="headerlink" title="LoggingSystem内部结构"></a>LoggingSystem内部结构</h2><p>从图中也可以发现目前SpringBoot支持4种类型的日志，分别是JDK内置的Log(JavaLoggingSystem)、Log4j(Log4JLoggingSystem)、Log4j2(Log4J2LoggingSystem)以及Logback(LogbackLoggingSystem)。</p>
<p>LoggingSystem是个抽象类，内部有这几个方法：</p>
<ol>
<li>beforeInitialize方法：日志系统初始化之前需要处理的事情。抽象方法，不同的日志架构进行不同的处理</li>
<li>initialize方法：初始化日志系统。默认不进行任何处理，需子类进行初始化工作</li>
<li>cleanUp方法：日志系统的清除工作。默认不进行任何处理，需子类进行清除工作</li>
<li>getShutdownHandler方法：返回一个Runnable用于当jvm退出的时候处理日志系统关闭后需要进行的操作，默认返回null，也就是什么都不做</li>
<li>setLogLevel方法：抽象方法，用于设置对应logger的级别</li>
</ol>
<p>AbstractLoggingSystem抽象类继承LoggingSystem抽象类，进行了一些扩展，重点在于initialize方法：</p>
<ol>
<li>实现了beforeInitialize方法，但是内部不做任何处理</li>
<li>复写了initialize方法，具体过程如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(LoggingInitializationContext initializationContext,</span></span></div><div class="line">		String configLocation, LogFile logFile) &#123;</div><div class="line">	<span class="comment">// 如果传递了日志配置文件，调用initializeWithSpecificConfig方法，使用指定的文件</span></div><div class="line">	<span class="keyword">if</span> (StringUtils.hasLength(configLocation)) &#123;</div><div class="line">		initializeWithSpecificConfig(initializationContext, configLocation, logFile);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 没有传递日志配置文件的话调用initializeWithConventions方法，使用约定俗成的方式</span></div><div class="line">	initializeWithConventions(initializationContext, logFile);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithSpecificConfig</span><span class="params">(</span></span></div><div class="line">		LoggingInitializationContext initializationContext, String configLocation,</div><div class="line">		LogFile logFile) &#123;</div><div class="line">	<span class="comment">// 处理日志配置文件中的占位符</span></div><div class="line">	configLocation = SystemPropertyUtils.resolvePlaceholders(configLocation);</div><div class="line">	loadConfiguration(initializationContext, configLocation, logFile);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWithConventions</span><span class="params">(</span></span></div><div class="line">		LoggingInitializationContext initializationContext, LogFile logFile) &#123;</div><div class="line">	<span class="comment">// 获取自初始化的日志配置文件，该方法会使用getStandardConfigLocations抽象方法得到的文件数组</span></div><div class="line">	<span class="comment">// 然后进行遍历，如果文件存在，返回对应的文件目录。注意这里的文件指的是classpath下的文件</span></div><div class="line">	String config = getSelfInitializationConfig();</div><div class="line">	<span class="comment">// 如果找到对应的日志配置文件并且logFile为null(logFile为null表示只有console会输出)</span></div><div class="line">	<span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; logFile == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 调用reinitialize方法重新初始化</span></div><div class="line">		<span class="comment">// 默认的reinitialize方法不做任何处理，logback,log4j和log4j2覆盖了这个方法，会进行处理</span></div><div class="line">		reinitialize(initializationContext);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 如果没有找到对应的日志配置文件</span></div><div class="line">	<span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 调用getSpringInitializationConfig方法获取日志配置文件</span></div><div class="line">		<span class="comment">// 该方法与getSelfInitializationConfig方法的区别在于getStandardConfigLocations方法得到的文件数组内部遍历的逻辑</span></div><div class="line">		<span class="comment">// getSelfInitializationConfig方法直接遍历并判断classpath下是否存在对应的文件</span></div><div class="line">		<span class="comment">// getSpringInitializationConfig方法遍历后判断的文件名会在后缀前加上 "-spring" 字符串</span></div><div class="line">		<span class="comment">// 比如查找logback.xml文件，getSelfInitializationConfig会直接查找classpath下是否存在logback.xml文件，而getSpringInitializationConfig方法会判断classpath下是否存在logback-spring.xml文件</span></div><div class="line">		config = getSpringInitializationConfig();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 如果找到了对应的日志配置文件</span></div><div class="line">	<span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 调用loadConfiguration抽象方法，让子类实现</span></div><div class="line">		loadConfiguration(initializationContext, config, logFile);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 还是没找到日志配置文件的话，调用loadDefaults抽象方法加载，让子类实现</span></div><div class="line">	loadDefaults(initializationContext, logFile);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> String[] getStandardConfigLocations();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadConfiguration</span><span class="params">(</span></span></div><div class="line">		LoggingInitializationContext initializationContext, String location,</div><div class="line">		LogFile logFile);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadDefaults</span><span class="params">(</span></span></div><div class="line">		LoggingInitializationContext initializationContext, LogFile logFile);</div></pre></td></tr></table></figure>
<p>以LogbackLoggingSystem类为例，分析具体的初始化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LogbackLoggingSystem.class</span></div><div class="line"></div><div class="line"><span class="comment">// 根据上面AbstractLoggingSystem的分析</span></div><div class="line"><span class="comment">// 使用logback日志库的时候会查找classpath下是否存在这些文件</span></div><div class="line"><span class="comment">// logback-test.groovy、logback-test.xml、logback.groovy、logback.xml以及</span></div><div class="line"><span class="comment">// logback-test-spring.groovy、logback-test-spring.xml、logback-spring.groovy、logback-spring.xml</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> String[] getStandardConfigLocations() &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"logback-test.groovy"</span>, <span class="string">"logback-test.xml"</span>, <span class="string">"logback.groovy"</span>,</div><div class="line">			<span class="string">"logback.xml"</span> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// logback具体的初始化加载过程</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadConfiguration</span><span class="params">(LoggingInitializationContext initializationContext,</span></span></div><div class="line">		String location, LogFile logFile) &#123;</div><div class="line">	<span class="comment">// 调用父类Slf4JLoggingSystem的loadConfiguration方法</span></div><div class="line">	<span class="keyword">super</span>.loadConfiguration(initializationContext, location, logFile);</div><div class="line">	<span class="comment">// 获取slf4j内部的LoggerContext</span></div><div class="line">	LoggerContext loggerContext = getLoggerContext();</div><div class="line">	<span class="comment">// logback环境的一些配置配置处理</span></div><div class="line">	stopAndReset(loggerContext);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		configureByResourceUrl(initializationContext, loggerContext,</div><div class="line">				ResourceUtils.getURL(location));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">				<span class="string">"Could not initialize Logback logging from "</span> + location, ex);</div><div class="line">	&#125;</div><div class="line">	List&lt;Status&gt; statuses = loggerContext.getStatusManager().getCopyOfStatusList();</div><div class="line">	StringBuilder errors = <span class="keyword">new</span> StringBuilder();</div><div class="line">	<span class="keyword">for</span> (Status status : statuses) &#123;</div><div class="line">		<span class="keyword">if</span> (status.getLevel() == Status.ERROR) &#123;</div><div class="line">			errors.append(errors.length() &gt; <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">""</span>);</div><div class="line">			errors.append(status.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (errors.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">				<span class="string">"Logback configuration error "</span> + <span class="string">"detected: \n"</span> + errors);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 没找到日志配置文件的话使用loadDefaults方法加载</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDefaults</span><span class="params">(LoggingInitializationContext initializationContext,</span></span></div><div class="line">		LogFile logFile) &#123;</div><div class="line">	<span class="comment">// 获取slf4j内部的LoggerContext</span></div><div class="line">	LoggerContext context = getLoggerContext();</div><div class="line">	stopAndReset(context);</div><div class="line">	LogbackConfigurator configurator = <span class="keyword">new</span> LogbackConfigurator(context);</div><div class="line">	context.putProperty(<span class="string">"LOG_LEVEL_PATTERN"</span>,</div><div class="line">			initializationContext.getEnvironment().resolvePlaceholders(</div><div class="line">					<span class="string">"$&#123;logging.pattern.level:$&#123;LOG_LEVEL_PATTERN:%5p&#125;&#125;"</span>));</div><div class="line">	<span class="comment">// 构造默认的console Appender。如果logFile不为空，还会构造file Appender</span></div><div class="line">	<span class="keyword">new</span> DefaultLogbackConfiguration(initializationContext, logFile)</div><div class="line">			.apply(configurator);</div><div class="line">	context.setPackagingDataEnabled(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// logback的清除工作</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.cleanUp();</div><div class="line">	getLoggerContext().getStatusManager().clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 动态设置logger的level</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogLevel</span><span class="params">(String loggerName, LogLevel level)</span> </span>&#123;</div><div class="line">	getLogger(loggerName).setLevel(LEVELS.get(level));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 清除后的一些工作</span></div><div class="line"><span class="comment">// ShutdownHandler会调用LoggerContext的stop方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Runnable <span class="title">getShutdownHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ShutdownHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LoggingSystem的初始化"><a href="#LoggingSystem的初始化" class="headerlink" title="LoggingSystem的初始化"></a>LoggingSystem的初始化</h2><p>LoggingApplicationListener是ApplicationListener接口的实现类，会被springboot使用工厂加载机制加载：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// spring-boot-version.jar/META-INF/spring.factories</div><div class="line"># Application Listeners</div><div class="line">org.springframework.context.ApplicationListener=\</div><div class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</div><div class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</div><div class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</div><div class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</div><div class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</div><div class="line">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\</div><div class="line">org.springframework.boot.logging.ClasspathLoggingApplicationListener,\</div><div class="line">org.springframework.boot.logging.LoggingApplicationListener</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SpringApplication.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</div><div class="line">	setInitializers((Collection) getSpringFactoriesInstances(</div><div class="line">			ApplicationContextInitializer.class));</div><div class="line">	<span class="comment">// 使用工厂加载机制找到这些Listener</span></div><div class="line">	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</div><div class="line">	<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LoggingApplicationListener.class</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line">	<span class="comment">// SpringApplication的run方法执行的时候触发该事件</span></div><div class="line">	<span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationStartedEvent) &#123;</div><div class="line">		<span class="comment">// onApplicationStartedEvent方法内部会先得到LoggingSystem，然后调用beforeInitialize方法</span></div><div class="line">		onApplicationStartedEvent((ApplicationStartedEvent) event);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 环境信息准备好，ApplicationContext创建之前触发该事件</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</div><div class="line">		<span class="comment">// onApplicationEnvironmentPreparedEvent方法内部会做一下几个事情</span></div><div class="line">		<span class="comment">// 1. 读取配置文件中"logging."开头的配置，比如logging.pattern.level, logging.pattern.console等设置到系统属性中</span></div><div class="line">		<span class="comment">// 2. 构造一个LogFile(LogFile是对日志对外输出文件的封装)，使用LogFile的静态方法get构造，会使用配置文件中logging.file和logging.path配置构造</span></div><div class="line">		<span class="comment">// 3. 判断配置中是否配置了debug并为true，如果是，设置level的DEBUG，然后继续查看是否配置了trace并为true，如果是，设置level的TRACE</span></div><div class="line">		<span class="comment">// 4. 构造LoggingInitializationContext，查看是否配置了logging.config，如有配置，调用LoggingSystem的initialize方法并带上该参数，否则调用initialize方法并且configLocation为null</span></div><div class="line">		<span class="comment">// 5. 设置一些比如org.springframework.boot、org.springframework、org.apache.tomcat、org.apache.catalina、org.eclipse.jetty、org.hibernate.tool.hbm2ddl、org.hibernate.SQL这些包的log level，跟第3步的level一样</span></div><div class="line">		<span class="comment">// 6. 查看是否配置了logging.register-shutdown-hook，如配置并设置为true，使用addShutdownHook的addShutdownHook方法加入LoggingSystem的getShutdownHandler</span></div><div class="line">		onApplicationEnvironmentPreparedEvent(</div><div class="line">				(ApplicationEnvironmentPreparedEvent) event);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Spring容器创建好，并进行了部分操作之后触发该事件</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</div><div class="line">		<span class="comment">// onApplicationPreparedEvent方法内部会把LoggingSystem注册到BeanFactory中(前期是BeanFactory中不存在name为springBootLoggingSystem的实例)</span></div><div class="line">		onApplicationPreparedEvent((ApplicationPreparedEvent) event);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Spring容器关闭的时候触发该事件</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent &amp;&amp; ((ContextClosedEvent) event)</div><div class="line">			.getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// onContextClosedEvent方法内部调用LoggingSystem的cleanUp方法进行清除工作</span></div><div class="line">		onContextClosedEvent();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationStartedEvent</span><span class="params">(ApplicationStartedEvent event)</span> </span>&#123;</div><div class="line">	<span class="comment">// 一开始先使用LoggingSystem的静态方法get获取LoggingSystem</span></div><div class="line">	<span class="comment">// 静态方法get会从下面那段static代码块中得到的Map中进行遍历</span></div><div class="line">	<span class="comment">// 如果对应的key(key是某个类的全名)在classloader中存在，那么会构造该key对应的value对应的LoggingSystem</span></div><div class="line">	<span class="keyword">this</span>.loggingSystem = LoggingSystem</div><div class="line">			.get(event.getSpringApplication().getClassLoader());</div><div class="line">	<span class="keyword">this</span>.loggingSystem.beforeInitialize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">	Map&lt;String, String&gt; systems = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</div><div class="line">	systems.put(<span class="string">"ch.qos.logback.core.Appender"</span>,</div><div class="line">			<span class="string">"org.springframework.boot.logging.logback.LogbackLoggingSystem"</span>);</div><div class="line">	systems.put(<span class="string">"org.apache.logging.log4j.core.impl.Log4jContextFactory"</span>,</div><div class="line">			<span class="string">"org.springframework.boot.logging.log4j2.Log4J2LoggingSystem"</span>);</div><div class="line">	systems.put(<span class="string">"org.apache.log4j.PropertyConfigurator"</span>,</div><div class="line">			<span class="string">"org.springframework.boot.logging.log4j.Log4JLoggingSystem"</span>);</div><div class="line">	systems.put(<span class="string">"java.util.logging.LogManager"</span>,</div><div class="line">			<span class="string">"org.springframework.boot.logging.java.JavaLoggingSystem"</span>);</div><div class="line">	SYSTEMS = Collections.unmodifiableMap(systems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(</span></span></div><div class="line">		ApplicationEnvironmentPreparedEvent event) &#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.loggingSystem == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">this</span>.loggingSystem = LoggingSystem</div><div class="line">				.get(event.getSpringApplication().getClassLoader());</div><div class="line">	&#125;</div><div class="line">	initialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationPreparedEvent</span><span class="params">(ApplicationPreparedEvent event)</span> </span>&#123;</div><div class="line">	ConfigurableListableBeanFactory beanFactory = event.getApplicationContext()</div><div class="line">			.getBeanFactory();</div><div class="line">	<span class="keyword">if</span> (!beanFactory.containsBean(LOGGING_SYSTEM_BEAN_NAME)) &#123;</div><div class="line">		beanFactory.registerSingleton(LOGGING_SYSTEM_BEAN_NAME, <span class="keyword">this</span>.loggingSystem);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onContextClosedEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.loggingSystem != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">this</span>.loggingSystem.cleanUp();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>spring-boot-starter模块内部会引用spring-boot-starter-logging模块，这个starter-logging模块内部会引入logback相关的依赖。这一依赖会导致LoggingSystem的静态方法get获取LoggingSystem的时候会得到LogbackLoggingSystem。</p>
<p>因此默认情况下，springboot程序基本都是使用logback作为默认的日志。</p>
<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>前提都是以LogbackLoggingSystem作为日志系统。</p>
<h3 id="项目里没有任何日志的配置"><a href="#项目里没有任何日志的配置" class="headerlink" title="项目里没有任何日志的配置"></a>项目里没有任何日志的配置</h3><p>由于没有任何配置，进行initialize的时候日志配置文件为null，最后只能调用loadDefaults方法进行加载，LogbackLoggingSystem的loadDefaults方法，由于logFile为null，所以最终只构造了一个ConsoleAppender。</p>
<p>所以项目没有任何日志配置的情况下，控制台依旧能打印出项目的启动信息。</p>
<h3 id="项目里没有任何logback的配置，只有yaml中配置了logging-file和logging-path"><a href="#项目里没有任何logback的配置，只有yaml中配置了logging-file和logging-path" class="headerlink" title="项目里没有任何logback的配置，只有yaml中配置了logging.file和logging.path"></a>项目里没有任何logback的配置，只有yaml中配置了logging.file和logging.path</h3><p>logging.file和logging.path的配置在LogFile这个日志文件类中生效。</p>
<p>比如yaml配置如下(只定义了logging.file)：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">logging:</span></div><div class="line"><span class="attr">  file:</span> /tmp/temp.log</div></pre></td></tr></table></figure>
<p>这个配置导致了调用initialize方法的时候logFile存在，这样不止有ConsoleAppender，还有一个FileAppender，这个FileAppender对应的文件就是LogFile文件，也就是 /tmp/temp.log日志文件。</p>
<p>比如yaml配置如下(只定义了logging.path)：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">logging:</span></div><div class="line"><span class="attr">  path:</span> /tmp</div></pre></td></tr></table></figure>
<p>这个时候FileAppender对应的file是/tmp/spring.log文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LogFile.class</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">// 如果配置了logging.file，直接使用该文件</span></div><div class="line">	<span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.file)) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.file;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 否则使用logging.path目录，在该目录下创建spring.log日志文件</span></div><div class="line">	String path = <span class="keyword">this</span>.path;</div><div class="line">	<span class="keyword">if</span> (!path.endsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">		path = path + <span class="string">"/"</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> StringUtils.applyRelativePath(path, <span class="string">"spring.log"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们如果配置了logging.path和logging.file，那么生效的只有logging.file配置。</p>
<h3 id="resources下有logback-xml配置-相当于就是classpath下存在logback-xml文件"><a href="#resources下有logback-xml配置-相当于就是classpath下存在logback-xml文件" class="headerlink" title="resources下有logback.xml配置(相当于就是classpath下存在logback.xml文件)"></a>resources下有logback.xml配置(相当于就是classpath下存在logback.xml文件)</h3><p>之前分析过，LogbackLoggingSystem中的getStandardConfigLocations方法返回以下文件：</p>
<ol>
<li>logback-test.groovy或者logback-test-spring.groovy</li>
<li>logback-test.xml或者logback-test-spring.xml</li>
<li>logback.groovy或者logback-spring.groovy</li>
<li>logback.xml或者logback-spring.xml</li>
</ol>
<p>在resources目录下定义logback-spring.xml文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--&lt;pattern&gt;%d&#123;YYYY-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger[%line] &amp;#45;&amp;#45; %msg%n&lt;/pattern&gt;--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;YYYY-MM-dd&#125; [%thread] %-5level %logger[%line] -- %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这时logging.file配置失效，这是因为没有调用loadDefaults方法(loadDefaults方法内部会把LogFile构造成FileAppender)，而是调用了loadConfiguration方法，该方法会根据logback.xml文件中的配置去构造Appender。</p>
<h3 id="resources下有my-logback-xml配置"><a href="#resources下有my-logback-xml配置" class="headerlink" title="resources下有my-logback.xml配置"></a>resources下有my-logback.xml配置</h3><p>由于LogbackLoggingSystem中没有对my-logback.xml路径的解析，所有不会被识别，但是可以在yaml中配置logging.config配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">logging:</span></div><div class="line"><span class="attr">  config:</span> classpath:my-logback.xml</div></pre></td></tr></table></figure>
<p>这样配置就能识别my-logback.xml文件。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>最新版的SpringBoot内部提供了一个NoOpLoggingSystem，这个日志系统内部什么都不做，构造过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggingSystem <span class="title">get</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</div><div class="line">	<span class="comment">// SYSTEM_PROPERTY静态变量是LoggingSystem的类全名</span></div><div class="line">	String loggingSystem = System.getProperty(SYSTEM_PROPERTY);</div><div class="line">	<span class="keyword">if</span> (StringUtils.hasLength(loggingSystem)) &#123;</div><div class="line">		<span class="keyword">if</span> (NONE.equals(loggingSystem)) &#123; <span class="comment">// None静态变量是值是none</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> NoOpLoggingSystem();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> get(classLoader, loggingSystem);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : SYSTEMS.entrySet()) &#123;</div><div class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(entry.getKey(), classLoader)) &#123;</div><div class="line">			<span class="keyword">return</span> get(classLoader, entry.getValue());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No suitable logging system located"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以程序启动的时候加上 -Dorg.springframework.boot.logging.LoggingSystem=none就可以构造NoOpLoggingSystem这个日志系统。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot对日志的配置和加载进行了封装，让我们可以很方便地使用一些日志框架，只需要定义对应日志框架的配置文件，比如LogBack、Log4j、Log4j2等，代码内部便可以直接使用。&lt;/p&gt;
&lt;p&gt;比如我们在resources目录下定义了一个logback.xml文件，文件内容是logback相关的配置，然后就可以直接在代码在使用Logger记录日志啦。&lt;/p&gt;
&lt;p&gt;下图是SpringBoot对日志功能的封装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wh6.com1.z0.glb.clouddn.com/logging-system.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC处理流程图</title>
    <link href="http://fangjian0423.github.io/2017/07/28/springmvc-process-write-by-processon/"/>
    <id>http://fangjian0423.github.io/2017/07/28/springmvc-process-write-by-processon/</id>
    <published>2017-07-28T13:12:47.000Z</published>
    <updated>2017-07-29T02:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现了一个不错的画图软件，叫做 <a href="https://www.processon.com/" target="_blank" rel="external">Processon</a> ， Web端工具，可直接上网使用。</p>
<p>不过免费版图片数量只有9张；收费版 159/年，图片数量不限。</p>
<p>体验还不错，于是画了张SpringMVC的总体处理流程图。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/SpringMVC-arch3.png" alt=""></p>
<p>以后每篇博客内容尽量也画图来说明，有了图片的话读者就不用面对枯燥的文字了，图文并茂，能大大提高阅读的效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现了一个不错的画图软件，叫做 &lt;a href=&quot;https://www.processon.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Processon&lt;/a&gt; ， Web端工具，可直接上网使用。&lt;/p&gt;
&lt;p&gt;不过免费版图片数量只有9
    
    </summary>
    
      <category term="springmvc" scheme="http://fangjian0423.github.io/categories/springmvc/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="springmvc" scheme="http://fangjian0423.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch集群知识笔记</title>
    <link href="http://fangjian0423.github.io/2017/07/24/es-cluster-notes/"/>
    <id>http://fangjian0423.github.io/2017/07/24/es-cluster-notes/</id>
    <published>2017-07-24T13:20:20.000Z</published>
    <updated>2017-07-25T03:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch内部提供了一个rest接口用于查看集群内部的健康状况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/_cluster/health</div></pre></td></tr></table></figure>
<p>response结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "cluster_name": "format-es",</div><div class="line">  "status": "green",</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的status有3种状态，分别是green(所有主分片和复制分片都可用)，yellow(所有主分片可用，但不是所有复制分片都可用)和red(不是所有主分片可用)。</p>
<a id="more"></a>
<h2 id="分片-Shard"><a href="#分片-Shard" class="headerlink" title="分片(Shard)"></a>分片(Shard)</h2><p>Elasticsearch中的索引(index)是由分片(shard)构成的。</p>
<p>比如我们集群中有个索引users，该索引由3个分片组成，那么这个users索引中的文档数据将分布在这3个分片中。</p>
<p>users索引中的文档是根据下面这个规则确定该文档属于哪个分片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard = hash(routing) % number_of_primary_shards <span class="comment">// routing值默认是文档的_id，number_of_primary_shards是索引的主分片个数</span></div></pre></td></tr></table></figure>
<p>这个routing默认是文档的_id，可以自定义(文章后面部分会举例说明)。</p>
<p>这3个分片可以进行复制，复制是为了实现容错性，比如复制1份，那么一共就需要6个分片(3个主分片+3个主分片复制出来的复制分片)。</p>
<p>users索引的创建命令(主分片3个，复制1份)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">curl -XPUT http://localhost:9200/users <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">	"settings": &#123;</div><div class="line">		"number_of_shards": 3,</div><div class="line">		"number_of_replicas": 1</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure>
<p>创建完users索引之后，es集群(单节点)分片情况如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-shards-one-node-2.png" alt=""></p>
<p>由于users索引有3个分片，es内部会创建出3个分片，分别是P0、P1和P2(大写P指的是primary)，且这3个分片都是主分片。users索引需要对分片进行复制1份，所以这3个主分片都需要复制1份，分别对应R0、R1和R2这3个复制分片(大写R指的是replica)。这个时候我们的集群只有1个节点node-1，所以复制分片并没有起作用(如果复制分片和主分片在同一个节点了，那么这个复制分片的意义就不存在了。复制分片的意义在于容错性，当一个节点挂了，另一个节点上的分片可以代替挂掉节点上的分片)。</p>
<p>查看健康状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/_cluster/health</div></pre></td></tr></table></figure>
<p>response结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"format-es"</span>,</div><div class="line">  <span class="attr">"status"</span>: <span class="string">"yellow"</span>,</div><div class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">"active_shards"</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">50</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以看到，集群的状态变成了yellow。这是因为users索引中的分片需要复制1份，但是没有足够的机器用来存储复制出来的复制分片，还有其它的一些字段比如unassigned_shards字段为3，对应R0、R1和R2这3个未分配的复制分片。</p>
<p>在集群中加入节点node-2，查看健康状况(这里使用伪集群。node-1节点对应9200端口的进程，node-2节点对应9201端口的进程)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/_cluster/health</div></pre></td></tr></table></figure>
<p>response结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"cluster_name"</span>: <span class="string">"format-es"</span>,</div><div class="line">  <span class="attr">"status"</span>: <span class="string">"green"</span>,</div><div class="line">  <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">"number_of_nodes"</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">"number_of_data_nodes"</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">"active_primary_shards"</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">"active_shards"</span>: <span class="number">6</span>,</div><div class="line">  <span class="attr">"relocating_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"initializing_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"unassigned_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"delayed_unassigned_shards"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"number_of_pending_tasks"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"number_of_in_flight_fetch"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"task_max_waiting_in_queue_millis"</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">"active_shards_percent_as_number"</span>: <span class="number">100</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主分片和复制分片均可用，status为green。</p>
<p>此时，es集群分片情况如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-shards-two-nodes.png" alt=""></p>
<p>这个时候es集群由2个节点node-1和node-2组成，并且这2个节点上具有主分片和复制分片，具有容错性。</p>
<p>我们往users索引中插入一条文档：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://localhost:9200/users/normal -d '</div><div class="line">&#123;</div><div class="line">  "name" : "Format",</div><div class="line">  "age" : 111</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"_index"</span>: <span class="string">"users"</span>,</div><div class="line">    <span class="attr">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="attr">"_id"</span>: <span class="string">"AV0hs4LnkXxVJ5DURwXr"</span>,</div><div class="line">    <span class="attr">"_version"</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">"_shards"</span>: &#123;</div><div class="line">        <span class="attr">"total"</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">"successful"</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"created"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从返回的信息中可以看到，这个文档已经被创建成功，并且2个分片都成功。id由es内部自动创建，值为AV0hs4LnkXxVJ5DURwXr。</p>
<p>读取id为AV0hs4LnkXxVJ5DURwXr的文档：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/users/normal/AV0hs4LnkXxVJ5DURwXr</div><div class="line"></div><div class="line"># 结果</div><div class="line">&#123;</div><div class="line">    "_index": "users",</div><div class="line">    "_type": "normal",</div><div class="line">    "_id": "AV0hs4LnkXxVJ5DURwXr",</div><div class="line">    "_version": 1,</div><div class="line">    "found": true,</div><div class="line">    "_source": &#123;</div><div class="line">        "name": "Format",</div><div class="line">        "age": 111</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候如果节点node-1挂了，读取数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9201/users/normal/AV0hs4LnkXxVJ5DURwXr</div><div class="line"></div><div class="line"># 结果</div><div class="line">&#123;</div><div class="line">    "_index": "users",</div><div class="line">    "_type": "normal",</div><div class="line">    "_id": "AV0hs4LnkXxVJ5DURwXr",</div><div class="line">    "_version": 1,</div><div class="line">    "found": true,</div><div class="line">    "_source": &#123;</div><div class="line">        "name": "Format",</div><div class="line">        "age": 111</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在节点node-1已经挂了的情况下还是读取到了之前插入的文档。这是因为我们users索引会复制2份，node-1节点虽然已经挂了，但是node-2节点上这个文档的数据还在，所以文档会被读取到。</p>
<p>在node-1节点挂掉的情况下，再次插入一条文档：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://localhost:9201/users/normal -d '</div><div class="line">&#123;</div><div class="line">  "name" : "Jim",</div><div class="line">  "age" : 66</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"_index"</span>: <span class="string">"users"</span>,</div><div class="line">    <span class="attr">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="attr">"_id"</span>: <span class="string">"AV0qMto5dJHprgu99sSN"</span>,</div><div class="line">    <span class="attr">"_version"</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">"_shards"</span>: &#123;</div><div class="line">        <span class="attr">"total"</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"created"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里看到返回的数据中，这个文档对应的分片只有1个成功插入，因为另1个分片对应的节点已经挂了。</p>
<p>然后读取这个新插入的文档：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9201/users/normal/AV0qMto5dJHprgu99sSN</div><div class="line"></div><div class="line"># 结果</div><div class="line">&#123;</div><div class="line">    "_index": "users",</div><div class="line">    "_type": "normal",</div><div class="line">    "_id": "AV0qMto5dJHprgu99sSN",</div><div class="line">    "_version": 1,</div><div class="line">    "found": true,</div><div class="line">    "_source": &#123;</div><div class="line">        "name": "Jim",</div><div class="line">        "age": 66</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后node-1节点恢复(节点恢复之后，es内部会自动从数据全的分片中复制数据到数据少的分片上，保证高可用)，然后读取数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/users/normal/AV0qMto5dJHprgu99sSN</div><div class="line"></div><div class="line"># 结果</div><div class="line">&#123;</div><div class="line">    "_index": "users",</div><div class="line">    "_type": "normal",</div><div class="line">    "_id": "AV0qMto5dJHprgu99sSN",</div><div class="line">    "_version": 1,</div><div class="line">    "found": true,</div><div class="line">    "_source": &#123;</div><div class="line">        "name": "Jim",</div><div class="line">        "age": 66</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES中文档的新建、删除和修改都是先在主分片上完成的，在主分片上完成这些操作以后，才会进行复制操作。比如有3个节点node-1、node-2和node-3，索引blogs有2个主分片，并且复制2份，集群结构如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-3-nodes.png" alt=""></p>
<p>当进行新建文档的时候过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-3-nodes-create-doc.png" alt=""></p>
<ol>
<li>客户端给master节点node-1发送新建文档的请求</li>
<li>node-1节点根据文档的_id，确定该文档属于属于分片1。分片1的主分片在节点node-2上，故将请求转发到node-2</li>
<li>node-2上的主分片P1处理文档成功，然后转发请求到node-1和node-3节点上的复制节点上。当所有的复制节点报告成功后，node-2节点报告成功到请求的节点，请求节点再返回给客户端</li>
</ol>
<p>当进行检索文档的时候过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-3-nodes-retrieve-doc.png" alt=""></p>
<ol>
<li>客户端给master节点node-1发送检索文档的请求</li>
<li>node-1节点根据文档的_id，确定该文档属于分片0。分片0在3个节点中都存在，本次请求中使用节点node-2，于是将请求转发给node-2节点</li>
<li>node-2节点得到文档数据，并返回给node-1节点，node-1节点返回给客户端</li>
</ol>
<p>这里es集群会使用轮询的策略对读取不同节点上的分片中的文档数据，比如针对上图中的查询，下次查询就会读取node-3节点上的R0分片中的文档。</p>
<p>当对文档进行局部更新的时候过程如下：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-3-nodes-partial-update-doc.png" alt=""></p>
<ol>
<li>客户端给master节点node-1发送局部更新文档的请求</li>
<li>node-1节点根据文档的_id，确定该文档属于分片1，并发现找到分片1的主分片在node-2节点上，转发请求到node-2节点上</li>
<li>node-2节点在主分片P1中找出对应id的文档，修改文档内部的_source属性，之后对文档重建索引。如果这个文档已经被其它进程修改，会重试步骤3 retry_on_conflict 次数(retry_on_conflict可通过参数设置)</li>
<li>如果步骤3执行成功，node-2节点转发新版本的文档给node-1和node-3节点上的复制分片，这2个节点对文档进行重建索引。一旦node-1和node-3节点上的复制分片处理成功，node-2节点返回成功给node-1节点，node-1节点返回给客户端</li>
</ol>
<h2 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点(Node)"></a>节点(Node)</h2><p>在分布式集群情况下，ES中的节点可分为4类：</p>
<ol>
<li>master节点：配置文件中node.master属性为true(默认为true)，就有资格被选为master节点，master节点用于控制整个集群的操作。比如创建或删除索引，管理其它非master节点等</li>
<li>data节点：配置文件中node.data属性为true(默认为true)，就有资格被设置成data节点，data节点主要用于执行数据相关的操作。比如文档的CRUD</li>
<li>客户端节点：配置文件中node.master属性和node.data属性均为false。该节点不能作为master节点，也不能作为data节点。可以作为客户端节点，用于响应用户的请求，把请求转发到其他节点</li>
<li>部落节点：当一个节点配置tribe.*的时候，它是一个特殊的客户端，它可以连接多个集群，在所有连接的集群上执行搜索和其他操作</li>
</ol>
<h2 id="查询集群状态的Rest接口"><a href="#查询集群状态的Rest接口" class="headerlink" title="查询集群状态的Rest接口"></a>查询集群状态的Rest接口</h2><p>可以通过es内部提供的rest接口查看master节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/_cat/master?v</div><div class="line"></div><div class="line">id                     host         ip           node   </div><div class="line">9FINsHCpTKqcpFlnnA4Yww 10.1.251.164 10.1.251.164 node-1</div></pre></td></tr></table></figure>
<p>查看节点信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/_cat/nodes?v</div><div class="line"></div><div class="line">host         ip           heap.percent ram.percent load node.role master name   </div><div class="line">10.1.251.164 10.1.251.164            6         100 5.48 d         *      node-1</div><div class="line">10.1.251.164 10.1.251.164            6         100 5.48 d         m      node-3</div><div class="line">10.1.251.164 10.1.251.164            7         100 5.48 d         m      node-2</div></pre></td></tr></table></figure>
<p>或者使用<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="external">head</a>插件查看节点情况。图中带有五角星的节点是master，这里users索引有3个主分片和3个复制分片(绿色框外部加粗的边框就是主分片，否则就是复制分片)：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-nodes-info.png" alt=""></p>
<p>如果我们的集群上node-1节点由于硬盘容量不足导致不可用时，head插件情况如下(3个复制节点未被分配，健康状况为黄色)：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/es-cluster-nodes-info-yellow.png" alt=""></p>
<p>也可使用es内部的rest接口查看分片信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">curl -XGET http://localhost:9200/_cat/shards?v</div><div class="line"></div><div class="line">index shard prirep state      docs store ip           node   </div><div class="line">users 1     p      STARTED       1 3.3kb 10.1.251.164 node-2</div><div class="line">users 1     r      UNASSIGNED                                </div><div class="line">users 2     p      STARTED       0  159b 10.1.251.164 node-2</div><div class="line">users 2     r      UNASSIGNED                                </div><div class="line">users 0     p      STARTED       2 6.6kb 10.1.251.164 node-3</div><div class="line">users 0     r      UNASSIGNED</div></pre></td></tr></table></figure>
<p>routing参数决定如何分片(可以在index、get、delete、update、bulk等方法中使用)，我们覆盖默认的routing为_id的默认策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 执行10次</span></div><div class="line">curl -XPOST http://localhost:9200/users/normal?routing=1 <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "Format345",</div><div class="line">  "age" : 456</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 执行1次</span></div><div class="line">curl -XPOST http://localhost:9200/users/normal <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "Format345",</div><div class="line">  "age" : 456</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 使用routing参数得到文档的结果(多了个_rouring属性)</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"users"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"AV07AubA6HDSJNRJle0i"</span>,</div><div class="line">    <span class="string">"_version"</span>: 1,</div><div class="line">    <span class="string">"_routing"</span>: <span class="string">"1"</span>,</div><div class="line">    <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"_source"</span>: &#123;</div><div class="line">        <span class="string">"name"</span>: <span class="string">"Format345"</span>,</div><div class="line">        <span class="string">"age"</span>: 456</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 查询文档分布情况(前面10次分布到了P2分片，后面1次分布到了P1分片)</span></div><div class="line">curl -XGET http://localhost:9200/_cat/shards?v</div><div class="line"></div><div class="line">index shard prirep state      docs store ip           node   </div><div class="line">users 1     p      STARTED       2 3.3kb 10.1.251.164 node-2</div><div class="line">users 1     r      UNASSIGNED                                </div><div class="line">users 2     p      STARTED       10  159b 10.1.251.164 node-2</div><div class="line">users 2     r      UNASSIGNED                                </div><div class="line">users 0     p      STARTED       2 6.6kb 10.1.251.164 node-3</div><div class="line">users 0     r      UNASSIGNED</div></pre></td></tr></table></figure>
<p>官网上有更多关于<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html" target="_blank" rel="external">_cat api</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html" target="_blank" rel="external">_cluster api</a>相关的文档。</p>
<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><p>es中文档的操作可以使用其内部提供的rest接口，使用过程中可以指定一些参数修改默认行为。</p>
<p>1.replication：用于设置复制分片的处理过程是同步还是异步。默认值是sync(主分片需要等待复制分片全部处理完毕)，也可以设置成async(主分片不需要等待复制分片的处理过程，但是还是会转发请求给复制分片，这个转发过程是异步的)。该参数在2.0.0版本后已经被废弃，因为异步转发给复制分片的话，不知道复制分片是否成功与否，而且复制分片在还没有处理完成的情况下由于一直过来的异步请求而导致es过载，不建议使用async</p>
<p>2.consistency：写文档的一致性参数，可以设置成one，quorum和all；分别表示主分片可用即可、过半分片可用[公式：int( (primary + number_of_replicas) / 2 ) + 1]以及全部分片可用。比如有个blogs索引，有3个主分片，并且复制2份，当集群中的1个节点挂了，并使用all的话，将会抛出异常：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://localhost:9200/blogs/normal?consistency=all <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "POST-1"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 一分钟后抛出异常</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"error"</span>: &#123;</div><div class="line">        <span class="string">"root_cause"</span>: [</div><div class="line">            &#123;</div><div class="line">                <span class="string">"type"</span>: <span class="string">"unavailable_shards_exception"</span>,</div><div class="line">                <span class="string">"reason"</span>: <span class="string">"[blogs][0] Not enough active copies to meet write consistency of [ALL] (have 2, needed 3). Timeout: [1m], request: [index &#123;[blogs][normal][AV1AF1FEl7qPpRBCQMV7], source[&#123;\n  \"name\" : \"POST-1\"\n&#125;]&#125;]"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="string">"type"</span>: <span class="string">"unavailable_shards_exception"</span>,</div><div class="line">        <span class="string">"reason"</span>: <span class="string">"[blogs][0] Not enough active copies to meet write consistency of [ALL] (have 2, needed 3). Timeout: [1m], request: [index &#123;[blogs][normal][AV1AF1FEl7qPpRBCQMV7], source[&#123;\n  \"name\" : \"POST-1\"\n&#125;]&#125;]"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"status"</span>: 503</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用默认的quorum策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://localhost:9200/blogs/normal <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "POST-1"</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 由于集群中的节点挂了1个，所分片只有2个success</div><div class="line">&#123;</div><div class="line">    "_index": "blogs",</div><div class="line">    "_type": "normal",</div><div class="line">    "_id": "AV1AckLfl7qPpRBCQMV_",</div><div class="line">    "_version": 1,</div><div class="line">    "_shards": &#123;</div><div class="line">        "total": 3,</div><div class="line">        "successful": 2,</div><div class="line">        "failed": 0</div><div class="line">    &#125;,</div><div class="line">    "created": true</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure>
<p><strong>consistency参数在5.0.0版本已经被弃用</strong></p>
<p>3.timeout：当分片不足的时候，es等待的时间(等待节点重新启动，分片恢复)，默认为1分钟，可以进行修改，改成10秒：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">curl -XPOST http://localhost:9200/blogs/normal?consistency=all&amp;timeout=10s <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "POST-1"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 10秒后抛出异常</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"error"</span>: &#123;</div><div class="line">        <span class="string">"root_cause"</span>: [</div><div class="line">            &#123;</div><div class="line">                <span class="string">"type"</span>: <span class="string">"unavailable_shards_exception"</span>,</div><div class="line">                <span class="string">"reason"</span>: <span class="string">"[blogs][1] Not enough active copies to meet write consistency of [ALL] (have 2, needed 3). Timeout: [10s], request: [index &#123;[blogs][normal][AV1AdXxsl7qPpRBCQMWB], source[&#123;\n  \"name\" : \"POST-1\"\n&#125;]&#125;]"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="string">"type"</span>: <span class="string">"unavailable_shards_exception"</span>,</div><div class="line">        <span class="string">"reason"</span>: <span class="string">"[blogs][1] Not enough active copies to meet write consistency of [ALL] (have 2, needed 3). Timeout: [10s], request: [index &#123;[blogs][normal][AV1AdXxsl7qPpRBCQMWB], source[&#123;\n  \"name\" : \"POST-1\"\n&#125;]&#125;]"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"status"</span>: 503</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.version</p>
<p>es中每个文档都有对应的版本信息，可以使用version版本参数用来实现并发情况下的乐观锁机制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 新建一个文档</span></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/format-001 <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "format-post-001"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 结果</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"format-001"</span>,</div><div class="line">    <span class="string">"_version"</span>: 1,</div><div class="line">    <span class="string">"_shards"</span>: &#123;</div><div class="line">        <span class="string">"total"</span>: 3,</div><div class="line">        <span class="string">"successful"</span>: 3,</div><div class="line">        <span class="string">"failed"</span>: 0</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"created"</span>: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># id为format-001的文档目前的version为1，进行更新</span></div><div class="line"></div><div class="line"><span class="comment"># 用version为2去更新</span></div><div class="line"></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/format-001?version=2 <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "format-post-001-001"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 报错，版本冲突</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"error"</span>: &#123;</div><div class="line">        <span class="string">"root_cause"</span>: [</div><div class="line">            &#123;</div><div class="line">                <span class="string">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</div><div class="line">                <span class="string">"reason"</span>: <span class="string">"[normal][format-001]: version conflict, current [1], provided [2]"</span>,</div><div class="line">                <span class="string">"shard"</span>: <span class="string">"0"</span>,</div><div class="line">                <span class="string">"index"</span>: <span class="string">"blogs"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="string">"type"</span>: <span class="string">"version_conflict_engine_exception"</span>,</div><div class="line">        <span class="string">"reason"</span>: <span class="string">"[normal][format-001]: version conflict, current [1], provided [2]"</span>,</div><div class="line">        <span class="string">"shard"</span>: <span class="string">"0"</span>,</div><div class="line">        <span class="string">"index"</span>: <span class="string">"blogs"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"status"</span>: 409</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 用version为1去更新</span></div><div class="line"></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/format-001?version=1 <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "format-post-001-001"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 更新成功，文档版本变成2</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"format-001"</span>,</div><div class="line">    <span class="string">"_version"</span>: 2,</div><div class="line">    <span class="string">"_shards"</span>: &#123;</div><div class="line">        <span class="string">"total"</span>: 3,</div><div class="line">        <span class="string">"successful"</span>: 3,</div><div class="line">        <span class="string">"failed"</span>: 0</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"created"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.op_type：可以指定本次操作的类型，比如create操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个id为1，type为normal，在blogs索引中的文档</span></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/1?op_type=create <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "POST-2"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"1"</span>,</div><div class="line">    <span class="string">"_version"</span>: 1,</div><div class="line">    <span class="string">"_shards"</span>: &#123;</div><div class="line">        <span class="string">"total"</span>: 3,</div><div class="line">        <span class="string">"successful"</span>: 3,</div><div class="line">        <span class="string">"failed"</span>: 0</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"created"</span>: <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 继续调用同一个操作</span></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/1?op_type=create <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "POST-2"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 报错，文档已经存在</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"error"</span>: &#123;</div><div class="line">        <span class="string">"root_cause"</span>: [</div><div class="line">            &#123;</div><div class="line">                <span class="string">"type"</span>: <span class="string">"document_already_exists_exception"</span>,</div><div class="line">                <span class="string">"reason"</span>: <span class="string">"[normal][1]: document already exists"</span>,</div><div class="line">                <span class="string">"shard"</span>: <span class="string">"0"</span>,</div><div class="line">                <span class="string">"index"</span>: <span class="string">"blogs"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="string">"type"</span>: <span class="string">"document_already_exists_exception"</span>,</div><div class="line">        <span class="string">"reason"</span>: <span class="string">"[normal][1]: document already exists"</span>,</div><div class="line">        <span class="string">"shard"</span>: <span class="string">"0"</span>,</div><div class="line">        <span class="string">"index"</span>: <span class="string">"blogs"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"status"</span>: 409</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以不使用op_type操作，在url中指定。这两种方法效果是一样的</p>
<p><a href="http://localhost:9200/blogs/normal/1/_create" target="_blank" rel="external">http://localhost:9200/blogs/normal/1/_create</a> 效果跟 <a href="http://localhost:9200/blogs/normal/1?op_type=create" target="_blank" rel="external">http://localhost:9200/blogs/normal/1?op_type=create</a> 是一样的。</p>
<p>目前支持的op_type有create(只支持创建文档)和index(支持创建和更新文档)。</p>
<p>6.wait_for_active_shards</p>
<p>在5.0.0版本新引入的一个参数，表示等待活跃的分片数。作用跟consistency类似，可以设置成all或者任意正整数。</p>
<p>比如在这种场景下：集群中有3个节点node-1、node-2和node-3，并且索引中的分片需要复制3份。那么该索引一共拥有4个分片，包括1个主分片和3个复制分片。</p>
<p>默认情况下，索引操作只需要等待主分片可用(wait_for_active_shards为1)即可。</p>
<p>如果node-2和node-3节点挂了，索引操作是不会受影响的(wait_for_active_shards默认为1)；如果设置了wait_for_active_shards为3，那么需要3个节点全部存活；如果设置了wait_for_active_shards为4或者all(一共4个分片，4和all是一样的效果)，那么该集群中的索引操作永远都会失败，因为集群一共就3个节点，不能处理所有的4个分片。</p>
<p>比如设置成all，则会抛出如下错误：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"error"</span>: &#123;</div><div class="line">        <span class="attr">"root_cause"</span>: [</div><div class="line">            &#123;</div><div class="line">                <span class="attr">"type"</span>: <span class="string">"unavailable_shards_exception"</span>,</div><div class="line">                <span class="attr">"reason"</span>: <span class="string">"[blogs][2] Not enough active copies to meet shard count of [ALL] (have 3, needed 4). Timeout: [1m], request: [index &#123;[blogs][normal][AV1QVDz3RpA5iuXn159C], source[&#123;\n  \"name\" : \"POST-1\"\n&#125;]&#125;]"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="attr">"type"</span>: <span class="string">"unavailable_shards_exception"</span>,</div><div class="line">        <span class="attr">"reason"</span>: <span class="string">"[blogs][2] Not enough active copies to meet shard count of [ALL] (have 3, needed 4). Timeout: [1m], request: [index &#123;[blogs][normal][AV1QVDz3RpA5iuXn159C], source[&#123;\n  \"name\" : \"POST-1\"\n&#125;]&#125;]"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"status"</span>: <span class="number">503</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>wait_for_active_shards的默认值可以在定义索引的时候进行设置，也可以动态地进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -XPUT http://localhost:9200/blogs/_settings <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">	"index.write.wait_for_active_shards": 3</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure>
<p>7.自动生成id</p>
<p>创建文档的时候，可以不指定id，es会自动为你生成1个id，需要注意的话需要使用POST方式，而不是PUT方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">curl -XPOST http://localhost:9200/blogs/normal <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "name" : "my-post"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"AV1Pj6MdAuPf3r3i0ysL"</span>, <span class="comment"># 自动生成的id</span></div><div class="line">    <span class="string">"_version"</span>: 1,</div><div class="line">    <span class="string">"_shards"</span>: &#123;</div><div class="line">        <span class="string">"total"</span>: 3,</div><div class="line">        <span class="string">"successful"</span>: 3,</div><div class="line">        <span class="string">"failed"</span>: 0</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"created"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>8.文档的局部更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新建文档</span></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/format-doc-001 <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "title" : "springboot in action",</div><div class="line">  "author" : "Format"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 执行全更新操作</span></div><div class="line">curl -XPUT http://localhost:9200/blogs/normal/format-doc-001 <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "create_at": "2017-07-18"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 获取文档</span></div><div class="line">curl -XGET http://localhost:9200/blogs/normal/format-doc-001</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"format-doc-001"</span>,</div><div class="line">    <span class="string">"_version"</span>: 2,</div><div class="line">    <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"_source"</span>: &#123;</div><div class="line">        <span class="string">"create_at"</span>: <span class="string">"2017-07-18"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 使用文档局部更新</span></div><div class="line"></div><div class="line">curl -XPOST http://localhost:9200/blogs/normal/format-doc-001/_update <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "doc": &#123;</div><div class="line">  	"title" : "springboot in action",</div><div class="line">	  "author" : "Format"</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 获取文档</span></div><div class="line">curl -XGET http://localhost:9200/blogs/normal/format-doc-001</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"format-doc-001"</span>,</div><div class="line">    <span class="string">"_version"</span>: 3,</div><div class="line">    <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"_source"</span>: &#123;</div><div class="line">        <span class="string">"create_at"</span>: <span class="string">"2017-07-18"</span>,</div><div class="line">        <span class="string">"author"</span>: <span class="string">"Format"</span>,</div><div class="line">        <span class="string">"title"</span>: <span class="string">"springboot in action"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 使用脚本局部更新</span></div><div class="line">curl -XPOST http://localhost:9200/blogs/normal/format-doc-001/_update <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "script" : "ctx._source.views = 0; ctx._source.tags = [new_tag]",</div><div class="line">  "params": &#123;</div><div class="line">  	"new_tag": "java"</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 获取文档</span></div><div class="line">curl -XGET http://localhost:9200/blogs/normal/format-doc-001</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"format-doc-001"</span>,</div><div class="line">    <span class="string">"_version"</span>: 3,</div><div class="line">    <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"_source"</span>: &#123;</div><div class="line">        <span class="string">"create_at"</span>: <span class="string">"2017-07-18"</span>,</div><div class="line">        <span class="string">"author"</span>: <span class="string">"Format"</span>,</div><div class="line">        <span class="string">"title"</span>: <span class="string">"springboot in action"</span>,</div><div class="line">        <span class="string">"tags"</span>: [</div><div class="line">            <span class="string">"java"</span></div><div class="line">        ],</div><div class="line">        <span class="string">"views"</span>: 0</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 使用脚本局部更新新创建的文档</span></div><div class="line">curl -XPOST http://localhost:9200/blogs/normal/format-doc-002/_update <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "script" : "ctx._source.views+=1"</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 报错，因为id为format-doc-002的文档不存在</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"error"</span>: &#123;</div><div class="line">        <span class="string">"root_cause"</span>: [</div><div class="line">            &#123;</div><div class="line">                <span class="string">"type"</span>: <span class="string">"document_missing_exception"</span>,</div><div class="line">                <span class="string">"reason"</span>: <span class="string">"[normal][format-doc-002]: document missing"</span>,</div><div class="line">                <span class="string">"shard"</span>: <span class="string">"0"</span>,</div><div class="line">                <span class="string">"index"</span>: <span class="string">"blogs"</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        <span class="string">"type"</span>: <span class="string">"document_missing_exception"</span>,</div><div class="line">        <span class="string">"reason"</span>: <span class="string">"[normal][format-doc-002]: document missing"</span>,</div><div class="line">        <span class="string">"shard"</span>: <span class="string">"0"</span>,</div><div class="line">        <span class="string">"index"</span>: <span class="string">"blogs"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"status"</span>: 404</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 加上upsert参数(设置字段的初始值)</span></div><div class="line"></div><div class="line">curl -XPOST http://localhost:9200/blogs/normal/format-doc-002/_update <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">  "script" : "ctx._source.views+=1",</div><div class="line">  "upsert": &#123;</div><div class="line">       "views": 1</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 获取文档</span></div><div class="line">curl -XGET http://localhost:9200/blogs/normal/format-doc-002</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">    <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">    <span class="string">"_id"</span>: <span class="string">"format-doc-002"</span>,</div><div class="line">    <span class="string">"_version"</span>: 1,</div><div class="line">    <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="string">"_source"</span>: &#123;</div><div class="line">        <span class="string">"views"</span>: 1</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>9.检索多个文档(Multi Get API)</p>
<p>可以在一个请求中获得多个文档数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在所有索引中执行mget，在参数中指定索引</span></div><div class="line">curl -XGET http://localhost:9200/_mget <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "docs" : [</div><div class="line">        &#123;</div><div class="line">            "_index" : "blogs",</div><div class="line">            "_type" : "normal",</div><div class="line">            "_id" : "format-doc-001"</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            "_index" : "blogs",</div><div class="line">            "_type" : "normal",</div><div class="line">            "_id" : "format-doc-002"</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 结果</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"docs"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">            <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">            <span class="string">"_id"</span>: <span class="string">"format-doc-001"</span>,</div><div class="line">            <span class="string">"_version"</span>: 3,</div><div class="line">            <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">"_source"</span>: &#123;</div><div class="line">                <span class="string">"create_at"</span>: <span class="string">"2017-07-18"</span>,</div><div class="line">                <span class="string">"author"</span>: <span class="string">"Format"</span>,</div><div class="line">                <span class="string">"title"</span>: <span class="string">"springboot in action"</span>,</div><div class="line">                <span class="string">"tags"</span>: [</div><div class="line">                    <span class="string">"java"</span></div><div class="line">                ],</div><div class="line">                <span class="string">"views"</span>: 0</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">            <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">            <span class="string">"_id"</span>: <span class="string">"format-doc-002"</span>,</div><div class="line">            <span class="string">"_version"</span>: 1,</div><div class="line">            <span class="string">"found"</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">"_source"</span>: &#123;</div><div class="line">                <span class="string">"views"</span>: 1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 基于特定的索引做mget</span></div><div class="line">curl -XGET http://localhost:9200/blogs/_mget <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "docs" : [</div><div class="line">        &#123;</div><div class="line">            "_type" : "normal",</div><div class="line">            "_id" : "format-doc-001"</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            "_type" : "normal",</div><div class="line">            "_id" : "format-doc-002"</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 基于特定的索引和类型做mget</span></div><div class="line">curl -XGET http://localhost:9200/blogs/normal/_mget <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "docs" : [</div><div class="line">        &#123;</div><div class="line">            "_id" : "format-doc-001"</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            "_id" : "format-doc-002"</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 简化版的基于特定的索引和类型做mget</span></div><div class="line">curl -XGET http://localhost:9200/blogs/normal/_mget <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "ids": ["format-doc-001", "format-doc-002"]</div><div class="line">&#125;</div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 过滤source中的属性</span></div><div class="line">curl -XGET http://localhost:9200/_mget <span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    "docs" : [</div><div class="line">        &#123;</div><div class="line">        	"_index": "blogs",</div><div class="line">        	"_type": "normal",</div><div class="line">            "_id" : "format-doc-001",</div><div class="line">            "_source": ["title", "author"]</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">        	"_index": "blogs",</div><div class="line">        	"_type": "normal",</div><div class="line">            "_id" : "format-doc-002",</div><div class="line">            "_source": false</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">        	"_index": "blogs",</div><div class="line">        	"_type": "normal",</div><div class="line">            "_id" : "format-doc-003",</div><div class="line">            "_source": &#123;</div><div class="line">            	"include": ["title"],</div><div class="line">            	"exclude": ["author"]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">'</div></pre></td></tr></table></figure>
<p>10.批量操作(bulk)</p>
<p>批量操作可以实现同一个请求操作多个文档的过程。需要注意的是bulk操作Http Body中的格式，对文档进行处理的话需要使用换行。比如创建新文档，更新文档都需要使用换行把创建目录和文档数据进行分割。不同的操作也需要用换行进行分割，比如创建文档和删除文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 3个批量操作，分别是创建文档，更新文档以及删除文档</span></div><div class="line"><span class="comment"># 创建文档的时候需要使用换行分割开创建目录和文档数据</span></div><div class="line"><span class="comment"># 更新文档的时候也需要使用换行分割开创建目录和文档数据</span></div><div class="line"><span class="comment"># 最后一个操作需要使用换行结束</span></div><div class="line">curl -XPOST http://localhost:9200/_bulk -<span class="_">-d</span> <span class="string">'</span></div><div class="line">&#123; "create": &#123; "_index": "blogs", "_type": "normal", "_id": "format-bulk-doc-001" &#125; &#125;</div><div class="line">&#123; "title": "Hadoop in action", "author": "Chuck Lam" &#125;</div><div class="line">&#123; "update": &#123; "_index": "blogs", "_type": "normal", "_id": "format-bulk-doc-001" &#125; &#125;</div><div class="line">&#123; "doc": &#123; "create_at": "2017-07-19" &#125; &#125;</div><div class="line">&#123; "delete": &#123; "_index": "blogs", "_type": "normal", "_id": "format-doc-002" &#125; &#125;</div><div class="line"></div><div class="line">'</div><div class="line"></div><div class="line"><span class="comment"># 结果</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"took"</span>: 695,</div><div class="line">    <span class="string">"errors"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="string">"items"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"create"</span>: &#123;</div><div class="line">                <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">                <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">                <span class="string">"_id"</span>: <span class="string">"format-bulk-doc-001"</span>,</div><div class="line">                <span class="string">"_version"</span>: 1,</div><div class="line">                <span class="string">"_shards"</span>: &#123;</div><div class="line">                    <span class="string">"total"</span>: 3,</div><div class="line">                    <span class="string">"successful"</span>: 3,</div><div class="line">                    <span class="string">"failed"</span>: 0</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"status"</span>: 201</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"update"</span>: &#123;</div><div class="line">                <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">                <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">                <span class="string">"_id"</span>: <span class="string">"format-bulk-doc-001"</span>,</div><div class="line">                <span class="string">"_version"</span>: 2,</div><div class="line">                <span class="string">"_shards"</span>: &#123;</div><div class="line">                    <span class="string">"total"</span>: 3,</div><div class="line">                    <span class="string">"successful"</span>: 3,</div><div class="line">                    <span class="string">"failed"</span>: 0</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"status"</span>: 200</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"delete"</span>: &#123;</div><div class="line">                <span class="string">"_index"</span>: <span class="string">"blogs"</span>,</div><div class="line">                <span class="string">"_type"</span>: <span class="string">"normal"</span>,</div><div class="line">                <span class="string">"_id"</span>: <span class="string">"format-doc-002"</span>,</div><div class="line">                <span class="string">"_version"</span>: 2,</div><div class="line">                <span class="string">"_shards"</span>: &#123;</div><div class="line">                    <span class="string">"total"</span>: 3,</div><div class="line">                    <span class="string">"successful"</span>: 3,</div><div class="line">                    <span class="string">"failed"</span>: 0</div><div class="line">                &#125;,</div><div class="line">                <span class="string">"status"</span>: 200,</div><div class="line">                <span class="string">"found"</span>: <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elasticsearch内部提供了一个rest接口用于查看集群内部的健康状况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;curl -XGET http://localhost:9200/_cluster/health&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;response结果：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &quot;cluster_name&quot;: &quot;format-es&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &quot;status&quot;: &quot;green&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里的status有3种状态，分别是green(所有主分片和复制分片都可用)，yellow(所有主分片可用，但不是所有复制分片都可用)和red(不是所有主分片可用)。&lt;/p&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://fangjian0423.github.io/categories/elasticsearch/"/>
    
    
      <category term="big data" scheme="http://fangjian0423.github.io/tags/big-data/"/>
    
      <category term="elasticsearch" scheme="http://fangjian0423.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引知识总结</title>
    <link href="http://fangjian0423.github.io/2017/07/05/mysql-index-summary/"/>
    <id>http://fangjian0423.github.io/2017/07/05/mysql-index-summary/</id>
    <published>2017-07-05T11:30:30.000Z</published>
    <updated>2017-07-04T03:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>对MySQL索引知识的总结笔记。</p>
<a id="more"></a>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>索引是一种数据结构，主要用于性能的提高。</p>
<p>比如我们有一个表t_users，有4个字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_users (</div><div class="line">	<span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</div><div class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">	age <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">	<span class="keyword">num</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">	primary <span class="keyword">key</span> (<span class="keyword">id</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div></pre></td></tr></table></figure>
<p>往这个表中插入100w条数据，name字段是format-1到100w，age字段也是1-100w，num字段是个随机的10以内的数字。然后执行sql语句进行查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_users where name = 'format-500000';</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">| id     | name          | age    | num |</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">| 500000 | format-500000 | 500000 |  38 |</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">1 row in set (0.47 sec)</div></pre></td></tr></table></figure>
<p>explain一下这条语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name = 'format-500000';</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | NULL          | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>发现查询了996677条数据，进行了全表的扫描。</p>
<p>我们给name字段加上索引：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create index IDX_FOR_NAME on t_users(name);</div></pre></td></tr></table></figure>
<p>再次执行sql语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_users where name = 'format-500000';</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">| id     | name          | age    | num |</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">| 500000 | format-500000 | 500000 |  38 |</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>explain一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name = 'format-500000';</div><div class="line">+----+-------------+---------+------+---------------+--------------+---------+-------+------+-----------------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key          | key_len | ref   | rows | Extra                 |</div><div class="line">+----+-------------+---------+------+---------------+--------------+---------+-------+------+-----------------------+</div><div class="line">|  1 | SIMPLE      | t_users | ref  | IDX_FOR_NAME  | IDX_FOR_NAME | 767     | const |    1 | Using index condition |</div><div class="line">+----+-------------+---------+------+---------------+--------------+---------+-------+------+-----------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>只查询了1条数据，因为我们加了btree索引，可以快速定位到具体的值。</p>
<p>接下来我们查询num字段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_users where num = 66;</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">....</div><div class="line">| 965109 | format-965109 | 965109 |  66 |</div><div class="line">| 965172 | format-965172 | 965172 |  66 |</div><div class="line">| 965182 | format-965182 | 965182 |  66 |</div><div class="line">| 965213 | format-965213 | 965213 |  66 |</div><div class="line">....</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">10029 rows in set (0.30 sec)</div></pre></td></tr></table></figure>
<p>由于num字段也是没有加索引的，查询的时候也进行全表的扫描，查询耗时。接下来我们给num字段加上索引。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create index IDX_FOR_NUM on t_users(num);</div></pre></td></tr></table></figure>
<p>然后进行查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_users where num = 5;</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">....</div><div class="line">| 965109 | format-965109 | 965109 |  5 |</div><div class="line">| 965172 | format-965172 | 965172 |  5 |</div><div class="line">| 965182 | format-965182 | 965182 |  5 |</div><div class="line">| 965213 | format-965213 | 965213 |  5 |</div><div class="line">....</div><div class="line">+--------+---------------+--------+-----+</div><div class="line">10029 rows in set (0.04 sec)</div></pre></td></tr></table></figure>
<p>explain一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where num = 5;</div><div class="line">+----+-------------+---------+------+---------------+-------------+---------+-------+-------+-------+</div><div class="line">| id | select_type | table   | type | possible_keys | key         | key_len | ref   | rows  | Extra |</div><div class="line">+----+-------------+---------+------+---------------+-------------+---------+-------+-------+-------+</div><div class="line">|  1 | SIMPLE      | t_users | ref  | IDX_FOR_NUM   | IDX_FOR_NUM | 8       | const | 206712 | NULL  |</div><div class="line">+----+-------------+---------+------+---------------+-------------+---------+-------+-------+-------+</div></pre></td></tr></table></figure>
<p>虽然我们在num字段上加了索引，但是由于num值在这100w条数据中有很多重复的数据，这个时候索引对查询速度的提高就没有那么明显了。</p>
<p>因为不论是hash类型的索引还是btree类型的索引，他们对于重复的数据的查询并没有提高多少。相反，由于添加了索引，导致数据写入性能变差，而查询性能又没有增强多少。所以说不能盲目地添加索引。</p>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>复合索引也叫联合索引，表示索引建立在多个列上。</p>
<p>我们删除t_users上的索引，然后创建一个复合索引。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql&gt; drop index IDX_FOR_NUM on t_users;</div><div class="line">mysql&gt; drop index IDX_FOR_NAME on t_users;</div><div class="line"></div><div class="line">mysql&gt; create index INDEX_FOR_NAME_AGE on t_users(name, age);</div></pre></td></tr></table></figure>
<p>复合索引支持最左原则，也就是说INDEX_FOR_NAME_AGE索引支持name字段的查找，支持name，age字段的查找，但是不支持age，name字段的查找以及age字段的查找。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name = 'format-100000';</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+</div><div class="line">| id | select_type | table   | type | possible_keys      | key                | key_len | ref   | rows | Extra                 |</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+</div><div class="line">|  1 | SIMPLE      | t_users | ref  | INDEX_FOR_NAME_AGE | INDEX_FOR_NAME_AGE | 767     | const |    1 | Using index condition |</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+</div><div class="line"></div><div class="line">mysql&gt; explain select * from t_users where name = 'format-100000' and age = 100000;</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------------+------+-----------------------+</div><div class="line">| id | select_type | table   | type | possible_keys      | key                | key_len | ref         | rows | Extra                 |</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------------+------+-----------------------+</div><div class="line">|  1 | SIMPLE      | t_users | ref  | INDEX_FOR_NAME_AGE | INDEX_FOR_NAME_AGE | 775     | const,const |    1 | Using index condition |</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------------+------+-----------------------+</div><div class="line"></div><div class="line">mysql&gt; explain select * from t_users where age = 100000;</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | NULL          | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>使用age，name字段查找：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where age = 100000 and name = 'format-100000';</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------------+------+-----------------------+</div><div class="line">| id | select_type | table   | type | possible_keys      | key                | key_len | ref         | rows | Extra                 |</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------------+------+-----------------------+</div><div class="line">|  1 | SIMPLE      | t_users | ref  | INDEX_FOR_NAME_AGE | INDEX_FOR_NAME_AGE | 775     | const,const |    1 | Using index condition |</div><div class="line">+----+-------------+---------+------+--------------------+--------------------+---------+-------------+------+-----------------------+</div></pre></td></tr></table></figure>
<p>我们发现使用age，name字段的查找使用了复合索引，这是因为MySQL内部有个查询优化器帮我们进行了优化。</p>
<h2 id="索引的生效"><a href="#索引的生效" class="headerlink" title="索引的生效"></a>索引的生效</h2><p>索引创建之后，查询的过程并不一定会使用索引。整理如下(t_users表中name和num字段都有单独的索引)：</p>
<p>1.当使用索引查询比全表扫描更慢。比如下面这句sql中num字段的值分布在1-10之间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where num &gt; 1 and num &lt; 8;</div><div class="line">+----+-------------+----------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table    | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+----------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users  | ALL  | IDX_ON_NUM    | NULL | NULL    | NULL | 996504 | Using where |</div><div class="line">+----+-------------+----------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>2.使用or进行查询，并且or左右两边的列有不存在索引的列</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name = 'format-4000' or age = 50;</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | IDX_FOR_NAME  | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>or两边的列都有索引：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name = 'format-4000' or num = 50;</div><div class="line">+----+-------------+----------+-------------+---------------------------------+---------------------------------+---------+------+------+-----------------------------------------------------------+</div><div class="line">| id | select_type | table    | type        | possible_keys                   | key                             | key_len | ref  | rows | Extra                                                     |</div><div class="line">+----+-------------+----------+-------------+---------------------------------+---------------------------------+---------+------+------+-----------------------------------------------------------+</div><div class="line">|  1 | SIMPLE      | t_users  | index_merge | IDX_ON_NUM,IDX_FOR_NAME         | IDX_FOR_NAME,IDX_ON_NUM         | 767,8   | NULL |    2 | Using union(IDX_FOR_NAME,IDX_ON_NUM); Using where         |</div><div class="line">+----+-------------+----------+-------------+---------------------------------+---------------------------------+---------+------+------+-----------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>3.使用like，并以 % 开头</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name like "%format-200";</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | NULL          | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line"></div><div class="line">mysql&gt; explain select * from t_users where name like "%format-200%";</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | NULL          | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>以 % 结尾的查询会使用索引：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name like "format-200%";</div><div class="line">+----+-------------+---------+-------+---------------+--------------+---------+------+------+-----------------------+</div><div class="line">| id | select_type | table   | type  | possible_keys | key          | key_len | ref  | rows | Extra                 |</div><div class="line">+----+-------------+---------+-------+---------------+--------------+---------+------+------+-----------------------+</div><div class="line">|  1 | SIMPLE      | t_users | range | IDX_FOR_NAME  | IDX_FOR_NAME | 767     | NULL | 1110 | Using index condition |</div><div class="line">+----+-------------+---------+-------+---------------+--------------+---------+------+------+-----------------------+</div></pre></td></tr></table></figure>
<p>4.复合索引</p>
<p>不是复合索引的最左字段(t_users表有(name,age)复合索引)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where age = 100000;</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | NULL          | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>5.对varchar类型的字段进行查询的时候，没有加上引号</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from t_users where name = 111;</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | t_users | ALL  | IDX_FOR_NAME  | NULL | NULL    | NULL | 996677 | Using where |</div><div class="line">+----+-------------+---------+------+---------------+------+---------+------+--------+-------------+</div><div class="line"></div><div class="line">mysql&gt; explain select * from t_users where name = "111";</div><div class="line">+----+-------------+---------+------+---------------+--------------+---------+-------+------+-----------------------+</div><div class="line">| id | select_type | table   | type | possible_keys | key          | key_len | ref   | rows | Extra                 |</div><div class="line">+----+-------------+---------+------+---------------+--------------+---------+-------+------+-----------------------+</div><div class="line">|  1 | SIMPLE      | t_users | ref  | IDX_FOR_NAME  | IDX_FOR_NAME | 767     | const |    1 | Using index condition |</div><div class="line">+----+-------------+---------+------+---------------+--------------+---------+-------+------+-----------------------+</div></pre></td></tr></table></figure>
<h2 id="hash索引和btree索引的区别"><a href="#hash索引和btree索引的区别" class="headerlink" title="hash索引和btree索引的区别"></a>hash索引和btree索引的区别</h2><ol>
<li>hash索引不能使用范围查询，只能使用一些比如 “=”, “&lt;&gt;”, “in”查询。因为hash索引会计算索引列的hash值，计算出后的hash值经过了hash算法与原先的值完全不一样，只能进行等值的过滤，不能基于范围的过滤</li>
<li>hash索引遇到大量hash值相同的情况下，性能比btree要差</li>
<li>hash索引并不一定一次可以定位到数据。因为基于索引列计算出的hash值会有重复，重复的话需要扫描hash表进行比较</li>
<li>由于hash索引中存放的是经过hash计算之后的hash值，而且hash值的大小关系并不一定和hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算</li>
<li>对于组合索引，hash索引在计算hash值的时候是组合索引键合并后再一起计算hash值，而不是单独计算hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，hash索引也无法被利用</li>
<li>InnoDB和MyISAM引擎不支持hash索引</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对MySQL索引知识的总结笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://fangjian0423.github.io/categories/mysql/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="mysql" scheme="http://fangjian0423.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用程序的关闭</title>
    <link href="http://fangjian0423.github.io/2017/06/28/springboot-application-exit/"/>
    <id>http://fangjian0423.github.io/2017/06/28/springboot-application-exit/</id>
    <published>2017-06-28T01:15:30.000Z</published>
    <updated>2017-06-28T02:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot应用程序的关闭目前总结起来有4种方式：</p>
<ol>
<li>Rest接口：使用spring-boot-starter-actuator模块里的ShutdownEndpoint</li>
<li>SpringApplication的exit静态方法：直接调用该静态方法即可</li>
<li>JMX：使用SpringBoot内部提供的MXBean</li>
<li>使用第三方进程管理工具</li>
</ol>
<a id="more"></a>
<h2 id="Rest接口"><a href="#Rest接口" class="headerlink" title="Rest接口"></a>Rest接口</h2><p>Rest接口使用Endpoint暴露出来，需要引入<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints" target="_blank" rel="external">spring-boot-starter-actuator</a>这个stater。</p>
<p>这个关闭应用程序对应的Endpoint是ShutdownEndpoint，直接调用ShutdownEndpoint提供的rest接口即可。得先开启ShutdownEndpoint(默认不开启)，以及不进行安全监测：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">endpoints<span class="selector-class">.shutdown</span><span class="selector-class">.enabled</span>: true</div><div class="line">endpoints<span class="selector-class">.shutdown</span><span class="selector-class">.sensitive</span>: false</div></pre></td></tr></table></figure>
<p>然后调用rest接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X POST http://localhost:8080/shutdown</div></pre></td></tr></table></figure>
<p>可以使用spring-security进行安全监测：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">endpoints<span class="selector-class">.shutdown</span><span class="selector-class">.sensitive</span>: true</div><div class="line">security<span class="selector-class">.user</span><span class="selector-class">.name</span>: admin</div><div class="line">security<span class="selector-class">.user</span><span class="selector-class">.password</span>: admin</div><div class="line">management<span class="selector-class">.security</span><span class="selector-class">.role</span>: SUPERUSER</div></pre></td></tr></table></figure>
<p>然后使用用户名和密码进行调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -u admin:admin -X POST http://127.0.0.1:8080/shutdown</div></pre></td></tr></table></figure>
<p>这个ShutdownEndpoint底层其实就是调用了Spring容器的close方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">invoke</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> Collections.&lt;String, Object&gt;singletonMap(<span class="string">"message"</span>,</div><div class="line">				<span class="string">"No context to shutdown."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">return</span> Collections.&lt;String, Object&gt;singletonMap(<span class="string">"message"</span>,</div><div class="line">				<span class="string">"Shutting down, bye..."</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">500L</span>);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">					<span class="comment">// Swallow exception and continue</span></div><div class="line">				&#125;</div><div class="line">				ShutdownEndpoint.<span class="keyword">this</span>.context.close();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="SpringApplication的exit静态方法"><a href="#SpringApplication的exit静态方法" class="headerlink" title="SpringApplication的exit静态方法"></a>SpringApplication的exit静态方法</h2><p>SpringApplication提供了一个exit静态方法，用于关闭Spring容器，该方法还有一个参数exitCodeGenerators表示ExitCodeGenerator接口的数组。ExitCodeGenerator接口是一个生成退出码exitCode的生成器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exit</span><span class="params">(ApplicationContext context,</span></span></div><div class="line">		ExitCodeGenerator... exitCodeGenerators) &#123;</div><div class="line">	Assert.notNull(context, <span class="string">"Context must not be null"</span>);</div><div class="line">	<span class="keyword">int</span> exitCode = <span class="number">0</span>; <span class="comment">// 默认的退出码是0</span></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 构造ExitCodeGenerator集合</span></div><div class="line">			ExitCodeGenerators generators = <span class="keyword">new</span> ExitCodeGenerators();</div><div class="line">			<span class="comment">// 获得Spring容器中所有的ExitCodeGenerator类型的bean</span></div><div class="line">			Collection&lt;ExitCodeGenerator&gt; beans = context</div><div class="line">					.getBeansOfType(ExitCodeGenerator.class).values();</div><div class="line">			<span class="comment">// 集合加上参数中的ExitCodeGenerator数组</span></div><div class="line">			generators.addAll(exitCodeGenerators);</div><div class="line">			<span class="comment">// 集合加上Spring容器中的ExitCodeGenerator集合</span></div><div class="line">			generators.addAll(beans);</div><div class="line">			<span class="comment">// 遍历每个ExitCodeGenerator，得到最终的退出码exitCode</span></div><div class="line">			<span class="comment">// 这里每个ExitCodeGenerator生成的退出码如果比0大，那么取最大的</span></div><div class="line">			<span class="comment">// 如果比0小，那么取最小的</span></div><div class="line">			exitCode = generators.getExitCode();</div><div class="line">			<span class="keyword">if</span> (exitCode != <span class="number">0</span>) &#123; <span class="comment">// 如果退出码exitCode不为0，发布ExitCodeEvent事件</span></div><div class="line">				context.publishEvent(<span class="keyword">new</span> ExitCodeEvent(context, exitCode));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			<span class="comment">// 关闭Spring容器</span></div><div class="line">			close(context);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">		ex.printStackTrace();</div><div class="line">		exitCode = (exitCode == <span class="number">0</span> ? <span class="number">1</span> : exitCode);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> exitCode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们写个Controller直接调用exit方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</div><div class="line"></div><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/stop"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 加上自己的权限验证</span></div><div class="line">    SpringApplication.exit(applicationContext);</div><div class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><p><a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints" target="_blank" rel="external">spring-boot-starter-actuator</a>这个stater内部会构造ShutdownEndpointMBean。</p>
<p>使用jconsole可以看到这个MBean：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/springboot-stop01.png" alt=""></p>
<p>SpringBoot内部也提供了一个SpringApplicationAdminMXBean，但是需要开启：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring<span class="selector-class">.application</span><span class="selector-class">.admin</span><span class="selector-class">.enabled</span>: true</div></pre></td></tr></table></figure>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/springboot-stop02.png" alt=""></p>
<h2 id="使用第三方进程管理工具"><a href="#使用第三方进程管理工具" class="headerlink" title="使用第三方进程管理工具"></a>使用第三方进程管理工具</h2><p>比如我们的应用程序部署在linux系统上，可以借助一些第三方的进程管理工具管理应用程序的运行，比如<a href="http://www.supervisord.org/" target="_blank" rel="external">supervisor</a>。</p>
<p>设置program：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[program:stop-application]</div><div class="line">command=java -jar /yourjar.jar</div><div class="line">process_name=%(program_name)s</div><div class="line">startsecs=10</div><div class="line">autostart=false</div><div class="line">autorestart=false</div><div class="line">stdout_logfile=/tmp/stop.log</div><div class="line">stderr_logfile=/tmp/stop-error.log</div></pre></td></tr></table></figure>
<p>使用supervisorctl进入控制台操作应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">supervisor&gt; status</div><div class="line">stop-application                 STOPPED   Jun 27 03:50 PM</div><div class="line">supervisor&gt; start stop-application</div><div class="line">stop-application: started</div><div class="line">supervisor&gt; status</div><div class="line">stop-application                 RUNNING   pid 27918, uptime 0:00:11</div><div class="line">supervisor&gt; stop stop-application</div><div class="line">stop-application: stopped</div><div class="line">supervisor&gt; status</div><div class="line">stop-application                 STOPPED   Jun 27 03:50 PM</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot应用程序的关闭目前总结起来有4种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Rest接口：使用spring-boot-starter-actuator模块里的ShutdownEndpoint&lt;/li&gt;
&lt;li&gt;SpringApplication的exit静态方法：直接调用该静态方法即可&lt;/li&gt;
&lt;li&gt;JMX：使用SpringBoot内部提供的MXBean&lt;/li&gt;
&lt;li&gt;使用第三方进程管理工具&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring内置的BeanPostProcessor总结</title>
    <link href="http://fangjian0423.github.io/2017/06/24/spring-embedded-bean-post-processor/"/>
    <id>http://fangjian0423.github.io/2017/06/24/spring-embedded-bean-post-processor/</id>
    <published>2017-06-23T16:57:01.000Z</published>
    <updated>2017-06-23T17:23:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring内置了一些很有用的BeanPostProcessor接口实现类。比如有AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、EventListenerMethodProcessor等。这些Processor会处理各自的场景。</p>
<p>正是有了这些processor，把bean的构造过程中的一部分功能分配给了这些processor处理，减轻了BeanFactory的负担。</p>
<p>而且添加一些新的功能也很方便。比如Spring Scheduling模块，只需要添加个@EnableScheduling注解，然后加个@Scheduled注解修饰的方法即可，这个Processor内部会自行处理。</p>
<a id="more"></a>
<h2 id="ApplicationContextAwareProcessor"><a href="#ApplicationContextAwareProcessor" class="headerlink" title="ApplicationContextAwareProcessor"></a>ApplicationContextAwareProcessor</h2><p>ApplicationContextAwareProcessor实现BeanPostProcessor接口。</p>
<p>Spring容器的refresh方法内部调用prepareBeanFactory方法，prepareBeanFactory方法会添加ApplicationContextAwareProcessor到BeanFactory中。这个Processor的作用在于为实现*Aware接口的bean调用该Aware接口定义的方法，并传入对应的参数。比如实现EnvironmentAware接口的bean在该Processor内部会调用EnvironmentAware接口的setEnvironment方法，并把Spring容器内部的ConfigurableEnvironment传递进去。</p>
<p>具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractApplicationContext.class</span></div><div class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</div><div class="line"><span class="comment">// ApplicationContextAwareProcessor.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</div><div class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</div><div class="line">      ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</div><div class="line">      ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(</div><div class="line">          <span class="keyword">new</span> EmbeddedValueResolver(<span class="keyword">this</span>.applicationContext.getBeanFactory()));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</div><div class="line">      ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</div><div class="line">      ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</div><div class="line">      ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</div><div class="line">      ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h2><p>在AnnotationConfigUtils类的registerAnnotationConfigProcessors方法中被封装成RootBeanDefinition并注册到Spring容器中。registerAnnotationConfigProcessors方法在一些比如扫描类的场景下注册。比如 context:component-scan 标签或 context:annotation-config 标签的使用，或ClassPathBeanDefinitionScanner扫描器的使用、AnnotatedBeanDefinitionReader读取器的使用。</p>
<p>主要处理@Resource、@PostConstruct和@PreDestroy注解的实现。</p>
<p>在postProcessPropertyValues过程中，该processor会找出bean中被@Resource注解修饰的属性(Field)和方法(Method)，找出以后注入到bean中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CommonAnnotationBeanPostProcessor.class</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></div><div class="line">    PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">  <span class="comment">// 找出bean中被@Resource注解修饰的属性(Field)和方法(Method)</span></div><div class="line">  InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 注入到bean中</span></div><div class="line">    metadata.inject(bean, beanName, pvs);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of resource dependencies failed"</span>, ex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pvs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommonAnnotationBeanPostProcessor的父类InitDestroyAnnotationBeanPostProcessor类的postProcessMergedBeanDefinition过程会找出被@PostConstruct和@PreDestroy注解修饰的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// InitDestroyAnnotationBeanPostProcessor.class</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// 找出被@PostConstruct和@PreDestroy注解修饰的方法</span></div><div class="line">    LifecycleMetadata metadata = findLifecycleMetadata(beanType);</div><div class="line">    metadata.checkConfigMembers(beanDefinition);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">  LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// postProcessBeforeInitialization在实例初始化之前调用</span></div><div class="line">    <span class="comment">// 这里调用了被@PostConstruct注解修饰的方法</span></div><div class="line">    metadata.invokeInitMethods(bean, beanName);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Invocation of init method failed"</span>, ex.getTargetException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Couldn't invoke init method"</span>, ex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">  LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// postProcessBeforeDestruction在实例销毁之前调用</span></div><div class="line">    <span class="comment">// 这里调用了被@PreDestroy注解修饰的方法</span></div><div class="line">    metadata.invokeDestroyMethods(bean, beanName);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">    String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + beanName + <span class="string">"'"</span>;</div><div class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">      logger.warn(msg, ex.getTargetException());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      logger.warn(msg + <span class="string">": "</span> + ex.getTargetException());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    logger.error(<span class="string">"Couldn't invoke destroy method on bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h2><p>跟CommonAnnotationBeanPostProcessor一样，在AnnotationConfigUtils类的registerAnnotationConfigProcessors方法被注册到Spring容器中。</p>
<p>主要处理@Autowired、@Value、@Lookup和@Inject注解的实现，处理逻辑跟CommonAnnotationBeanPostProcessor类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AutowiredAnnotationBeanPostProcessor.class</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></div><div class="line">    PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">  <span class="comment">// 找出被@Autowired、@Value以及@Inject注解修饰的属性和方法</span></div><div class="line">  InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 注入到bean中</span></div><div class="line">    metadata.inject(bean, beanName, pvs);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, ex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pvs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于@Autowired注解可以在构造器中使用，所以AutowiredAnnotationBeanPostProcessor实现了determineCandidateConstructors方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : rawCandidates) &#123; <span class="comment">// 遍历所有的构造器</span></div><div class="line">    <span class="comment">// 找出被@Autowired注解修饰的构造器</span></div><div class="line">    AnnotationAttributes ann = findAutowiredAnnotation(candidate);</div><div class="line">    <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</div><div class="line">      ...</div><div class="line">      candidates.add(candidate);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.getParameterTypes().length == <span class="number">0</span>) &#123;</div><div class="line">      defaultConstructor = candidate;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!candidates.isEmpty()) &#123; <span class="comment">// 有找到的话使用这些构造器</span></div><div class="line">    ...</div><div class="line">    candidateConstructors = candidates.toArray(<span class="keyword">new</span> Constructor&lt;?&gt;[candidates.size()]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">// 否则使用默认的构造器</span></div><div class="line">    candidateConstructors = <span class="keyword">new</span> Constructor&lt;?&gt;[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h2><p>跟CommonAnnotationBeanPostProcessor一样，在AnnotationConfigUtils类的registerAnnotationConfigProcessors方法被注册到Spring容器中。</p>
<p>主要处理@Required注解的实现(@Required注解只能修饰方法)，在postProcessPropertyValues过程中处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></div><div class="line">    PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</div><div class="line">    <span class="keyword">throws</span> BeansException &#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.validatedBeanNames.contains(beanName)) &#123; <span class="comment">// 查看是否已经验证过</span></div><div class="line">    <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) &#123; <span class="comment">// 查看该bean是否不会被skip，如果在BeanDefinition中有个org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.skipRequiredCheck属性，且值为true。那么这里会skip，不做required验证</span></div><div class="line">      List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">      <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</div><div class="line">        <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123; <span class="comment">// 如果属性对应的set方法被@Required注解修饰并且该属性没有被设置值的话，添加到invalidProperties集合中</span></div><div class="line">          invalidProperties.add(pd.getName());</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (!invalidProperties.isEmpty()) &#123; <span class="comment">// 如果存在被@Required注解修饰的方法对应的属性，抛出BeanInitializationException异常</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage(invalidProperties, beanName));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.validatedBeanNames.add(beanName);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> pvs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="BeanValidationPostProcessor"><a href="#BeanValidationPostProcessor" class="headerlink" title="BeanValidationPostProcessor"></a>BeanValidationPostProcessor</h2><p>默认不添加，需要手动添加。主要提供对JSR-303验证的支持，内部有个boolean类型的属性afterInitialization，默认是false。如果是false，在postProcessBeforeInitialization过程中对bean进行验证，否则在postProcessAfterInitialization过程对bean进行验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手动注册BeanValidationPostProcessor</span></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> BeanPostProcessor <span class="title">beanValidationPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanValidationPostProcessor();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义一个使用JSR-303的bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanForBeanValidation</span> </span>&#123;</div><div class="line">    <span class="meta">@NotNull</span></div><div class="line">    <span class="keyword">private</span> String id;</div><div class="line">    <span class="meta">@Min</span>(value = <span class="number">10</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后实例化BeanForBeanValidation的时候，BeanValidationPostProcessor起作用，在postProcessBeforeInitialization过程中发现validate不通过，抛出异常：</p>
<pre><code>Caused by: org.springframework.beans.factory.BeanInitializationException: Bean state is invalid: age - 最小不能小于10; id - 不能为null
</code></pre><h2 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h2><p>这是一个抽象类，实现了SmartInstantiationAwareBeanPostProcessor接口。主要用于aop在Spring中的应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">  <span class="comment">// 生成缓存key</span></div><div class="line">  <span class="comment">// AbstractAutoProxyCreator内部有个Map用于存储代理类的缓存信息</span></div><div class="line">  Object cacheKey = getCacheKey(beanClass, beanName);</div><div class="line">  <span class="comment">// targetSourcedBeans是个String集合，如果这个bean被内部的TargetSourceCreator数组属性处理过，那么targetSourcedBeans就会存储这个bean的beanName</span></div><div class="line">  <span class="comment">// 如果targetSourcedBeans内部没有包括当前beanName</span></div><div class="line">  <span class="keyword">if</span> (beanName == <span class="keyword">null</span> || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</div><div class="line">    <span class="comment">// advisedBeans属性是个Map&lt;Object, Boolean&gt;类型的map，key为cacheKey，value是个Boolean，如果是true，说明这个bean已经被wrap成代理类，否则还是原先的bean</span></div><div class="line">    <span class="comment">// 这里判断cacheKey是否已经被wrap成代理类，如果没有，返回null，走Spring默认的构造bean流程</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// isInfrastructureClass方法判断该bean是否是aop相关的bean，比如Advice、Advisor、AopInfrastructureBean</span></div><div class="line">    <span class="comment">// shouldSkip方法默认返回false，子类可覆盖。比如AspectJAwareAdvisorAutoProxyCreator子类进行了覆盖，它内部会找出Spring容器中Advisor类型的bean，然后进行遍历判断处理的bean是否是这个Advisor，如果是则过滤</span></div><div class="line">    <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</div><div class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (beanName != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// 遍历内部的TargetSourceCreator数组属性，根据bean信息得到TargetSource</span></div><div class="line">    <span class="comment">// 默认情况下TargetSourceCreator数组属性是空的</span></div><div class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</div><div class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 添加beanName到targetSourcedBeans中，证明这个bean被自定义的TargetSourceCreator处理过</span></div><div class="line">      <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</div><div class="line">      <span class="comment">// 得到Advice</span></div><div class="line">      Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</div><div class="line">      <span class="comment">// 创建代理</span></div><div class="line">      Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</div><div class="line">      <span class="comment">// 添加到proxyTypes属性中</span></div><div class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</div><div class="line">      <span class="comment">// 返回这个代理类，这样后续对该bean便不再处理，除了postProcessAfterInitialization过程</span></div><div class="line">      <span class="keyword">return</span> proxy;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个postProcessBeforeInstantiation方法我们得出：如果使用了自定义的TargetSourceCreator，并且这个TargetSourceCreator得到了处理bean的TargetSource结果，那么直接基于这个bean和TargetSource结果构造出代理类。这个过程发生在postProcessBeforeInstantiation方法中，所以这个代理类直接代替了原本该生成的bean。如果没有使用自定义的TargetSourceCreator，那么走默认构造bean的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">  <span class="comment">// 生成缓存key</span></div><div class="line">  Object cacheKey = getCacheKey(bean.getClass(), beanName);</div><div class="line">  <span class="comment">// earlyProxyReferences用来存储提前暴露的代理对象的缓存key，这里判断是否已经处理过，没处理过的话放到earlyProxyReferences里</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</div><div class="line">    <span class="keyword">this</span>.earlyProxyReferences.add(cacheKey);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果已经使用了自定义的TargetSourceCreator生成了代理类，直接返回这个代理类</span></div><div class="line">  <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</div><div class="line">    <span class="keyword">return</span> bean;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 该bean已经没有被wrap成代理类，直接返回原本生成的实例</span></div><div class="line">  <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</div><div class="line">    <span class="keyword">return</span> bean;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 如果是处理aop自身相关的bean或者这些bean需要被skip，也直接返回这些bean</span></div><div class="line">  <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</div><div class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">    <span class="keyword">return</span> bean;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 得到Advice</span></div><div class="line">  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</div><div class="line">  <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123; <span class="comment">// 如果被aop处理了</span></div><div class="line">    <span class="comment">// 添加到advisedBeans属性中，说明该bean已经被wrap成代理类</span></div><div class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</div><div class="line">    <span class="comment">// 创建代理类</span></div><div class="line">    Object proxy = createProxy(</div><div class="line">        bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</div><div class="line">    <span class="comment">// 添加到proxyTypes属性中</span></div><div class="line">    <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 如果没有被aop处理，添加到advisedBeans属性中，并说明不是代理类</span></div><div class="line">  <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</div><div class="line">  <span class="keyword">return</span> bean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</div><div class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</div><div class="line">      <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面这些方法看出，要实例化的bean会通过wrapIfNecessary进行处理，wrapIfNecessary方法会根据情况是否wrap成代理类，最终返回这个结果。getEarlyBeanReference和postProcessAfterInitialization处理流程是一样的，唯一的区别是getEarlyBeanReference是针对单例的，而postProcessAfterInitialization方法是针对prototype的，针对prototype的话，每次实例化都会wrap成代理对象，而单例的话只需要wrap一次即可。</p>
<p>AbstractAutoProxyCreator抽象类有基于注解的子类AnnotationAwareAspectJAutoProxyCreator。这个AnnotationAwareAspectJAutoProxyCreator会扫描出Spring容器中带有@Aspect注解的bean，然后在getAdvicesAndAdvisorsForBean方法中会根据这个aspect查看是否被拦截，如果被拦截那么就wrap成代理类。</p>
<p>默认情况下，AbstractAutoProxyCreator相关的BeanPostProcessor是不会注册到Spring容器中的。比如在SpringBoot中加入aop-starter之后，会触发AopAutoConfiguration自动化配置，然后将AnnotationAwareAspectJAutoProxyCreator注册到Spring容器中。</p>
<h2 id="MethodValidationPostProcessor"><a href="#MethodValidationPostProcessor" class="headerlink" title="MethodValidationPostProcessor"></a>MethodValidationPostProcessor</h2><p>默认不添加，需要手动添加。支持方法级别的JSR-303规范。需要在类上加上@Validated注解，以及在方法的参数中加上验证注解，比如@Max，@Min，@NotEmpty …。 下面这个BeanForMethodValidation就加上了@Validated注解，并且在方法validate的参数里加上的JSR-303的验证注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@Validated</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanForMethodValidation</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(@NotEmpty String name, @Min(<span class="number">10</span>)</span> <span class="keyword">int</span> age) </span>&#123;</div><div class="line">        System.out.println(<span class="string">"validate, name: "</span> + name + <span class="string">", age: "</span> + age);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MethodValidationPostProcessor内部使用aop完成对方法的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MethodValidationPostProcessor.class</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 基于validatedAnnotationType属性构造出Pointcut，这个validatedAnnotationType属性默认是@Validated注解类型，可以进行修改</span></div><div class="line">  Pointcut pointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">this</span>.validatedAnnotationType, <span class="keyword">true</span>);</div><div class="line">  <span class="comment">// 基于Pointcut和Advice构造出Advisor</span></div><div class="line">  <span class="keyword">this</span>.advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(<span class="keyword">this</span>.validator));</div><div class="line">&#125;</div><div class="line"><span class="comment">// MethodValidationInterceptor这个Advice内部使用JSR完成方法参数的验证</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Advice <span class="title">createMethodValidationAdvice</span><span class="params">(Validator validator)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (validator != <span class="keyword">null</span> ? <span class="keyword">new</span> MethodValidationInterceptor(validator) : <span class="keyword">new</span> MethodValidationInterceptor());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ScheduledAnnotationBeanPostProcessor"><a href="#ScheduledAnnotationBeanPostProcessor" class="headerlink" title="ScheduledAnnotationBeanPostProcessor"></a>ScheduledAnnotationBeanPostProcessor</h2><p>默认不添加，使用@EnableScheduling注解后，会被注册到Spring容器中。主要使用Spring Scheduling功能对bean中使用了@Scheduled注解的方法进行调度处理。实现了BeanPostProcessor接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> </span>&#123;</div><div class="line">  <span class="comment">// 判断是否是代理类，如果是代理类，拿到真正的目标类</span></div><div class="line">  Class&lt;?&gt; targetClass = AopUtils.getTargetClass(bean);</div><div class="line">  <span class="comment">// 判断是否已经处理过。nonAnnotatedClasses属性是个Class集合，用于存储bean对应的class是否有@Scheduled注解的方法，如果没有，则添加到这个集合中</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.nonAnnotatedClasses.contains(targetClass)) &#123;</div><div class="line">    <span class="comment">// 找出class中带有@Scheduled注解的方法</span></div><div class="line">    Map&lt;Method, Set&lt;Scheduled&gt;&gt; annotatedMethods = MethodIntrospector.selectMethods(targetClass,</div><div class="line">        <span class="keyword">new</span> MethodIntrospector.MetadataLookup&lt;Set&lt;Scheduled&gt;&gt;() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Set&lt;Scheduled&gt; <span class="title">inspect</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">            Set&lt;Scheduled&gt; scheduledMethods =</div><div class="line">                AnnotationUtils.getRepeatableAnnotations(method, Scheduled.class, Schedules.class);</div><div class="line">            <span class="keyword">return</span> (!scheduledMethods.isEmpty() ? scheduledMethods : <span class="keyword">null</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">    <span class="comment">// 如果不存在@Scheduled注解的方法</span></div><div class="line">    <span class="keyword">if</span> (annotatedMethods.isEmpty()) &#123;</div><div class="line">      <span class="comment">// 添加到nonAnnotatedClasses集合中。下次不用重复处理该类</span></div><div class="line">      <span class="keyword">this</span>.nonAnnotatedClasses.add(targetClass);</div><div class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">        logger.trace(<span class="string">"No @Scheduled annotations found on bean class: "</span> + bean.getClass());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果存在@Scheduled注解的方法</span></div><div class="line">      <span class="comment">// 遍历这些@Scheduled注解的方法</span></div><div class="line">      <span class="keyword">for</span> (Map.Entry&lt;Method, Set&lt;Scheduled&gt;&gt; entry : annotatedMethods.entrySet()) &#123;</div><div class="line">        Method method = entry.getKey();</div><div class="line">        <span class="keyword">for</span> (Scheduled scheduled : entry.getValue()) &#123;</div><div class="line">          <span class="comment">// 进行调度处理</span></div><div class="line">          processScheduled(scheduled, method, bean);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">        logger.debug(annotatedMethods.size() + <span class="string">" @Scheduled methods processed on bean '"</span> + beanName +</div><div class="line">            <span class="string">"': "</span> + annotatedMethods);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AsyncAnnotationBeanPostProcessor"><a href="#AsyncAnnotationBeanPostProcessor" class="headerlink" title="AsyncAnnotationBeanPostProcessor"></a>AsyncAnnotationBeanPostProcessor</h2><p>默认不添加，使用@EnableAsync注解后，会被注册到Spring容器中。AsyncAnnotationBeanPostProcessor内部使用aop处理方法的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AsyncAnnotationBeanPostProcessor.class</span></div><div class="line"><span class="comment">// 实现了BeanFactoryAware接口，这里会得到beanFactory</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.setBeanFactory(beanFactory);</div><div class="line">  <span class="comment">// 构造一个AsyncAnnotationAdvisor</span></div><div class="line">  <span class="comment">// AsyncAnnotationAdvisor内部的Advice是AnnotationAsyncExecutionInterceptor，Pointcut会找出带有@Async的类和@Async的方法</span></div><div class="line">  AsyncAnnotationAdvisor advisor = <span class="keyword">new</span> AsyncAnnotationAdvisor(<span class="keyword">this</span>.executor, <span class="keyword">this</span>.exceptionHandler);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.asyncAnnotationType != <span class="keyword">null</span>) &#123;</div><div class="line">    advisor.setAsyncAnnotationType(<span class="keyword">this</span>.asyncAnnotationType);</div><div class="line">  &#125;</div><div class="line">  advisor.setBeanFactory(beanFactory);</div><div class="line">  <span class="keyword">this</span>.advisor = advisor;</div><div class="line">&#125;</div><div class="line"><span class="comment">// AsyncExecutionInterceptor.class。 AnnotationAsyncExecutionInterceptor的父类</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="comment">// 得到方法的对应类</span></div><div class="line">  Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</div><div class="line">  <span class="comment">// 得到方法</span></div><div class="line">  Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);</div><div class="line">  <span class="keyword">final</span> Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);</div><div class="line">  <span class="comment">// 得到Executor线程池。如果没有在Spring容器中找到TaskExecutor类型的线程池，直接构造一个SimpleAsyncTaskExecutor</span></div><div class="line">  AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod);</div><div class="line">  <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">        <span class="string">"No executor specified and no default executor set on AsyncExecutionInterceptor either"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 把方法在调用封装到Callable中</span></div><div class="line">  Callable&lt;Object&gt; task = <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Object result = invocation.proceed();</div><div class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Future) &#123;</div><div class="line">          <span class="keyword">return</span> ((Future&lt;?&gt;) result).get();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (ExecutionException ex) &#123;</div><div class="line">        handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">        handleError(ex, userDeclaredMethod, invocation.getArguments());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// 提交任务</span></div><div class="line">  <span class="keyword">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ServletContextAwareProcessor"><a href="#ServletContextAwareProcessor" class="headerlink" title="ServletContextAwareProcessor"></a>ServletContextAwareProcessor</h2><p>默认不添加，如果Spring容器是个Web容器，那么会被添加。比如GenericWebApplicationContext容器就在postProcessBeanFactory中添加了ServletContextAwareProcessor。postProcessBeanFactory方法是在Spring容器的refresh过程中被调用的。</p>
<p>ServletContextAwareProcessor实现了BeanPostProcessor接口，如果Spring容器中的bean实现了ServletContextAware或ServletConfigAware接口，那么会进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (getServletContext() != <span class="keyword">null</span> &amp;&amp; bean <span class="keyword">instanceof</span> ServletContextAware) &#123;</div><div class="line">    ((ServletContextAware) bean).setServletContext(getServletContext());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (getServletConfig() != <span class="keyword">null</span> &amp;&amp; bean <span class="keyword">instanceof</span> ServletConfigAware) &#123;</div><div class="line">    ((ServletConfigAware) bean).setServletConfig(getServletConfig());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bean;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="SpringBoot内部特有的BeanPostProcessor"><a href="#SpringBoot内部特有的BeanPostProcessor" class="headerlink" title="SpringBoot内部特有的BeanPostProcessor"></a>SpringBoot内部特有的BeanPostProcessor</h2><p>EmbeddedServletContainerCustomizerBeanPostProcessor主要处理实现EmbeddedServletContainerCustomizer接口的bean。EmbeddedServletContainerCustomizer接口是SpringBoot提供的用于处理内置的Servlet容器的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerCustomizer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个EmbeddedServletContainerCustomizerBeanPostProcessor实现了BeanPostProcessor接口，处理过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">    <span class="keyword">throws</span> BeansException &#123;</div><div class="line">  <span class="comment">// 处理ConfigurableEmbeddedServletContainer类型的bean</span></div><div class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</div><div class="line">    postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bean;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(</span></span></div><div class="line">		ConfigurableEmbeddedServletContainer bean) &#123;</div><div class="line">  <span class="comment">// 找出Spring容器中EmbeddedServletContainerCustomizer接口的实现类，并遍历依次调用</span></div><div class="line">	<span class="keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</div><div class="line">		customizer.customize(bean);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="title">getCustomizers</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.customizers == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// Look up does not include the parent context</span></div><div class="line">		<span class="keyword">this</span>.customizers = <span class="keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</div><div class="line">				<span class="keyword">this</span>.applicationContext</div><div class="line">						.getBeansOfType(EmbeddedServletContainerCustomizer.class,</div><div class="line">								<span class="keyword">false</span>, <span class="keyword">false</span>)</div><div class="line">						.values());</div><div class="line">		Collections.sort(<span class="keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</div><div class="line">		<span class="keyword">this</span>.customizers = Collections.unmodifiableList(<span class="keyword">this</span>.customizers);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.customizers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpringBoot内部EmbeddedServletContainerCustomizer接口的实现类有ServerProperties、ErrorMvcAutoConfiguration的内部类ErrorPageCustomizer等。 我们也可以实现自定义的EmbeddedServletContainerCustomizer用于修改内置Servlet容器的属性。</p>
<p>SpringBoot内部还有一些比如ConfigurationPropertiesBindingPostProcessor用于处于@ConfigurationProperties注解的processor、DataSourceInitializedPublisher用于发布DataSourceInitializedEvent事件等。读者可查看相关源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring内置了一些很有用的BeanPostProcessor接口实现类。比如有AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、EventListenerMethodProcessor等。这些Processor会处理各自的场景。&lt;/p&gt;
&lt;p&gt;正是有了这些processor，把bean的构造过程中的一部分功能分配给了这些processor处理，减轻了BeanFactory的负担。&lt;/p&gt;
&lt;p&gt;而且添加一些新的功能也很方便。比如Spring Scheduling模块，只需要添加个@EnableScheduling注解，然后加个@Scheduled注解修饰的方法即可，这个Processor内部会自行处理。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring内部的BeanPostProcessor接口总结</title>
    <link href="http://fangjian0423.github.io/2017/06/20/spring-bean-post-processor/"/>
    <id>http://fangjian0423.github.io/2017/06/20/spring-bean-post-processor/</id>
    <published>2017-06-20T11:30:30.000Z</published>
    <updated>2017-06-22T16:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring内部提供了一个BeanPostProcessor接口，这个接口的作用在于对于新构造的实例可以做一些自定义的修改。比如如何构造、属性值的修改、构造器的选择等等。</p>
<p>只要我们实现了这个接口，便可以对构造的bean进行自定义的修改。</p>
<a id="more"></a>
<p>BeanPostProcessor接口还有一些子接口的定义：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/bean-post-processor.png" alt=""></p>
<h2 id="InstantiationAwareBeanPostProcessor"><a href="#InstantiationAwareBeanPostProcessor" class="headerlink" title="InstantiationAwareBeanPostProcessor"></a>InstantiationAwareBeanPostProcessor</h2><p>InstantiationAwareBeanPostProcessor接口继承自BeanPostProcessor接口。多出了3个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// postProcessBeforeInstantiation方法的作用在目标对象被实例化之前调用的方法，可以返回目标实例的一个代理用来代替目标实例</span></div><div class="line"><span class="comment">// beanClass参数表示目标对象的类型，beanName是目标实例在Spring容器中的name</span></div><div class="line"><span class="comment">// 返回值类型是Object，如果返回的是非null对象，接下来除了postProcessAfterInitialization方法会被执行以外，其它bean构造的那些方法都不再执行。否则那些过程以及postProcessAfterInitialization方法都会执行</span></div><div class="line"><span class="function">Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line"><span class="comment">// postProcessAfterInstantiation方法的作用在目标对象被实例化之后并且在属性值被populate之前调用</span></div><div class="line"><span class="comment">// bean参数是目标实例(这个时候目标对象已经被实例化但是该实例的属性还没有被设置)，beanName是目标实例在Spring容器中的name</span></div><div class="line"><span class="comment">// 返回值是boolean类型，如果返回true，目标实例内部的返回值会被populate，否则populate这个过程会被忽视</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line"></div><div class="line"><span class="comment">// postProcessPropertyValues方法的作用在属性中被设置到目标实例之前调用，可以修改属性的设置</span></div><div class="line"><span class="comment">// pvs参数表示参数属性值(从BeanDefinition中获取)，pds代表参数的描述信息(比如参数名，类型等描述信息)，bean参数是目标实例，beanName是目标实例在Spring容器中的name</span></div><div class="line"><span class="comment">// 返回值是PropertyValues，可以使用一个全新的PropertyValues代替原先的PropertyValues用来覆盖属性设置或者直接在参数pvs上修改。如果返回值是null，那么会忽略属性设置这个过程(所有属性不论使用什么注解，最后都是null)</span></div><div class="line"><span class="function">PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></div><div class="line">    PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</div><div class="line">    <span class="keyword">throws</span> BeansException;</div></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>InstantiationAwareBeanPostProcessor接口继承BeanPostProcessor接口，它内部提供了3个方法，再加上BeanPostProcessor接口内部的2个方法，所以实现这个接口需要实现5个方法。InstantiationAwareBeanPostProcessor接口的主要作用在于目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置</li>
<li>postProcessBeforeInstantiation方法是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走</li>
<li>postProcessAfterInstantiation方法在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。如果该方法返回false，会忽略属性值的设置；如果返回true，会按照正常流程设置属性值</li>
<li>postProcessPropertyValues方法对属性值进行修改(这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值)。如果postProcessAfterInstantiation方法返回false，该方法不会被调用。可以在该方法内对属性值进行修改</li>
<li>父接口BeanPostProcessor的2个方法postProcessBeforeInitialization和postProcessAfterInitialization都是在目标对象被实例化之后，并且属性也被设置之后调用的</li>
<li>Instantiation表示实例化，Initialization表示初始化。实例化的意思在对象还未生成，初始化的意思在对象已经生成</li>
</ol>
<h2 id="SmartInstantiationAwareBeanPostProcessor"><a href="#SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="SmartInstantiationAwareBeanPostProcessor"></a>SmartInstantiationAwareBeanPostProcessor</h2><p>SmartInstantiationAwareBeanPostProcessor接口继承InstantiationAwareBeanPostProcessor接口。多出了3个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null</span></div><div class="line">Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException;</div><div class="line"></div><div class="line"><span class="comment">// 选择合适的构造器，比如目标对象有多个构造器，在这里可以进行一些定制化，选择合适的构造器</span></div><div class="line"><span class="comment">// beanClass参数表示目标实例的类型，beanName是目标实例在Spring容器中的name</span></div><div class="line"><span class="comment">// 返回值是个构造器数组，如果返回null，会执行下一个PostProcessor的determineCandidateConstructors方法；否则选取该PostProcessor选择的构造器</span></div><div class="line">Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException;</div><div class="line"></div><div class="line"><span class="comment">// 获得提前暴露的bean引用。主要用于解决循环引用的问题</span></div><div class="line"><span class="comment">// 只有单例对象才会调用此方法</span></div><div class="line"><span class="function">Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>SmartInstantiationAwareBeanPostProcessor接口继承InstantiationAwareBeanPostProcessor接口，它内部提供了3个方法，再加上父接口的5个方法，所以实现这个接口需要实现8个方法。SmartInstantiationAwareBeanPostProcessor接口的主要作用也是在于目标对象的实例化过程中需要处理的事情。它是InstantiationAwareBeanPostProcessor接口的一个扩展。主要在Spring框架内部使用</li>
<li>predictBeanType方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null。主要在于BeanDefinition无法确定Bean类型的时候调用该方法来确定类型</li>
<li>determineCandidateConstructors方法用于选择合适的构造器，比如类有多个构造器，可以实现这个方法选择合适的构造器并用于实例化对象。该方法在postProcessBeforeInstantiation方法和postProcessAfterInstantiation方法之间调用，如果postProcessBeforeInstantiation方法返回了一个新的实例代替了原本该生成的实例，那么该方法会被忽略</li>
<li>getEarlyBeanReference主要用于解决循环引用问题。比如ReferenceA实例内部有ReferenceB的引用，ReferenceB实例内部有ReferenceA的引用。首先先实例化ReferenceA，实例化完成之后提前把这个bean暴露在ObjectFactory中，然后populate属性，这个时候发现需要ReferenceB。然后去实例化ReferenceB，在实例化ReferenceB的时候它需要ReferenceA的实例才能继续，这个时候就会去ObjectFactory中找出了ReferenceA实例，ReferenceB顺利实例化。ReferenceB实例化之后，ReferenceA的populate属性过程也成功完成，注入了ReferenceB实例。提前把这个bean暴露在ObjectFactory中，这个ObjectFactory获取的实例就是通过getEarlyBeanReference方法得到的</li>
</ol>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>BeanPostProcessor接口是最顶层的接口，接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">    <span class="comment">// 初始化之前的操作</span></div><div class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">// 初始化之后的操作</span></div><div class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>postProcessBeforeInitialization是指bean在初始化之前需要调用的方法</li>
<li>postProcessAfterInitialization是指bean在初始化之后需要调用的方法</li>
<li>postProcessBeforeInitialization和postProcessAfterInitialization方法被调用的时候。这个时候bean已经被实例化，并且所有该注入的属性都已经被注入，是一个完整的bean</li>
<li>这2个方法的返回值可以是原先生成的实例bean，或者使用wrapper包装这个实例</li>
</ol>
<h2 id="DestructionAwareBeanPostProcessor"><a href="#DestructionAwareBeanPostProcessor" class="headerlink" title="DestructionAwareBeanPostProcessor"></a>DestructionAwareBeanPostProcessor</h2><p>DestructionAwareBeanPostProcessor接口继承BeanPostProcessor接口。多出了1个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div></pre></td></tr></table></figure>
<p>该方法是bean在Spring在容器中被销毁之前调用</p>
<h2 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h2><p>DestructionAwareBeanPostProcessor接口继承BeanPostProcessor接口。多出了1个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;</div></pre></td></tr></table></figure>
<p>该方法是bean在合并Bean定义之后调用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring内部对bean的构造已经形成了一套体系。如果我们想修改这套体系，只能使用Spring提供的BeanPostProcessor接口去处理。这样做的好处：</p>
<p><strong>遵循设计模式的开闭原则，对扩展开放，对修改关闭。 我们只需要实现接口进行扩展即可，不需要修改内部的源码</strong></p>
<p>下一篇，将分析Spring内置的一些BeanPostProcessor的功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring内部提供了一个BeanPostProcessor接口，这个接口的作用在于对于新构造的实例可以做一些自定义的修改。比如如何构造、属性值的修改、构造器的选择等等。&lt;/p&gt;
&lt;p&gt;只要我们实现了这个接口，便可以对构造的bean进行自定义的修改。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring类注册笔记</title>
    <link href="http://fangjian0423.github.io/2017/06/15/spring-bean-register-note/"/>
    <id>http://fangjian0423.github.io/2017/06/15/spring-bean-register-note/</id>
    <published>2017-06-15T14:14:37.000Z</published>
    <updated>2017-06-15T14:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>对Spring类注册功能做个笔记，包括内置的一些扫描器以及这些扫描器的用途和注意点；还有bean注册相关的接口介绍；最后就是这些扫描器在SpringBoot上的使用。</p>
<a id="more"></a>
<h2 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h2><ol>
<li>BeanDefinitionReader接口。目前有3种实现，分别是GroovyBeanDefinitionReader(groovy文件的读取器)、PropertiesBeanDefinitionReader(Properties文件的读取器)和XmlBeanDefinitionReader(xml文件的读取器)。这3个实现类都继承AbstractBeanDefinitionReader，AbstractBeanDefinitionReader抽象类内部有个BeanDefinitionRegistry接口类型的属性，BeanDefinitionRegistry接口存在的意义在于对bean数据的管理，包括bean的注册、删除、查找等。这3个实现类内部最终对bean的注册都是通过BeanDefinitionRegistry完成的，不同点在于它们处理过程不一样，比如xml文件的解析和properties文件的解析这个过程不一样</li>
<li>AnnotatedBeanDefinitionReader类。独立的一个类，用来注册单独的类，也是使用BeanDefinitionRegistry接口类型的属性完成bean的注册</li>
<li>ClassPathScanningCandidateComponentProvider类。独立的一个类，用来找出具体包下的bean信息，内部有2个TypeFilter集合属性，includeFilters和excludeFilters，分别用于对找出的bean信息做匹配，includeFilters中的TypeFilter只要有一个满足，就不会过滤；excludeFilters中的TypeFilter只要有一个满足，就会被过滤。ClassPathBeanDefinitionScanner是ClassPathScanningCandidateComponentProvider类的子类，提供了scan方法，这个scan方法会找出包下的bean信息并使用BeanDefinitionRegistry接口类型的属性完成bean的注册</li>
<li>ConfigurationClassParser类。独立的一个类，用来解析被@Configuration注解修饰的配置类。在<br><a href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/">SpringBoot源码分析之Spring容器的refresh过程</a>文章中分析过ConfigurationClassParser的作用。简单点来说就是ConfigurationClassParser会解析被@Configuration注解修饰的类，然后再处理这个类内部被其它注解修饰的情况，比如@Import注解、@ComponentScan注解、@ImportResource注解、@Bean注解等。这里解析过程中也会遇到其它被@Configuration注解修饰的类，这些类会放到ConfigurationClassParser的configurationClasses属性中然后被ConfigurationClassBeanDefinitionReader处理</li>
<li>ConfigurationClassBeanDefinitionReader，独立的一个类，处理ConfigurationClassParser解析出的被@Configuration注解修饰的配置类，会处理配置类内部的被@Bean注解修饰的方法、@ImportResource注解修饰的资源、@Import注解修饰的ImportBeanDefinitionRegistrar接口。最后使用BeanDefinitionRegistry注册</li>
<li>ComponentScanAnnotationParser，独立的一个类，@ComponentScan注解对应的解析器，内部使用ClassPathBeanDefinitionScanner完成</li>
</ol>
<h2 id="扫描器注意点"><a href="#扫描器注意点" class="headerlink" title="扫描器注意点"></a>扫描器注意点</h2><ol>
<li>第4点和第5点提到的ConfigurationClassParser和ConfigurationClassBeanDefinitionReader在ConfigurationClassPostProcessor这个BeanFactoryPostProcessor中使用；它们都是跟@Configuration注解修饰的类有关系</li>
<li>AnnotatedBeanDefinitionReader构造的时候会使用AnnotationConfigUtils的registerAnnotationConfigProcessors方法预先注册一些processor bean，比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor</li>
<li>ClassPathBeanDefinitionScanner扫描具体包下的类，扫描完之后根据includeAnnotationConfig属性是否使用AnnotationConfigUtils的registerAnnotationConfigProcessors方法预先注册一些processor bean。includeAnnotationConfig属性默认是true，可修改</li>
<li>AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner加入processor的原因在于它们注册或者扫描出来的类在Spring容器的后续处理过程中进行另外的处理。比如扫描出来配置类(被@Configuration注解修饰的类)，会被ConfigurationClassPostProcessor处理(解析内部结构)，比如类中的一些被@Autowired注解修饰的属性会被AutowiredAnnotationBeanPostProcessor处理等等</li>
</ol>
<h2 id="一些接口"><a href="#一些接口" class="headerlink" title="一些接口"></a>一些接口</h2><ol>
<li>BeanDefinition接口：描述bean实例，包括属性值、构造方法的参数值、是否单例、是否抽象、作用域scope、对应的class名字等<br>1.1 AnnotatedBeanDefinition接口是BeanDefinition接口的子接口，包括了实例的注解信息<br>1.2 ScannedGenericBeanDefinition类是AnnotatedBeanDefinition接口的实现类，ClassPathScanningCandidateComponentProvider扫描出来的类信息就会封装成ScannedGenericBeanDefinition，这是一个被扫描到的类定义<br>1.3 AnnotatedGenericBeanDefinition类也是AnnotatedBeanDefinition接口的实现类，在AnnotatedBeanDefinitionReader读取器读取类后封装成的，这是一个被注解过的类定义</li>
<li>BeanDefinitionRegistry接口：持有BeanDefinition信息的注册中心，可以注册新的BeanDefinition、删除老的BeanDefinition、获取注册中心的BeanDefinition。这个接口是Spring提供的唯一一个可以操作BeanDefinition数据的接口<br>2.1 SimpleBeanDefinitionRegistry是一个简单的BeanDefinitionRegistry接口的实现类，内部使用Map<string, beandefinition="">类型的map存储BeanDefinition信息<br>2.2 DefaultListableBeanFactory这个BeanFactory接口的实现类也实现了BeanDefinitionRegistry接口，内部也是使用Map<string, beandefinition="">类型的map存储BeanDefinition信息<br>2.3 通用的Spring容器GenericApplicationContext也是BeanDefinitionRegistry接口的实现类，它使用内部属性DefaultListableBeanFactory完成BeanDefinitionRegistry接口的功能(DefaultListableBeanFactory实现了BeanDefinitionRegistry接口)</string,></string,></li>
<li>BeanFactory接口：Spring bean容器，用来管理bean的容器</li>
<li>ApplicationContext：应用程序上下文接口，我一般喜欢叫Spring容器。它不仅仅包括bean相关的操作，还包括了很多其它的东西(毕竟是跟应用程序相关的)，比如环境信息的设置、事件触发器、国际化等。 是一个全局的概念</li>
</ol>
<h2 id="扫描器在SpringBoot中的使用"><a href="#扫描器在SpringBoot中的使用" class="headerlink" title="扫描器在SpringBoot中的使用"></a>扫描器在SpringBoot中的使用</h2><p>SpringBoot中的SpringApplication类提供了run方法，run方法内部有一个参数叫做source，是Object类型的(有重载的方法，支持多个source，类型是Object数组)。</p>
<p>SpringBoot通过一个叫做BeanDefinitionLoader类的加载器去加载这些source。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(Object source)</span> </span>&#123;</div><div class="line">  Assert.notNull(source, <span class="string">"Source must not be null"</span>);</div><div class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</div><div class="line">    <span class="keyword">return</span> load((Class&lt;?&gt;) source);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) &#123;</div><div class="line">    <span class="keyword">return</span> load((Resource) source);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) &#123;</div><div class="line">    <span class="keyword">return</span> load((Package) source);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</div><div class="line">    <span class="keyword">return</span> load((CharSequence) source);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid source type "</span> + source.getClass());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前支持4种类型的source，分别是：</p>
<ol>
<li>Class类型：使用AnnotatedBeanDefinitionReader读取器加载</li>
<li>Resource类型：使用XmlBeanDefinitionReader读取器加载</li>
<li>Package类型：使用ClassPathBeanDefinitionScanner扫描器加载</li>
<li>CharSequence：识别这个字符串信息。如果是Class类型，用第1种；如果是Resource类型，用第2种；如果是Package类型，用第3种</li>
</ol>
<p>Class类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// Class类型，使用AnnotatedBeanDefinitionReader加载</span></div><div class="line">        <span class="comment">// 加载完毕之后使用ConfigurationClassPostProcessor进行后续的处理</span></div><div class="line">        SpringApplication.run(MyApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Resource类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SpringApplication.run(</div><div class="line"><span class="keyword">new</span> Object[] &#123;</div><div class="line">        MyApplication.class</div><div class="line">        , <span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>) <span class="comment">// 使用XmlBeanDefinitionReader加载</span></div><div class="line">&#125;</div><div class="line">, args);</div></pre></td></tr></table></figure>
<p>Package类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SpringApplication.run(</div><div class="line"><span class="keyword">new</span> Object[] &#123;</div><div class="line">        MyApplication.class</div><div class="line">        , <span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>)</div><div class="line">        , OtherBean.class.getPackage() <span class="comment">// 使用ClassPathBeanDefinitionScanner加载</span></div><div class="line">&#125;</div><div class="line">, args);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Spring类注册功能做个笔记，包括内置的一些扫描器以及这些扫描器的用途和注意点；还有bean注册相关的接口介绍；最后就是这些扫描器在SpringBoot上的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring自定义类扫描器</title>
    <link href="http://fangjian0423.github.io/2017/06/11/spring-custom-component-provider/"/>
    <id>http://fangjian0423.github.io/2017/06/11/spring-custom-component-provider/</id>
    <published>2017-06-11T10:41:50.000Z</published>
    <updated>2017-06-14T07:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们刚开始接触Spring的时候，要定义bean的话需要在xml中编写，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBean"</span> <span class="attr">class</span>=<span class="string">"your.pkg.YourClass"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>后来发现如果bean比较多，会需要写很多的bean标签，太麻烦了。于是出现了一个component-scan注解。这个注解直接指定包名就可以，它会去扫描这个包下所有的class，然后判断是否解析：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"your.pkg"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>再后来，由于注解Annotation的流行，出现了@ComponentScan注解，作用跟component-scan标签一样，跟@Configuration注解配合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"your.pkg"</span>, <span class="string">"other.pkg"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>不论是component-scan标签，还是@ComponentScan注解。它们扫描或解析的bean只能是Spring内部所定义的，比如@Component、@Service、@Controller或@Repository。如果有一些自定义的注解，比如@Consumer、这个注解修饰的类是不会被扫描到的。这个时候我们就得自定义扫描器完成这个操作。</p>
<a id="more"></a>
<h2 id="Spring内置的扫描器"><a href="#Spring内置的扫描器" class="headerlink" title="Spring内置的扫描器"></a>Spring内置的扫描器</h2><p>component-scan标签底层使用ClassPathBeanDefinitionScanner这个类完成扫描工作的。@ComponentScan注解配合@Configuration注解使用，底层使用ComponentScanAnnotationParser解析器完成解析工作。</p>
<p>ComponentScanAnnotationParser解析器内部使用了ClassPathBeanDefinitionScanner扫描器，ClassPathBeanDefinitionScanner扫描器内部的处理过程整理如下：</p>
<ol>
<li>遍历basePackages，根据每个basePackage找出这个包下的所有的class。比如basePackage为your/pkg，会找出your.pkg包下所有的class。找出之后封装成Resource接口集合，这个Resource接口是Spring对资源的封装，有FileSystemResource、ClassPathResource、UrlResource实现等</li>
<li>遍历找到的Resource集合，通过includeFilters和excludeFilters判断是否解析。这里的includeFilters和excludeFilters是TypeFilter接口类型的集合，是ClassPathBeanDefinitionScanner内部的属性。TypeFilter接口是一个用于判断类型是否满足要求的类型过滤器。excludeFilters中只要有一个TypeFilter满足条件，这个Resource就会被过滤。includeFilters中只要有一个TypeFilter满足条件，这个Resource就不会被过滤</li>
<li>如果没有被过滤。把Resource封装成ScannedGenericBeanDefinition添加到BeanDefinition结果集中</li>
<li>返回最后的BeanDefinition结果集</li>
</ol>
<p>TypeFilter接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeFilter</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></div><div class="line">			<span class="keyword">throws</span> IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TypeFilter接口目前有AnnotationTypeFilter实现类(类是否有注解修饰)、RegexPatternTypeFilter(类名是否满足正则表达式)等。</p>
<p>ClassPathBeanDefinitionScanner继承ClassPathScanningCandidateComponentProvider类。</p>
<p>ClassPathScanningCandidateComponentProvider内部的构造函数提供了一个useDefaultFilters参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(<span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>(useDefaultFilters, <span class="keyword">new</span> StandardEnvironment());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>useDefaultFilters这个参数表示是否使用默认的TypeFilter，如果设置为true，会添加默认的TypeFilter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</div><div class="line">  ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</div><div class="line">        ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</div><div class="line">    logger.debug(<span class="string">"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">    <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</div><div class="line">        ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</div><div class="line">    logger.debug(<span class="string">"JSR-330 'javax.inject.Named' annotation found and supported for component scanning"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">    <span class="comment">// JSR-330 API not available - simply skip.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到这里includeFilters加上了AnnotationTypeFilter，并且对应的注解是@Component。@Service、@Controller或@Repository注解它们内部都是被@Component注解所修饰的，所以它们也会被识别。</p>
<h2 id="自定义扫描功能"><a href="#自定义扫描功能" class="headerlink" title="自定义扫描功能"></a>自定义扫描功能</h2><p>一般情况下，我们要自定义扫描功能的话，可以直接使用ClassPathScanningCandidateComponentProvider完成，加上一些自定义的TypeFilter即可。或者写个自定义扫描器继承ClassPathScanningCandidateComponentProvider，并在内部添加自定义的TypeFilter。后者相当于对前者的封装。</p>
<p>我们就以一个简单的例子说明一下自定义扫描的实现，直接使用ClassPathScanningCandidateComponentProvider。</p>
<p>项目结构如下：</p>
<pre><code>./
└── spring
    └── study
        └── componentprovider
            ├── annotation
            │   └──  Consumer.java
            ├── bean
            │   ├── ConsumerWithComponentAnnotation.java
            │   ├── ConsumerWithConsumerAnnotation.java
            │   ├── ConsumerWithInterface.java
            │   ├── ConsumerWithNothing.java
            │   └── ProducerWithInterface.java
            └── interfaze
                ├── IConsumer.java
                └── IProducer.java
</code></pre><p>我们直接使用ClassPathScanningCandidateComponentProvider扫描spring.study.componentprovider.bean包下的class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPathScanningCandidateComponentProvider provider = <span class="keyword">new</span> ClassPathScanningCandidateComponentProvider(<span class="keyword">false</span>); <span class="comment">// 不使用默认的TypeFilter</span></div><div class="line">provider.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Consumer.class));</div><div class="line">provider.addIncludeFilter(<span class="keyword">new</span> AssignableTypeFilter(IConsumer.class));</div><div class="line">Set&lt;BeanDefinition&gt; beanDefinitionSet = provider.findCandidateComponents(<span class="string">"spring.study.componentprovider.bean"</span>);</div></pre></td></tr></table></figure>
<p>这里扫描出来的类只有2个，分别是ConsumerWithConsumerAnnotation(被@Consumer注解修饰)和ConsumerWithInterface(实现了IConsumer接口)。ConsumerWithComponentAnnotation使用@Component注解，ConsumerWithNothing没实现任何借口，没使用任何注解，ProducerWithInterface实现了IProducer接口；所以这3个类不会被识别。</p>
<p>如果我们要自定义ComponentProvider，继承ClassPathScanningCandidateComponentProvider类即可。</p>
<p>RepositoryComponentProvider这个类是SpringData模块提供的，继承自ClassPathScanningCandidateComponentProvider，主要是为了识别SpringData相关的类。</p>
<p>它内部定义了一些自定义TypeFilter，比如InterfaceTypeFilter(识别接口的TypeFilter，目标比较是个接口，而不是实现类)、AllTypeFilter(保存存储TypeList集合，这个集合内部所有的TypeFilter必须全部满足条件才能被识别)等。</p>
<p>有兴趣的读者可以查看源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们刚开始接触Spring的时候，要定义bean的话需要在xml中编写，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myBean&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;your.pkg.YourClass&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;后来发现如果bean比较多，会需要写很多的bean标签，太麻烦了。于是出现了一个component-scan注解。这个注解直接指定包名就可以，它会去扫描这个包下所有的class，然后判断是否解析：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;context:component-scan&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;base-package&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;your.pkg&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再后来，由于注解Annotation的流行，出现了@ComponentScan注解，作用跟component-scan标签一样，跟@Configuration注解配合使用：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@ComponentScan&lt;/span&gt;(basePackages = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;your.pkg&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;other.pkg&quot;&lt;/span&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Application&lt;/span&gt; &lt;/span&gt;&amp;#123; ... &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不论是component-scan标签，还是@ComponentScan注解。它们扫描或解析的bean只能是Spring内部所定义的，比如@Component、@Service、@Controller或@Repository。如果有一些自定义的注解，比如@Consumer、这个注解修饰的类是不会被扫描到的。这个时候我们就得自定义扫描器完成这个操作。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="http://fangjian0423.github.io/tags/spring/"/>
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之配置环境的构造过程</title>
    <link href="http://fangjian0423.github.io/2017/06/10/springboot-environment-analysis/"/>
    <id>http://fangjian0423.github.io/2017/06/10/springboot-environment-analysis/</id>
    <published>2017-06-10T11:30:30.000Z</published>
    <updated>2017-06-10T08:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot把配置文件的加载封装成了PropertySourceLoader接口，该接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertySourceLoader</span> </span>&#123;</div><div class="line">	<span class="comment">// 支持的文件后缀</span></div><div class="line">	String[] getFileExtensions();</div><div class="line">	<span class="comment">// 把资源Resource加载成属性源PropertySource</span></div><div class="line">	PropertySource&lt;?&gt; load(String name, Resource resource, String profile)</div><div class="line">			<span class="keyword">throws</span> IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PropertySource是Spring对name/value键值对的封装接口。该定义了getSource()方法，这个方法会返回得到属性源的源头。比如MapPropertySource的源头就是一个Map，PropertiesPropertySource的源头就是一个Properties。</p>
<p>PropertySource目前的实现类有不少，比如上面提到的MapPropertySource和PropertiesPropertySource，还有RandomValuePropertySource(source是Random)、SimpleCommandLinePropertySource(source是CommandLineArgs，命令行参数)、ServletConfigPropertySource(source是ServletConfig)等等。</p>
<p>PropertySourceLoader接口目前有两个实现类：PropertiesPropertySourceLoader和YamlPropertySourceLoader。</p>
<p>PropertiesPropertySourceLoader支持从xml或properties格式的文件中加载数据。</p>
<p>YamlPropertySourceLoader支持从yml或者yaml格式的文件中加载数据。</p>
<a id="more"></a>
<h2 id="Environment的构造以及PropertySource的生成"><a href="#Environment的构造以及PropertySource的生成" class="headerlink" title="Environment的构造以及PropertySource的生成"></a>Environment的构造以及PropertySource的生成</h2><p>Environment接口是Spring对当前程序运行期间的环境的封装。主要提供了两大功能：profile和property(父接口PropertyResolver提供)。目前主要有StandardEnvironment、StandardServletEnvironment和MockEnvironment3种实现，分别代表普通程序、Web程序以及测试程序的环境。</p>
<p>下面这段代码就是SpringBoot的run方法内调用的，它会在Spring容器构造之前调用，创建环境信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SpringApplication.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title">createAndRefreshContext</span><span class="params">(</span></span></div><div class="line">		SpringApplicationRunListeners listeners,</div><div class="line">		ApplicationArguments applicationArguments) &#123;</div><div class="line">	ConfigurableApplicationContext context;</div><div class="line">	<span class="comment">// 如果是web环境，创建StandardServletEnvironment</span></div><div class="line">	<span class="comment">// 否则，创建StandardEnvironment</span></div><div class="line">	<span class="comment">// StandardServletEnvironment继承自StandardEnvironment，StandardEnvironment继承AbstractEnvironment</span></div><div class="line">	<span class="comment">// AbstractEnvironment内部有个MutablePropertySources类型的propertySources属性，用于存储多个属性源PropertySource</span></div><div class="line">	<span class="comment">// StandardEnvironment构造的时候会默认加上2个PropertySource。分别是MapPropertySource(调用System.getProperties()配置)和SystemEnvironmentPropertySource(调用System.getenv()配置)</span></div><div class="line">	ConfigurableEnvironment environment = getOrCreateEnvironment();</div><div class="line">	<span class="comment">// 如果设置了一些启动参数args，添加基于args的SimpleCommandLinePropertySource</span></div><div class="line">	<span class="comment">// 还会配置profile信息，比如设置了spring.profiles.active启动参数，设置到环境信息中</span></div><div class="line">	configureEnvironment(environment, applicationArguments.getSourceArgs());</div><div class="line">	<span class="comment">// 触发ApplicationEnvironmentPreparedEvent事件</span></div><div class="line">	listeners.environmentPrepared(environment);</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a>这篇文章中，我们分析过SpringApplication启动的时候会使用<a href="http://fangjian0423.github.io/2017/06/05/springboot-factory-loading-mechanism/">工厂加载机制</a>初始化一些初始化器和监听器。其中org.springframework.boot.context.config.ConfigFileApplicationListener这个监听器会被加载：</p>
<pre><code>// spring-boot-version.release/META-INF/spring.factories
org.springframework.context.ApplicationListener=\
...
org.springframework.boot.context.config.ConfigFileApplicationListener,\
...
</code></pre><p>ConfigFileApplicationListener会监听SpringApplication启动的时候发生的事件，它的监听代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line">	<span class="comment">// 应用环境信息准备好的时候对应的事件。此时Spring容器尚未创建，但是环境已经创建</span></div><div class="line">	<span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</div><div class="line">		onApplicationEnvironmentPreparedEvent(</div><div class="line">				(ApplicationEnvironmentPreparedEvent) event);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Spring容器创建完成并在refresh方法调用之前对应的事件</span></div><div class="line">	<span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</div><div class="line">		onApplicationPreparedEvent(event);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationEnvironmentPreparedEvent</span><span class="params">(</span></span></div><div class="line">		ApplicationEnvironmentPreparedEvent event) &#123;</div><div class="line">	<span class="comment">// 使用工厂加载机制读取key为org.springframework.boot.env.EnvironmentPostProcessor的实现类</span></div><div class="line">	List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();</div><div class="line">	<span class="comment">// 加上自己。ConfigFileApplicationListener也是一个EnvironmentPostProcessor接口的实现类</span></div><div class="line">	postProcessors.add(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">// 排序</span></div><div class="line">	AnnotationAwareOrderComparator.sort(postProcessors);</div><div class="line">	<span class="comment">// 遍历这些EnvironmentPostProcessor，并调用postProcessEnvironment方法</span></div><div class="line">	<span class="keyword">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;</div><div class="line">		postProcessor.postProcessEnvironment(event.getEnvironment(),</div><div class="line">				event.getSpringApplication());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConfigFileApplicationListener也是一个EnvironmentPostProcessor接口的实现类，在这里会被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ConfigFileApplicationListener的postProcessEnvironment方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment,</span></span></div><div class="line">		SpringApplication application) &#123;</div><div class="line">	<span class="comment">// 添加属性源到环境中</span></div><div class="line">	addPropertySources(environment, application.getResourceLoader());</div><div class="line">	<span class="comment">// 配置需要ignore的beaninfo</span></div><div class="line">	configureIgnoreBeanInfo(environment);</div><div class="line">	<span class="comment">// 从环境中绑定一些参数到SpringApplication中</span></div><div class="line">	bindToSpringApplication(environment, application);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addPropertySources</span><span class="params">(ConfigurableEnvironment environment,</span></span></div><div class="line">		ResourceLoader resourceLoader) &#123;</div><div class="line">	<span class="comment">// 添加一个RandomValuePropertySource到环境中</span></div><div class="line">	<span class="comment">// RandomValuePropertySource是一个用于处理随机数的PropertySource，内部存储一个Random类的实例</span></div><div class="line">	RandomValuePropertySource.addToEnvironment(environment);</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 构造一个内部类Loader，并调用它的load方法</span></div><div class="line">		<span class="keyword">new</span> Loader(environment, resourceLoader).load();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load configuration files"</span>, ex);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部类Loader的处理过程整理如下：</p>
<ol>
<li>创建PropertySourcesLoader。PropertySourcesLoader内部有2个属性，分别是PropertySourceLoader集合和MutablePropertySources(内部有PropertySource的集合)。最终加载完毕之后MutablePropertySources属性中的PropertySource会被添加到环境Environment中的属性源列表中。PropertySourcesLoader被构造的时候会使用工厂加载机制获得PropertySourceLoader集合(默认就2个：PropertiesPropertySourceLoader和YamlPropertySourceLoader；可以自己扩展)，然后设置到属性中</li>
<li>获取环境信息中激活的profile(启动项目时设置的spring.profiles.active参数)。如果没设置profile，默认使用default这个profile，并添加到profiles队列中。最后会添加一个null到profiles队列中(为了获取没有指定profile的配置文件。比如环境中有application.yml和appliation-dev.yml，这个null就保证优先加载application.yml文件)</li>
<li>profiles队列取出profile数据，使用PropertySourcesLoader内部的各个PropertySourceLoader支持的后缀去目录(默认识别4种目录classpath:/[类加载目录],classpath:/config/[类加载目录下的config目录],file:./[当前目录],file:./config/[当前目录下的config目录])查找application文件名(这4个目录是默认的，可以通过启动参数spring.config.location添加新的目录，文件名可以通过启动参数spring.config.name修改)。比如目录是file:/，文件名是application，后缀为properties，那么就会查找file:/application.properties文件，如果找到，执行第4步</li>
<li>找出的属性源文件被加载，然后添加到PropertySourcesLoader内部的PropertySourceLoader集合中。如果该属性源文件中存在spring.profiles.active配置，识别出来并加入第2步中的profiles队列，然后重复第3步</li>
<li>第4步找到的属性源从PropertySourcesLoader中全部添加到环境信息Environment中。如果这些属性源存在defaultProperties配置，那么会添加到Environment中的属性源集合头部，否则添加到尾部</li>
</ol>
<p>比如项目中classpath下存在application.yml文件和application-dev.yml，application.yml文件的内容如下：</p>
<pre><code>spring.profiles.active: dev
</code></pre><p>直接启动项目，开始解析，过程如下：</p>
<ol>
<li>从环境信息中找出是否设置profile，发现没有设置。 添加默认的profile - default，然后添加到队列里，最后添加null的profile。此时profiles队列中有2个元素：default和null</li>
<li>profiles队列中先拿出null的profile。然后遍历4个目录和2个PropertySourceLoader中的4个后缀(PropertiesPropertySourceLoader的properties和xml以及YamlPropertySourceLoader的yml和yaml)的application文件名。file:./config/application.properties、file:./application.properties、classpath:/config/application.properties、classpath:/application.properties、file:./config/application.xml; file:./application.xml ….</li>
<li>找到classpath:/application.yml文件，解析成PropertySource并添加到PropertySourcesLoader里的MutablePropertySources中。由于该文件存在spring.profiles.active配置，把dev添加到profiles队列中</li>
<li>profiles队列拿出dev这个profile。由于存在profile，寻找文件的时候会带上profile，重复第3步，比如classpath:/application-dev.yml…</li>
<li>找到classpath:/application-dev.yml文件，解析成PropertySource并添加到PropertySourcesLoader里的MutablePropertySources中</li>
<li>profiles队列拿出default这个profile。寻找文件发现没有找到。结束</li>
</ol>
<p>这里需要注意一下一些常用的额外参数的问题，整理如下：</p>
<ol>
<li>如果启动程序的时候设置了系统参数spring.profiles.active，那么这个参数会被设置到环境信息中(由于设置了系统参数，在StandardEnvironment的钩子方法customizePropertySources中被封装成MapPropertySource并添加到Environment中)。这样PropertySourcesLoader加载的时候不会加上default这个默认profile，但是还是会读取profile为null的配置信息。spring.profiles.active支持多个profile，比如java -Dspring.profiles.active=”dev,custom” -jar yourjar.jar</li>
<li>如果设置程序参数spring.config.location，那么查找目录的时候会多出设置的目录，也支持多个目录的设置。这些会在SpringApplication里的configureEnvironment方法中被封装成SimpleCommandLinePropertySource并添加到Environment中。比如java -jar yourjar.jar –spring.config.location=classpath:/custom,file:./custom 1 2 3。有4个参数会被设置到SimpleCommandLinePropertySource中。解析文件的时候会多出2个目录，分别是classpath:/custom和file:./custom</li>
<li>如果设置程序参数spring.config.name，那么查找的文件名就是这个参数值。原理跟spring.config.location一样，都封装到了SimpleCommandLinePropertySource中。比如java -jar yourjar.jar –spring.config.name=myfile。 这样会去查找myfile文件，而不是默认的application文件</li>
<li>如果设置程序参数spring.profiles.active。注意这是程序参数，不是系统参数。比如java -jar yourjar.jar –spring.profiles.active=prod。会去解析prod这个profile(不论是系统参数还是程序参数，都会被封装成多个PropertySource存在于环境信息中。最终获取profile的时候会去环境信息中拿，且都可以拿到)</li>
<li>上面说的每个profile都是在不同文件里的。不同profile也可以存在在一个文件里。因为有profile会去加载带profile的文件的同时也会去加载不带profile的文件，并解析出这个文件中spring.profiles对应的值是profile的数据。比如profile为prod，会去查找application-prod.yml文件，也会去查找application.yml文件，其中application.yml文件只会查找spring.profiles为prod的数据</li>
</ol>
<p>比如第6点中profile.yml的数据如下：</p>
<pre><code>spring:
    profiles: prod
my.name: 1

---

spring:
    profiles: dev
my.name: 2
</code></pre><p>这里会解析出spring.profiles为prod的数据，也就是my.name为1的数据。</p>
<p>优先级的问题：由于环境信息Environment中保存的PropertySource是MutablePropertySources，那么会去配置值的时候就存在优先级的问题。比如PropertySource1和PropertySource2都存在custom.name配置，那么会从哪个PropertySource中获取这个custom.name配置呢？它会遍历内部的PropertySource列表，越在前面的PropertySource，越先获取；比如PropertySource1在PropertySource2前面，那么会先获取PropertySource1的配置。MutablePropertySources内部添加PropertySource的时候可以选择元素的位置，可以addFirst，也可以addLast，也可以自定义位置。</p>
<p>总结：SpringApplication启动的时候会构造环境信息Environment，如果是web环境，创建StandardServletEnvironment，否则，创建StandardEnvironment。这两种环境创建的时候都会在内部的propertySources属性中加入一些PropertySource。比如属性属性的配置信息封装成MapPropertySource，系统环境配置信息封装成SystemEnvironmentPropertySource等。这些PropertySource集合存在在环境信息中，从环境信息中读取配置的话会遍历这些PropertySource并找到相对应的配置和值。Environment构造完成之后会读取springboot相应的配置文件，从3个角度去查找：目录、文件名和profile。这3个角度有默认值，可以进行覆盖。springboot相关的配置文件读取完成之后会被封装成PropertySource并添加到环境信息中。</p>
<h2 id="ConfigurationProperties和-EnableConfigurationProperties注解的原理"><a href="#ConfigurationProperties和-EnableConfigurationProperties注解的原理" class="headerlink" title="@ConfigurationProperties和@EnableConfigurationProperties注解的原理"></a>@ConfigurationProperties和@EnableConfigurationProperties注解的原理</h2><p>SpringBoot内部规定了一套配置和配置属性类映射规则，可以使用@ConfigurationProperties注解配合前缀属性完成属性类的读取；再通过@EnableConfigurationProperties注解设置配置类就可以把这个配置类注入进来。</p>
<p>比如ES的配置类ElasticsearchProperties和对应的@EnableConfigurationProperties修饰的类ElasticsearchAutoConfiguration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用前缀为spring.data.elasticsearch的配置</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.data.elasticsearch"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchProperties</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String clusterName = <span class="string">"elasticsearch"</span>;</div><div class="line">	<span class="keyword">private</span> String clusterNodes;</div><div class="line">	<span class="keyword">private</span> Map&lt;String, String&gt; properties = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Client.class, TransportClientFactoryBean.class,</div><div class="line">		NodeClientFactoryBean.class &#125;)</div><div class="line"><span class="comment">// 使用@EnableConfigurationProperties注解让ElasticsearchProperties配置生效</span></div><div class="line"><span class="comment">// 这样ElasticsearchProperties就会自动注入到属性中</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(ElasticsearchProperties.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">	...</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> ElasticsearchProperties properties;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们分析下这个过程的实现。</p>
<p>@EnableConfigurationProperties注解有个属性value，是个Class数组，它会导入一个selector：EnableConfigurationPropertiesImportSelector。这个selector的selectImport方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</div><div class="line">	<span class="comment">// 获取@EnableConfigurationProperties注解的属性</span></div><div class="line">	MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(</div><div class="line">			EnableConfigurationProperties.class.getName(), <span class="keyword">false</span>);</div><div class="line">	<span class="comment">// 得到value属性，是个Class数组</span></div><div class="line">	Object[] type = attributes == <span class="keyword">null</span> ? <span class="keyword">null</span></div><div class="line">			: (Object[]) attributes.getFirst(<span class="string">"value"</span>);</div><div class="line">	<span class="keyword">if</span> (type == <span class="keyword">null</span> || type.length == <span class="number">0</span>) &#123; <span class="comment">// 如果value属性不存在</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;</div><div class="line">				<span class="comment">// 返回Registrar，Registrar内部会注册bean</span></div><div class="line">				ConfigurationPropertiesBindingPostProcessorRegistrar.class</div><div class="line">						.getName() &#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 如果value属性存在</span></div><div class="line">	<span class="comment">// 返回Registrar，Registrar内部会注册bean</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; ConfigurationPropertiesBeanRegistrar.class.getName(),</div><div class="line">			ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar都实现了ImportBeanDefinitionRegistrar接口，会额外注册bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ConfigurationPropertiesBeanRegistrar的registerBeanDefinitions方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></div><div class="line">		BeanDefinitionRegistry registry) &#123;</div><div class="line">	<span class="comment">// 获取@EnableConfigurationProperties注解中的属性值Class数组</span></div><div class="line">	MultiValueMap&lt;String, Object&gt; attributes = metadata</div><div class="line">			.getAllAnnotationAttributes(</div><div class="line">					EnableConfigurationProperties.class.getName(), <span class="keyword">false</span>);</div><div class="line">	List&lt;Class&lt;?&gt;&gt; types = collectClasses(attributes.get(<span class="string">"value"</span>));</div><div class="line">	<span class="comment">// 遍历这些Class数组</span></div><div class="line">	<span class="keyword">for</span> (Class&lt;?&gt; type : types) &#123;</div><div class="line">		<span class="comment">// 如果这个class被@ConfigurationProperties注解修饰</span></div><div class="line">		<span class="comment">// 获取@ConfigurationProperties注解中的前缀属性</span></div><div class="line">		<span class="comment">// 否则该前缀为空字符串</span></div><div class="line">		String prefix = extractPrefix(type);</div><div class="line">		<span class="comment">// 构造bean的名字： 前缀-类全名</span></div><div class="line">		<span class="comment">// 比如ElasticsearchProperties对应的bean名字就是spring.data.elasticsearch-org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchProperties</span></div><div class="line">		String name = (StringUtils.hasText(prefix) ? prefix + <span class="string">"-"</span> + type.getName()</div><div class="line">				: type.getName());</div><div class="line">		<span class="keyword">if</span> (!registry.containsBeanDefinition(name)) &#123;</div><div class="line">			<span class="comment">// 这个bean没被注册的话进行注册</span></div><div class="line">			registerBeanDefinition(registry, type, name);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessorRegistrar的registerBeanDefinitions方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span></div><div class="line">		BeanDefinitionRegistry registry) &#123;</div><div class="line">	<span class="comment">// 先判断Spring容器里是否有ConfigurationPropertiesBindingPostProcessor类型的bean</span></div><div class="line">	<span class="comment">// 由于条件里面会判断是否已经存在这个ConfigurationPropertiesBindingPostProcessor类型的bean</span></div><div class="line">	<span class="comment">// 所以实际上条件里的代码只会执行一次</span></div><div class="line">	<span class="keyword">if</span> (!registry.containsBeanDefinition(BINDER_BEAN_NAME)) &#123;</div><div class="line">		BeanDefinitionBuilder meta = BeanDefinitionBuilder</div><div class="line">				.genericBeanDefinition(ConfigurationBeanFactoryMetaData.class);</div><div class="line">		BeanDefinitionBuilder bean = BeanDefinitionBuilder.genericBeanDefinition(</div><div class="line">				ConfigurationPropertiesBindingPostProcessor.class);</div><div class="line">		bean.addPropertyReference(<span class="string">"beanMetaDataStore"</span>, METADATA_BEAN_NAME);</div><div class="line">		registry.registerBeanDefinition(BINDER_BEAN_NAME, bean.getBeanDefinition());</div><div class="line">		registry.registerBeanDefinition(METADATA_BEAN_NAME, meta.getBeanDefinition());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConfigurationPropertiesBindingPostProcessor在ConfigurationPropertiesBindingPostProcessorRegistrar中被注册到Spring容器中，它是一个BeanPostProcessor，它的postProcessBeforeInitialization方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Spring容器中bean被实例化之前要做的事</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">		<span class="keyword">throws</span> BeansException &#123;</div><div class="line">	<span class="comment">// 先获取bean对应的Class中的@ConfigurationProperties注解</span></div><div class="line">	ConfigurationProperties annotation = AnnotationUtils</div><div class="line">			.findAnnotation(bean.getClass(), ConfigurationProperties.class);</div><div class="line">	<span class="comment">// 如果@ConfigurationProperties注解，说明这是一个配置类。比如ElasticsearchProperties</span></div><div class="line">	<span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 调用postProcessBeforeInitialization方法</span></div><div class="line">		postProcessBeforeInitialization(bean, beanName, annotation);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 同样的方法使用beanName去查找</span></div><div class="line">	annotation = <span class="keyword">this</span>.beans.findFactoryAnnotation(beanName,</div><div class="line">			ConfigurationProperties.class);</div><div class="line">	<span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</div><div class="line">		postProcessBeforeInitialization(bean, beanName, annotation);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> bean;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName,</span></span></div><div class="line">		ConfigurationProperties annotation) &#123;</div><div class="line">	Object target = bean;</div><div class="line">	<span class="comment">// 构造一个PropertiesConfigurationFactory</span></div><div class="line">	PropertiesConfigurationFactory&lt;Object&gt; factory = <span class="keyword">new</span> PropertiesConfigurationFactory&lt;Object&gt;(</div><div class="line">			target);</div><div class="line">	<span class="comment">// 设置属性源，这里的属性源从环境信息Environment中得到</span></div><div class="line">	factory.setPropertySources(<span class="keyword">this</span>.propertySources);</div><div class="line">	<span class="comment">// 设置验证器</span></div><div class="line">	factory.setValidator(determineValidator(bean));</div><div class="line">	<span class="comment">// 设置ConversionService</span></div><div class="line">	factory.setConversionService(<span class="keyword">this</span>.conversionService == <span class="keyword">null</span></div><div class="line">			? getDefaultConversionService() : <span class="keyword">this</span>.conversionService);</div><div class="line">	<span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">// 设置@ConfigurationProperties注解对应的属性到PropertiesConfigurationFactory中</span></div><div class="line">		<span class="comment">// 比如是否忽略不合法的属性ignoreInvalidFields、忽略未知的字段、忽略嵌套属性、验证器验证不合法后是否抛出异常</span></div><div class="line">		factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields());</div><div class="line">		factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields());</div><div class="line">		factory.setExceptionIfInvalid(annotation.exceptionIfInvalid());</div><div class="line">		factory.setIgnoreNestedProperties(annotation.ignoreNestedProperties());</div><div class="line">		<span class="keyword">if</span> (StringUtils.hasLength(annotation.prefix())) &#123;</div><div class="line">			<span class="comment">// 设置前缀</span></div><div class="line">			factory.setTargetName(annotation.prefix());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// 绑定属性到配置类中，比如ElasticsearchProperties</span></div><div class="line">		<span class="comment">// 会使用环境信息中的属性源进行绑定</span></div><div class="line">		<span class="comment">// 这样配置类就读取到了配置文件中的配置</span></div><div class="line">		factory.bindPropertiesToTarget();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">		String targetClass = ClassUtils.getShortName(target.getClass());</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Could not bind properties to "</span></div><div class="line">				+ targetClass + <span class="string">" ("</span> + getAnnotationDetails(annotation) + <span class="string">")"</span>, ex);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：SpringBoot内部规定了一套配置和配置属性类映射规则，可以使用@ConfigurationProperties注解配合前缀属性完成属性类的读取；再通过@EnableConfigurationProperties注解设置配置类就可以把这个配置类注入进来。由于这个配置类是被注入进来的，所以它肯定在Spring容器中存在；这是因为在ConfigurationPropertiesBeanRegistrar内部会注册配置类到Spring容器中，这个配置类的实例化过程在ConfigurationPropertiesBindingPostProcessor这个BeanPostProcessor完成，它会在实例化bean之前会判断bean是否被@ConfigurationProperties注解修饰，如果有，使用PropertiesConfigurationFactory从环境信息Environment中进行值的绑定。这个ConfigurationPropertiesBeanRegistrar是在使用@EnableConfigurationProperties注解的时候被创建的(通过EnableConfigurationPropertiesImportSelector)。配置类内部属性的绑定成功与否是通过环境信息Environment中的属性源PropertySource决定的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot把配置文件的加载封装成了PropertySourceLoader接口，该接口的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PropertySourceLoader&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 支持的文件后缀&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	String[] getFileExtensions();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 把资源Resource加载成属性源PropertySource&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	PropertySource&amp;lt;?&amp;gt; load(String name, Resource resource, String profile)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PropertySource是Spring对name/value键值对的封装接口。该定义了getSource()方法，这个方法会返回得到属性源的源头。比如MapPropertySource的源头就是一个Map，PropertiesPropertySource的源头就是一个Properties。&lt;/p&gt;
&lt;p&gt;PropertySource目前的实现类有不少，比如上面提到的MapPropertySource和PropertiesPropertySource，还有RandomValuePropertySource(source是Random)、SimpleCommandLinePropertySource(source是CommandLineArgs，命令行参数)、ServletConfigPropertySource(source是ServletConfig)等等。&lt;/p&gt;
&lt;p&gt;PropertySourceLoader接口目前有两个实现类：PropertiesPropertySourceLoader和YamlPropertySourceLoader。&lt;/p&gt;
&lt;p&gt;PropertiesPropertySourceLoader支持从xml或properties格式的文件中加载数据。&lt;/p&gt;
&lt;p&gt;YamlPropertySourceLoader支持从yml或者yaml格式的文件中加载数据。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析系列</title>
    <link href="http://fangjian0423.github.io/2017/06/05/springboot-source-analysis-summary/"/>
    <id>http://fangjian0423.github.io/2017/06/05/springboot-source-analysis-summary/</id>
    <published>2017-06-05T11:40:30.000Z</published>
    <updated>2017-08-23T07:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己总结和学习的SpringBoot源码，包括一些例子代码和文章。</p>
<p>本系列不涉及SpringBoot的入门，主要针对想深入学习SpringBoot的读者。</p>
<p>目前已经有的文章：</p>
<ol>
<li><a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a></li>
<li><a href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/">SpringBoot源码分析之Spring容器的refresh过程</a></li>
<li><a href="http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/">SpringBoot源码分析之条件注解的底层实现</a></li>
<li><a href="http://fangjian0423.github.io/2017/05/22/springboot-embedded-servlet-container/">SpringBoot源码分析之内置Servlet容器</a></li>
<li><a href="http://fangjian0423.github.io/2017/05/31/springboot-executable-jar/">SpringBoot源码分析之SpringBoot可执行文件解析</a></li>
<li><a href="http://fangjian0423.github.io/2017/06/05/springboot-factory-loading-mechanism">SpringBoot源码分析之工厂加载机制</a></li>
<li><a href="http://fangjian0423.github.io/2017/06/10/springboot-environment-analysis">SpringBoot源码分析之配置环境的构造过程</a></li>
<li><a href="http://fangjian0423.github.io/2017/08/23/springboot-logging-system/">SpringBoot源码分析之日志系统的构造</a></li>
</ol>
<p>另外也会写一些Spring和SpringBoot相关的文章。</p>
<p>Spring：</p>
<ol>
<li><a href="http://fangjian0423.github.io/2017/06/11/spring-custom-component-provider/">Spring自定义类扫描器</a></li>
<li><a href="http://fangjian0423.github.io/2017/06/15/spring-bean-register-note/">Spring类注册笔记</a></li>
<li><a href="http://fangjian0423.github.io/2017/06/20/spring-bean-post-processor/">Spring内部的BeanPostProcessor接口总结</a></li>
<li><a href="http://fangjian0423.github.io/2017/06/24/spring-embedded-bean-post-processor/">Spring内置的BeanPostProcessor总结</a></li>
</ol>
<p>SpringBoot：</p>
<ol>
<li><a href="http://fangjian0423.github.io/2017/06/28/springboot-application-exit/">SpringBoot应用程序的关闭</a></li>
</ol>
<p>会写一些例子记录学习的过程，上传到<a href="https://github.com/fangjian0423/springboot-analysis" target="_blank" rel="external">github</a>。</p>
<p>我不能保证写的每个地方都是对的，有问题的地方还请指出来，一起学习!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己总结和学习的SpringBoot源码，包括一些例子代码和文章。&lt;/p&gt;
&lt;p&gt;本系列不涉及SpringBoot的入门，主要针对想深入学习SpringBoot的读者。&lt;/p&gt;
&lt;p&gt;目前已经有的文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://fangji
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之工厂加载机制</title>
    <link href="http://fangjian0423.github.io/2017/06/05/springboot-factory-loading-mechanism/"/>
    <id>http://fangjian0423.github.io/2017/06/05/springboot-factory-loading-mechanism/</id>
    <published>2017-06-05T11:30:30.000Z</published>
    <updated>2017-06-05T12:15:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的一些文章中，我们提到过从spring.factories中找出key为XXX的类。比如@EnableAutoConfiguration注解对应的EnableAutoConfigurationImportSelector中的selectImport方法会在spring.factories文件中找出key为EnableAutoConfiguration对应的值。这些类都是自动化配置类：</p>
<pre><code>// 这个spring.factories文件在spring-boot-autoconfigure模块的 META-INF/spring.factories中
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
......
</code></pre><a id="more"></a>
<p>代码的实现，EnableAutoConfigurationImportSelector的selectImport方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 获取注解的属性</span></div><div class="line">    AnnotationAttributes attributes = getAttributes(metadata);</div><div class="line">    <span class="comment">// 读取spring.factories属性文件中的数据</span></div><div class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(metadata,</div><div class="line">        attributes);</div><div class="line">    <span class="comment">// 删除重复的配置类</span></div><div class="line">    configurations = removeDuplicates(configurations);</div><div class="line">    <span class="comment">// 找到@EnableAutoConfiguration注解中定义的需要被过滤的配置类</span></div><div class="line">    Set&lt;String&gt; exclusions = getExclusions(metadata, attributes);</div><div class="line">    <span class="comment">// 删除这些需要被过滤的配置类</span></div><div class="line">    configurations.removeAll(exclusions);</div><div class="line">    <span class="comment">// 配置类做排序</span></div><div class="line">    configurations = sort(configurations);</div><div class="line">    <span class="comment">// 记录配置类的处理信息到ConditionEvaluationReport中</span></div><div class="line">    recordWithConditionEvaluationReport(configurations, exclusions);</div><div class="line">    <span class="comment">// 返回最终得到的自动化配置类</span></div><div class="line">    <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></div><div class="line">    AnnotationAttributes attributes) &#123;</div><div class="line">  <span class="comment">// 调用SpringFactoriesLoader的loadFactoryNames静态方法</span></div><div class="line">  <span class="comment">// getSpringFactoriesLoaderFactoryClass方法返回的是EnableAutoConfiguration类对象</span></div><div class="line">  <span class="keyword">return</span> SpringFactoriesLoader.loadFactoryNames(</div><div class="line">      getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</div><div class="line">  <span class="comment">// 解析出properties文件中需要的key值</span></div><div class="line">  String factoryClassName = factoryClass.getName();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 常量FACTORIES_RESOURCE_LOCATION的值为META-INF/spring.factories</span></div><div class="line">    <span class="comment">// 使用类加载器找META-INF/spring.factories资源</span></div><div class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</div><div class="line">        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</div><div class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    <span class="comment">// 遍历找到的资源</span></div><div class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</div><div class="line">      URL url = urls.nextElement();</div><div class="line">      <span class="comment">// 使用属性文件加载资源</span></div><div class="line">      Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</div><div class="line">      <span class="comment">// 找出key为参数factoryClass类对象对应的全名称对应的值</span></div><div class="line">      String factoryClassNames = properties.getProperty(factoryClassName);</div><div class="line">      <span class="comment">// 以逗号分隔添加到结果集中</span></div><div class="line">      result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load ["</span> + factoryClass.getName() +</div><div class="line">        <span class="string">"] factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring Framework内部使用一种<strong>工厂加载机制(Factory Loading Mechanism)</strong>。这种机制使用SpringFactoriesLoader完成，SpringFactoriesLoader使用loadFactories方法加载并实例化从META-INF目录里的spring.factories文件出来的工厂，这些spring.factories文件都是从classpath里的jar包里找出来的。</p>
<p>spring.factories文件是以Java的Properties格式存在，key是接口或抽象类的全名、value是以逗号 “ , “ 分隔的实现类，比如：</p>
<pre><code>example.MyService=example.MyServiceImpl1,example.MyServiceImpl2
</code></pre><p>其中example.MyService是接口的全名，example.MyServiceImpl1和example.MyServiceImpl2是这个接口的两种实现。</p>
<p>可通过SpringFactoriesLoader完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; classes = SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, <span class="keyword">this</span>.getClass().getClassLoader());</div><div class="line">classes.forEach(clazz -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"==== "</span> + clazz);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>总结：</p>
<p>工厂加载机制是Spring内部提供的一个约定俗成的加载方式。只需要在模块的META-INF目录下定义Properties格式的spring.factories文件，这个Properties格式的文件中的key是接口或抽象类的全名，value是以逗号 “ , “ 分隔的实现类。</p>
<p>SpringBoot中的autoconfigure模块中的spring.factories就存在于META-INF目录下：</p>
<pre><code>├── META-INF
│   ├── MANIFEST.MF
│   ├── additional-spring-configuration-metadata.json
│   ├── maven
│   │   └── org.springframework.boot
│   │       └── spring-boot-autoconfigure
│   │           ├── pom.properties
│   │           └── pom.xml
│   ├── spring-configuration-metadata.json
│   └── spring.factories
├── org
│   └── springframework
│       └── boot
│           └── autoconfigure
│               ├── AbstractDependsOnBeanFactoryPostProcessor.class
....
</code></pre><p>而且也定义了一些配置，比如自动化配置信息：</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=...
</code></pre><p>应用初始化器：</p>
<pre><code>org.springframework.context.ApplicationContextInitializer=...
</code></pre><p>应用监听器：</p>
<pre><code>org.springframework.context.ApplicationListener=...
</code></pre><p>模板可用提供器：</p>
<pre><code>org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=...
</code></pre><p>等等。</p>
<p>我们只需要遵守这个机制并在对应的文件中写出需要加载的接口和实例即可，或者自己使用SpringFactoriesLoader实现加载。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的一些文章中，我们提到过从spring.factories中找出key为XXX的类。比如@EnableAutoConfiguration注解对应的EnableAutoConfigurationImportSelector中的selectImport方法会在spring.factories文件中找出key为EnableAutoConfiguration对应的值。这些类都是自动化配置类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这个spring.factories文件在spring-boot-autoconfigure模块的 META-INF/spring.factories中
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
......
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringData ES中一些底层原理的分析</title>
    <link href="http://fangjian0423.github.io/2017/06/02/spring-data-es-analysis/"/>
    <id>http://fangjian0423.github.io/2017/06/02/spring-data-es-analysis/</id>
    <published>2017-06-02T12:33:33.000Z</published>
    <updated>2017-06-02T15:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇<a href="http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/">SpringData ES 关于字段名和索引中的列名字不一致导致的查询问题</a>，顺便深入学习下Spring Data Elasticsearch。</p>
<p><a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="external">Spring Data Elasticsearch</a>是<a href="http://projects.spring.io/spring-data/" target="_blank" rel="external">Spring Data</a>针对Elasticsearch的实现。</p>
<p>它跟Spring Data一样，提供了Repository接口，我们只需要定义一个新的接口并继承这个Repository接口，然后就可以注入这个新的接口使用了。</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Task</span>, <span class="title">String</span>&gt; </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>注入接口进行使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> TaskRepository taskRepository;</div><div class="line"></div><div class="line">....</div><div class="line">taskRepository.save(task);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Repository接口的代理生成"><a href="#Repository接口的代理生成" class="headerlink" title="Repository接口的代理生成"></a>Repository接口的代理生成</h2><p>上面的例子中TaskRepository是个接口，而我们却直接注入了这个接口并调用方法；很明显，这是错误的。</p>
<p>其实SpringData ES内部基于这个TaskRepository接口构造一个SimpleElasticsearchRepository，真正被注入的是这个SimpleElasticsearchRepository。</p>
<p>这个过程是如何实现的呢？  来分析一下。</p>
<p>ElasticsearchRepositoriesAutoConfiguration自动化配置类会导入ElasticsearchRepositoriesRegistrar这个ImportBeanDefinitionRegistrar。</p>
<p>ElasticsearchRepositoriesRegistrar继承自AbstractRepositoryConfigurationSourceSupport，是个ImportBeanDefinitionRegistrar接口的实现类，会被Spring容器调用registerBeanDefinitions进行自定义bean的注册。</p>
<p>ElasticsearchRepositoriesRegistrar委托给RepositoryConfigurationDelegate完成bean的解析。</p>
<p>整个解析过程可以分3个步骤：</p>
<ol>
<li>找出模块中的org.springframework.data.repository.Repository接口的实现类或者org.springframework.data.repository.RepositoryDefinition注解的修饰类，并会过滤掉org.springframework.data.repository.NoRepositoryBean注解的修饰类。找出后封装到RepositoryConfiguration中</li>
<li>遍历这些RepositoryConfiguration，然后构造成BeanDefinition并注册到Spring容器中。需要注意的是这些RepositoryConfiguration会以beanClass为ElasticsearchRepositoryFactoryBean这个类的方式被注册，并把对应的Repository接口当做构造参数传递给ElasticsearchRepositoryFactoryBean，还会设置相应的属性比如elasticsearchOperations、evaluationContextProvider、namedQueries、repositoryBaseClass、lazyInit、queryLookupStrategyKey</li>
<li>ElasticsearchRepositoryFactoryBean被实例化的时候设置对应的构造参数和属性。设置完毕以后调用afterPropertiesSet方法(实现了InitializingBean接口)。在afterPropertiesSet方法内部会去创建RepositoryFactorySupport类，并进行一些初始化，比如namedQueries、repositoryBaseClass等。然后通过这个RepositoryFactorySupport的getRepository方法基于Repository接口创建出代理类，并使用AOP添加了几个MethodInterceptor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历基于第1步条件得到的RepositoryConfiguration集合</span></div><div class="line"><span class="keyword">for</span> (RepositoryConfiguration&lt;? extends RepositoryConfigurationSource&gt; configuration : extension</div><div class="line">    .getRepositoryConfigurations(configurationSource, resourceLoader, inMultiStoreMode)) &#123;</div><div class="line">  <span class="comment">// 构造出BeanDefinitionBuilder</span></div><div class="line">  BeanDefinitionBuilder definitionBuilder = builder.build(configuration);</div><div class="line"></div><div class="line">  extension.postProcess(definitionBuilder, configurationSource);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isXml) &#123;</div><div class="line">    <span class="comment">// 设置elasticsearchOperations属性</span></div><div class="line">    extension.postProcess(definitionBuilder, (XmlRepositoryConfigurationSource) configurationSource);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 设置elasticsearchOperations属性</span></div><div class="line">    extension.postProcess(definitionBuilder, (AnnotationRepositoryConfigurationSource) configurationSource);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 使用命名策略生成bean的名字</span></div><div class="line">  AbstractBeanDefinition beanDefinition = definitionBuilder.getBeanDefinition();</div><div class="line">  String beanName = beanNameGenerator.generateBeanName(beanDefinition, registry);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class="line">    LOGGER.debug(REPOSITORY_REGISTRATION, extension.getModuleName(), beanName,</div><div class="line">        configuration.getRepositoryInterface(), extension.getRepositoryFactoryClassName());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  beanDefinition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, configuration.getRepositoryInterface());</div><div class="line">  <span class="comment">// 注册到Spring容器中</span></div><div class="line">  registry.registerBeanDefinition(beanName, beanDefinition);</div><div class="line">  definitions.add(<span class="keyword">new</span> BeanComponentDefinition(beanDefinition, beanName));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// build方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionBuilder <span class="title">build</span><span class="params">(RepositoryConfiguration&lt;?&gt; configuration)</span> </span>&#123;</div><div class="line"></div><div class="line">  Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null!"</span>);</div><div class="line">  Assert.notNull(resourceLoader, <span class="string">"ResourceLoader must not be null!"</span>);</div><div class="line">  <span class="comment">// 得到factoryBeanName，这里会使用extension.getRepositoryFactoryClassName()去获得</span></div><div class="line">  <span class="comment">// extension.getRepositoryFactoryClassName()返回的正是ElasticsearchRepositoryFactoryBean</span></div><div class="line">  String factoryBeanName = configuration.getRepositoryFactoryBeanName();</div><div class="line">  factoryBeanName = StringUtils.hasText(factoryBeanName) ? factoryBeanName</div><div class="line">      : extension.getRepositoryFactoryClassName();</div><div class="line">  <span class="comment">// 基于factoryBeanName构造BeanDefinitionBuilder</span></div><div class="line">  BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(factoryBeanName);</div><div class="line"></div><div class="line">  builder.getRawBeanDefinition().setSource(configuration.getSource());</div><div class="line">  <span class="comment">// 设置ElasticsearchRepositoryFactoryBean的构造参数，这里是对应的Repository接口</span></div><div class="line">  <span class="comment">// 设置一些的属性值</span></div><div class="line">  builder.addConstructorArgValue(configuration.getRepositoryInterface());</div><div class="line">  builder.addPropertyValue(<span class="string">"queryLookupStrategyKey"</span>, configuration.getQueryLookupStrategyKey());</div><div class="line">  builder.addPropertyValue(<span class="string">"lazyInit"</span>, configuration.isLazyInit());</div><div class="line">  builder.addPropertyValue(<span class="string">"repositoryBaseClass"</span>, configuration.getRepositoryBaseClassName());</div><div class="line"></div><div class="line">  NamedQueriesBeanDefinitionBuilder definitionBuilder = <span class="keyword">new</span> NamedQueriesBeanDefinitionBuilder(</div><div class="line">      extension.getDefaultNamedQueryLocation());</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (StringUtils.hasText(configuration.getNamedQueriesLocation())) &#123;</div><div class="line">    definitionBuilder.setLocations(configuration.getNamedQueriesLocation());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  builder.addPropertyValue(<span class="string">"namedQueries"</span>, definitionBuilder.build(configuration.getSource()));</div><div class="line">  <span class="comment">// 查找是否有对应Repository接口的自定义实现类</span></div><div class="line">  String customImplementationBeanName = registerCustomImplementation(configuration);</div><div class="line">  <span class="comment">// 存在自定义实现类的话，设置到属性中</span></div><div class="line">  <span class="keyword">if</span> (customImplementationBeanName != <span class="keyword">null</span>) &#123;</div><div class="line">    builder.addPropertyReference(<span class="string">"customImplementation"</span>, customImplementationBeanName);</div><div class="line">    builder.addDependsOn(customImplementationBeanName);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  RootBeanDefinition evaluationContextProviderDefinition = <span class="keyword">new</span> RootBeanDefinition(</div><div class="line">      ExtensionAwareEvaluationContextProvider.class);</div><div class="line">  evaluationContextProviderDefinition.setSource(configuration.getSource());</div><div class="line">  <span class="comment">// 设置一些的属性值</span></div><div class="line">  builder.addPropertyValue(<span class="string">"evaluationContextProvider"</span>, evaluationContextProviderDefinition);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> builder;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RepositoryFactorySupport的getRepository方法，获得Repository接口的代理类</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getRepository</span><span class="params">(Class&lt;T&gt; repositoryInterface, Object customImplementation)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 获取Repository的元数据</span></div><div class="line">  RepositoryMetadata metadata = getRepositoryMetadata(repositoryInterface);</div><div class="line">  <span class="comment">// 获取Repository的自定义实现类</span></div><div class="line">  Class&lt;?&gt; customImplementationClass = <span class="keyword">null</span> == customImplementation ? <span class="keyword">null</span> : customImplementation.getClass();</div><div class="line">  <span class="comment">// 根据元数据和自定义实现类得到Repository的RepositoryInformation信息类</span></div><div class="line">  <span class="comment">// 获取信息类的时候如果发现repositoryBaseClass是空的话会根据meta中的信息去自动匹配</span></div><div class="line">  <span class="comment">// 具体匹配过程在下面的getRepositoryBaseClass方法中说明</span></div><div class="line">  RepositoryInformation information = getRepositoryInformation(metadata, customImplementationClass);</div><div class="line">  <span class="comment">// 验证</span></div><div class="line">  validate(information, customImplementation);</div><div class="line">  <span class="comment">// 得到最终的目标类实例，会通过repositoryBaseClass去查找</span></div><div class="line">  Object target = getTargetRepository(information);</div><div class="line"></div><div class="line">  <span class="comment">// 创建代理工厂</span></div><div class="line">  ProxyFactory result = <span class="keyword">new</span> ProxyFactory();</div><div class="line">  result.setTarget(target);</div><div class="line">  result.setInterfaces(<span class="keyword">new</span> Class[] &#123; repositoryInterface, Repository.class &#125;);</div><div class="line">  <span class="comment">// 进行aop相关的设置</span></div><div class="line">  result.addAdvice(SurroundingTransactionDetectorMethodInterceptor.INSTANCE);</div><div class="line">  result.addAdvisor(ExposeInvocationInterceptor.ADVISOR);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (TRANSACTION_PROXY_TYPE != <span class="keyword">null</span>) &#123;</div><div class="line">    result.addInterface(TRANSACTION_PROXY_TYPE);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 使用RepositoryProxyPostProcessor处理</span></div><div class="line">  <span class="keyword">for</span> (RepositoryProxyPostProcessor processor : postProcessors) &#123;</div><div class="line">    processor.postProcess(result, information);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (IS_JAVA_8) &#123;</div><div class="line">    <span class="comment">// 如果是JDK8的话，添加DefaultMethodInvokingMethodInterceptor</span></div><div class="line">    result.addAdvice(<span class="keyword">new</span> DefaultMethodInvokingMethodInterceptor());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 添加QueryExecutorMethodInterceptor</span></div><div class="line">  result.addAdvice(<span class="keyword">new</span> QueryExecutorMethodInterceptor(information, customImplementation, target));</div><div class="line">  <span class="comment">// 使用代理工厂创建出代理类，这里是使用jdk内置的代理模式</span></div><div class="line">  <span class="keyword">return</span> (T) result.getProxy(classLoader);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 目标类的获取</span></div><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) &#123;</div><div class="line">  <span class="comment">// 如果Repository接口属于QueryDsl，抛出异常。目前还不支持</span></div><div class="line">  <span class="keyword">if</span> (isQueryDslRepository(metadata.getRepositoryInterface())) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"QueryDsl Support has not been implemented yet."</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 如果主键是数值类型的话，repositoryBaseClass为NumberKeyedRepository</span></div><div class="line">  <span class="keyword">if</span> (Integer.class.isAssignableFrom(metadata.getIdType())</div><div class="line">      || Long.class.isAssignableFrom(metadata.getIdType())</div><div class="line">      || Double.class.isAssignableFrom(metadata.getIdType())) &#123;</div><div class="line">    <span class="keyword">return</span> NumberKeyedRepository.class;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metadata.getIdType() == String.class) &#123;</div><div class="line">    <span class="comment">// 如果主键是String类型的话，repositoryBaseClass为SimpleElasticsearchRepository</span></div><div class="line">    <span class="keyword">return</span> SimpleElasticsearchRepository.class;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metadata.getIdType() == UUID.class) &#123;</div><div class="line">    <span class="comment">// 如果主键是UUID类型的话，repositoryBaseClass为UUIDElasticsearchRepository</span></div><div class="line">    <span class="keyword">return</span> UUIDElasticsearchRepository.class;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 否则报错</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported ID type "</span> + metadata.getIdType());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ElasticsearchRepositoryFactoryBean是一个FactoryBean接口的实现类，getObject方法返回的上面提到的getRepository方法返回的代理对象；getObjectType方法返回的是对应Repository接口类型。</p>
<p>我们文章一开始提到的注入TaskRepository的时候，实际上这个对象是ElasticsearchRepositoryFactoryBean类型的实例，只不过ElasticsearchRepositoryFactoryBean实现了FactoryBean接口，所以注入的时候会得到一个代理对象，这个代理对象是由jdk内置的代理生成的，并且它的target对象是SimpleElasticsearchRepository(主键是String类型)。</p>
<h2 id="SpringData-ES中ElasticsearchOperations的介绍"><a href="#SpringData-ES中ElasticsearchOperations的介绍" class="headerlink" title="SpringData ES中ElasticsearchOperations的介绍"></a>SpringData ES中ElasticsearchOperations的介绍</h2><p>ElasticsearchTemplate实现了ElasticsearchOperations接口。</p>
<p>ElasticsearchOperations接口是SpringData对Elasticsearch操作的一层封装，比如有创建索引createIndex方法、获取索引的设置信息getSetting方法、查询对象queryForObject方法、分页查询方法queryForPage、删除文档delete方法、更新文档update方法等等。</p>
<p>ElasticsearchTemplate是具体的实现类，它有这些属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// elasticsearch提供的基于java的客户端连接接口。java对es集群的操作使用这个接口完成</span></div><div class="line"><span class="keyword">private</span> Client client;</div><div class="line"><span class="comment">// 一个转换器接口，定义了2个方法，分别可以获得MappingContext和ConversionService</span></div><div class="line"><span class="comment">// MappingContext接口用于获取所有的持久化实体和这些实体的属性</span></div><div class="line"><span class="comment">// ConversionService目前在SpringData ES中没有被使用</span></div><div class="line"><span class="keyword">private</span> ElasticsearchConverter elasticsearchConverter;</div><div class="line"><span class="comment">// 内部使用EntityMapper完成对象到json字符串和json字符串到对象的映射。默认使用jackson完成映射，可自定义</span></div><div class="line"><span class="keyword">private</span> ResultsMapper resultsMapper;</div><div class="line"><span class="comment">// 查询超时时间</span></div><div class="line"><span class="keyword">private</span> String searchTimeout;</div></pre></td></tr></table></figure>
<p>Client接口在ElasticsearchAutoConfiguration自动化配置类里被构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">elasticsearchClient</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> createClient();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ElasticsearchTemplate、ElasticsearchConverter以及SimpleElasticsearchMappingContext在ElasticsearchDataAutoConfiguration自动化配置类里被构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ElasticsearchTemplate <span class="title">elasticsearchTemplate</span><span class="params">(Client client,</span></span></div><div class="line">    ElasticsearchConverter converter) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElasticsearchTemplate(client, converter);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ElasticsearchConverter <span class="title">elasticsearchConverter</span><span class="params">(</span></span></div><div class="line">    SimpleElasticsearchMappingContext mappingContext) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MappingElasticsearchConverter(mappingContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span></div><div class="line"><span class="function"><span class="keyword">public</span> SimpleElasticsearchMappingContext <span class="title">mappingContext</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SimpleElasticsearchMappingContext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是这个bean被自动化配置类构造的前提是它们在Spring容器中并不存在。</p>
<h2 id="Repository的调用过程"><a href="#Repository的调用过程" class="headerlink" title="Repository的调用过程"></a>Repository的调用过程</h2><p>以自定义的TaskRepository的save方法为例，大致的执行流程如下所示：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/SpringData-ES-seq.png" alt=""></p>
<p>SimpleElasticsearchRepository的save方法具体的分析在<a href="http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/">SpringData ES 关于字段名和索引中的列名字不一致导致的查询问题</a>中分析过。</p>
<p>像自定义的Repository查询方法，或者Repository接口的自定义实现类的操作这些底层，可以去QueryExecutorMethodInterceptor中查看，本文就不做具体分析了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇&lt;a href=&quot;http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/&quot;&gt;SpringData ES 关于字段名和索引中的列名字不一致导致的查询问题&lt;/a&gt;，顺便深入学习下Spring Data Elasticsearch。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-data-elasticsearch&quot;&gt;Spring Data Elasticsearch&lt;/a&gt;是&lt;a href=&quot;http://projects.spring.io/spring-data/&quot;&gt;Spring Data&lt;/a&gt;针对Elasticsearch的实现。&lt;/p&gt;
&lt;p&gt;它跟Spring Data一样，提供了Repository接口，我们只需要定义一个新的接口并继承这个Repository接口，然后就可以注入这个新的接口使用了。&lt;/p&gt;
&lt;p&gt;定义接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Repository&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TaskRepository&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ElasticsearchRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Task&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注入接口进行使用：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; TaskRepository taskRepository;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;....&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;taskRepository.save(task);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="elasticsearch" scheme="http://fangjian0423.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之SpringBoot可执行文件解析</title>
    <link href="http://fangjian0423.github.io/2017/05/31/springboot-executable-jar/"/>
    <id>http://fangjian0423.github.io/2017/05/31/springboot-executable-jar/</id>
    <published>2017-05-31T12:33:33.000Z</published>
    <updated>2017-05-31T13:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。在pom文件里加入这个插件即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<p>打包完生成的executable-jar-1.0-SNAPSHOT.jar内部的结构如下：</p>
<pre><code>├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── spring.study
│           └── executable-jar
│               ├── pom.properties
│               └── pom.xml
├── lib
│   ├── aopalliance-1.0.jar
│   ├── classmate-1.1.0.jar
│   ├── spring-boot-1.3.5.RELEASE.jar
│   ├── spring-boot-autoconfigure-1.3.5.RELEASE.jar
│   ├── ...
├── org
│   └── springframework
│       └── boot
│           └── loader
│               ├── ExecutableArchiveLauncher$1.class
│               ├── ...
└── spring
    └── study
        └── executablejar
            └── ExecutableJarApplication.class
</code></pre><p>然后可以直接执行jar包就能启动程序了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar executable-jar-1.0-SNAPSHOT.jar</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>打包出来fat jar内部有4种文件类型：</p>
<ol>
<li>META-INF文件夹：程序入口，其中MANIFEST.MF用于描述jar包的信息</li>
<li>lib目录：放置第三方依赖的jar包，比如springboot的一些jar包</li>
<li>spring boot loader相关的代码</li>
<li>模块自身的代码</li>
</ol>
<p>MANIFEST.MF文件的内容：</p>
<pre><code>Manifest-Version: 1.0
Implementation-Title: executable-jar
Implementation-Version: 1.0-SNAPSHOT
Archiver-Version: Plexus Archiver
Built-By: Format
Start-Class: spring.study.executablejar.ExecutableJarApplication
Implementation-Vendor-Id: spring.study
Spring-Boot-Version: 1.3.5.RELEASE
Created-By: Apache Maven 3.2.3
Build-Jdk: 1.8.0_20
Implementation-Vendor: Pivotal Software, Inc.
Main-Class: org.springframework.boot.loader.JarLauncher
</code></pre><p>我们看到，它的Main-Class是org.springframework.boot.loader.JarLauncher，当我们使用java -jar执行jar包的时候会调用JarLauncher的main方法，而不是我们编写的SpringApplication。</p>
<p>那么JarLauncher这个类是的作用是什么的？</p>
<p>它是SpringBoot内部提供的工具Spring Boot Loader提供的一个用于执行Application类的工具类(fat jar内部有spring loader相关的代码就是因为这里用到了)。相当于Spring Boot Loader提供了一套标准用于执行SpringBoot打包出来的jar</p>
<h2 id="Spring-Boot-Loader抽象的一些类"><a href="#Spring-Boot-Loader抽象的一些类" class="headerlink" title="Spring Boot Loader抽象的一些类"></a>Spring Boot Loader抽象的一些类</h2><p>抽象类Launcher：各种Launcher的基础抽象类，用于启动应用程序；跟Archive配合使用；目前有3种实现，分别是JarLauncher、WarLauncher以及PropertiesLauncher</p>
<p>Archive：归档文件的基础抽象类。JarFileArchive就是jar包文件的抽象。它提供了一些方法比如getUrl会返回这个Archive对应的URL；getManifest方法会获得Manifest数据等。ExplodedArchive是文件目录的抽象</p>
<p>JarFile：对jar包的封装，每个JarFileArchive都会对应一个JarFile。JarFile被构造的时候会解析内部结构，去获取jar包里的各个文件或文件夹，这些文件或文件夹会被封装到Entry中，也存储在JarFileArchive中。如果Entry是个jar，会解析成JarFileArchive。</p>
<p>比如一个JarFileArchive对应的URL为：</p>
<pre><code>jar:file:/Users/format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/
</code></pre><p>它对应的JarFile为：</p>
<pre><code>/Users/format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar
</code></pre><p>这个JarFile有很多Entry，比如：</p>
<pre><code>META-INF/
META-INF/MANIFEST.MF
spring/
spring/study/
....
spring/study/executablejar/ExecutableJarApplication.class
lib/spring-boot-starter-1.3.5.RELEASE.jar
lib/spring-boot-1.3.5.RELEASE.jar
...
</code></pre><p>JarFileArchive内部的一些依赖jar对应的URL(SpringBoot使用org.springframework.boot.loader.jar.Handler处理器来处理这些URL)：</p>
<pre><code>jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-starter-web-1.3.5.RELEASE.jar!/

jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class
</code></pre><p>我们看到如果有jar包中包含jar，或者jar包中包含jar包里面的class文件，那么会使用 <strong>!/</strong> 分隔开，这种方式只有org.springframework.boot.loader.jar.Handler能处理，它是SpringBoot内部扩展出来的一种URL协议。</p>
<h2 id="JarLauncher的执行过程"><a href="#JarLauncher的执行过程" class="headerlink" title="JarLauncher的执行过程"></a>JarLauncher的执行过程</h2><p>JarLauncher的main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造JarLauncher，然后调用它的launch方法。参数是控制台传递的</span></div><div class="line">    <span class="keyword">new</span> JarLauncher().launch(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JarLauncher被构造的时候会调用父类ExecutableArchiveLauncher的构造方法。</p>
<p>ExecutableArchiveLauncher的构造方法内部会去构造Archive，这里构造了JarFileArchive。构造JarFileArchive的过程中还会构造很多东西，比如JarFile，Entry …</p>
<p>JarLauncher的launch方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 在系统属性中设置注册了自定义的URL处理器：org.springframework.boot.loader.jar.Handler。如果URL中没有指定处理器，会去系统属性中查询</span></div><div class="line">    JarFile.registerUrlProtocolHandler();</div><div class="line">    <span class="comment">// getClassPathArchives方法在会去找lib目录下对应的第三方依赖JarFileArchive，同时也会项目自身的JarFileArchive</span></div><div class="line">    <span class="comment">// 根据getClassPathArchives得到的JarFileArchive集合去创建类加载器ClassLoader。这里会构造一个LaunchedURLClassLoader类加载器，这个类加载器继承URLClassLoader，并使用这些JarFileArchive集合的URL构造成URLClassPath</span></div><div class="line">    <span class="comment">// LaunchedURLClassLoader类加载器的父类加载器是当前执行类JarLauncher的类加载器</span></div><div class="line">    ClassLoader classLoader = createClassLoader(getClassPathArchives());</div><div class="line">    <span class="comment">// getMainClass方法会去项目自身的Archive中的Manifest中找出key为Start-Class的类</span></div><div class="line">    <span class="comment">// 调用重载方法launch</span></div><div class="line">    launch(args, getMainClass(), classLoader);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    ex.printStackTrace();</div><div class="line">    System.exit(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Archive的getMainClass方法</span></div><div class="line"><span class="comment">// 这里会找出spring.study.executablejar.ExecutableJarApplication这个类</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMainClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	Manifest manifest = getManifest();</div><div class="line">	String mainClass = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span> (manifest != <span class="keyword">null</span>) &#123;</div><div class="line">		mainClass = manifest.getMainAttributes().getValue(<span class="string">"Start-Class"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (mainClass == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">				<span class="string">"No 'Start-Class' manifest entry specified in "</span> + <span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mainClass;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// launch重载方法</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span></span></div><div class="line">		<span class="keyword">throws</span> Exception &#123;</div><div class="line">      <span class="comment">// 创建一个MainMethodRunner，并把args和Start-Class传递给它</span></div><div class="line">	Runnable runner = createMainMethodRunner(mainClass, args, classLoader);</div><div class="line">      <span class="comment">// 构造新线程</span></div><div class="line">	Thread runnerThread = <span class="keyword">new</span> Thread(runner);</div><div class="line">      <span class="comment">// 线程设置类加载器以及名字，然后启动</span></div><div class="line">	runnerThread.setContextClassLoader(classLoader);</div><div class="line">	runnerThread.setName(Thread.currentThread().getName());</div><div class="line">	runnerThread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MainMethodRunner的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 根据Start-Class进行实例化</span></div><div class="line">    Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</div><div class="line">        .loadClass(<span class="keyword">this</span>.mainClassName);</div><div class="line">    <span class="comment">// 找出main方法</span></div><div class="line">    Method mainMethod = mainClass.getDeclaredMethod(<span class="string">"main"</span>, String[].class);</div><div class="line">    <span class="comment">// 如果main方法不存在，抛出异常</span></div><div class="line">    <span class="keyword">if</span> (mainMethod == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">          <span class="keyword">this</span>.mainClassName + <span class="string">" does not have a main method"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 调用</span></div><div class="line">    mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    UncaughtExceptionHandler handler = Thread.currentThread()</div><div class="line">        .getUncaughtExceptionHandler();</div><div class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">      handler.uncaughtException(Thread.currentThread(), ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Start-Class的main方法调用之后，内部会构造Spring容器，启动内置Servlet容器等过程。 这些过程我们都已经分析过了。</p>
<h2 id="关于自定义的类加载器LaunchedURLClassLoader"><a href="#关于自定义的类加载器LaunchedURLClassLoader" class="headerlink" title="关于自定义的类加载器LaunchedURLClassLoader"></a>关于自定义的类加载器LaunchedURLClassLoader</h2><p>LaunchedURLClassLoader重写了loadClass方法，也就是说它修改了默认的类加载方式(先看该类是否已加载这部分不变，后面真正去加载类的规则改变了，不再是直接从父类加载器中去加载)。LaunchedURLClassLoader定义了自己的类加载规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Class&lt;?&gt; doLoadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"></div><div class="line">  <span class="comment">// 1) Try the root class loader</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rootClassLoader != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.rootClassLoader.loadClass(name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    <span class="comment">// Ignore and continue</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 2) Try to find locally</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    findPackage(name);</div><div class="line">    Class&lt;?&gt; cls = findClass(name);</div><div class="line">    <span class="keyword">return</span> cls;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    <span class="comment">// Ignore and continue</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 3) Use standard loading</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载规则：</p>
<ol>
<li>如果根类加载器存在，调用它的加载方法。这里是根类加载是ExtClassLoader</li>
<li>调用LaunchedURLClassLoader自身的findClass方法，也就是URLClassLoader的findClass方法</li>
<li>调用父类的loadClass方法，也就是执行默认的类加载顺序(从BootstrapClassLoader开始从下往下寻找)</li>
</ol>
<p>LaunchedURLClassLoader自身的findClass方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</div><div class="line">     <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</div><div class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">                    <span class="comment">// 把类名解析成路径并加上.class后缀</span></div><div class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</div><div class="line">                    <span class="comment">// 基于之前得到的第三方jar包依赖以及自己的jar包得到URL数组，进行遍历找出对应类名的资源</span></div><div class="line">                    <span class="comment">// 比如path是org/springframework/boot/loader/JarLauncher.class，它在jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/中被找出</span></div><div class="line">                    <span class="comment">// 那么找出的资源对应的URL为jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class</span></div><div class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123; <span class="comment">// 找到了资源</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            <span class="keyword">return</span> defineClass(name, res);</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找不到资源的话直接抛出ClassNotFoundException异常</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;, acc);</div><div class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</div><div class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是LaunchedURLClassLoader的一个测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册org.springframework.boot.loader.jar.Handler URL协议处理器</span></div><div class="line">JarFile.registerUrlProtocolHandler();</div><div class="line"><span class="comment">// 构造LaunchedURLClassLoader类加载器，这里使用了2个URL，分别对应jar包中依赖包spring-boot-loader和spring-boot，使用 "!/" 分开，需要org.springframework.boot.loader.jar.Handler处理器处理</span></div><div class="line">LaunchedURLClassLoader classLoader = <span class="keyword">new</span> LaunchedURLClassLoader(</div><div class="line">        <span class="keyword">new</span> URL[] &#123;</div><div class="line">                <span class="keyword">new</span> URL(<span class="string">"jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/"</span>)</div><div class="line">                , <span class="keyword">new</span> URL(<span class="string">"jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-1.3.5.RELEASE.jar!/"</span>)</div><div class="line">        &#125;,</div><div class="line">        LaunchedURLClassLoaderTest.class.getClassLoader());</div><div class="line"></div><div class="line"><span class="comment">// 加载类</span></div><div class="line"><span class="comment">// 这2个类都会在第二步本地查找中被找出(URLClassLoader的findClass方法)</span></div><div class="line">classLoader.loadClass(<span class="string">"org.springframework.boot.loader.JarLauncher"</span>);</div><div class="line">classLoader.loadClass(<span class="string">"org.springframework.boot.SpringApplication"</span>);</div><div class="line"><span class="comment">// 在第三步使用默认的加载顺序在ApplicationClassLoader中被找出</span></div><div class="line">classLoader.loadClass(<span class="string">"org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration"</span>);</div></pre></td></tr></table></figure>
<h2 id="Spring-Boot-Loader的作用"><a href="#Spring-Boot-Loader的作用" class="headerlink" title="Spring Boot Loader的作用"></a>Spring Boot Loader的作用</h2><p>SpringBoot在可执行jar包中定义了自己的一套规则，比如第三方依赖jar包在/lib目录下，jar包的URL路径使用自定义的规则并且这个规则需要使用org.springframework.boot.loader.jar.Handler处理器处理。它的Main-Class使用JarLauncher，如果是war包，使用WarLauncher执行。这些Launcher内部都会另起一个线程启动自定义的SpringApplication类。</p>
<p>这些特性通过spring-boot-maven-plugin插件打包完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot提供了一个插件spring-boot-maven-plugin用于把程序打包成一个可执行的jar包。在pom文件里加入这个插件即可：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打包完生成的executable-jar-1.0-SNAPSHOT.jar内部的结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── spring.study
│           └── executable-jar
│               ├── pom.properties
│               └── pom.xml
├── lib
│   ├── aopalliance-1.0.jar
│   ├── classmate-1.1.0.jar
│   ├── spring-boot-1.3.5.RELEASE.jar
│   ├── spring-boot-autoconfigure-1.3.5.RELEASE.jar
│   ├── ...
├── org
│   └── springframework
│       └── boot
│           └── loader
│               ├── ExecutableArchiveLauncher$1.class
│               ├── ...
└── spring
    └── study
        └── executablejar
            └── ExecutableJarApplication.class
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后可以直接执行jar包就能启动程序了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;java -jar executable-jar-1.0-SNAPSHOT.jar&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringData ES 关于字段名和索引中的列名字不一致导致的查询问题</title>
    <link href="http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/"/>
    <id>http://fangjian0423.github.io/2017/05/24/spring-data-es-query-problem/</id>
    <published>2017-05-23T16:33:33.000Z</published>
    <updated>2017-05-31T13:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中使用了<a href="https://github.com/spring-projects/spring-data-elasticsearch" target="_blank" rel="external">Spring Data Elasticsearch</a>。发生它存在一个问题：</p>
<p><strong>Document对应的POJO的属性跟es里面文档的字段名字不一样，这样Repository里面编写自定义的查询方法就会查询不出结果。</strong></p>
<p>比如有个Person类，它有2个属性goodFace和goodAt。这2个属性在es的索引里对应的字段表为good_face和good_at：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Document</span>(replicas = <span class="number">1</span>, shards = <span class="number">1</span>, type = <span class="string">"person"</span>, indexName = <span class="string">"person"</span>)</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="meta">@Setter</span></div><div class="line"><span class="meta">@JsonNaming</span>(PropertyNamingStrategy.SnakeCaseStrategy.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="keyword">private</span> String id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> goodFace;</div><div class="line">    <span class="keyword">private</span> String goodAt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Repository中的自定义查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByGoodFace</span><span class="params">(<span class="keyword">boolean</span> isGoodFace)</span></span>;</div><div class="line">    <span class="function">List&lt;Person&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法findByGoodFace是查询不出结果的，而findByName是ok的。</p>
<p>为什么findByGoodFace不行而findByName可以呢，来探究一下。</p>
<a id="more"></a>
<p>Person类的name属性跟ES中的字段名是一模一样的，而goodFace字段在ES中的字段是good_face(因为我们使用了SnakeCaseStrategy策略)。</p>
<p>所以产生这个问题的原因在于ES中文档的字段名跟POJO中的字段名不统一造成的。</p>
<p><strong>但是我们使用PersonRepository的save方法保存文档的时候属性和字段是可以对上的。</strong></p>
<p>那为什么使用repository的save方法能对应上文档和字段，而自定义的find方法却不行呢？</p>
<p>ES是使用<a href="https://github.com/FasterXML/jackson" target="_blank" rel="external">jackson</a>来完成POJO到json的映射关系的。</p>
<p>在Person类上使用@JsonNaming注解完成POJO和json的映射，我们使用了SnakeCaseStrategy策略，这个策略会把属性从驼峰方式改成小写带下划线的方式。</p>
<p>比如goodAt属性映射的时候就会变成good_at，good_face变成good_face，name变成name。</p>
<p>Spring Data Elasticsearch把对ES的操作封装成了一个ElasticsearchOperations接口。比如queryForObject、queryForPage、count、queryForList方法。</p>
<p>ElasticsearchOperations接口目前有一个实现类ElasticsearchTemplate。</p>
<p>ElasticsearchTemplate内部有个ResultsMapper属性，这个ResultsMapper目前只有一个实现类DefaultResultMapper，DefaultResultMapper内部使用DefaultEntityMapper完成映射。DefaultEntityMapper是个EntityMapper接口的实现类，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EntityMapper</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">mapToString</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">mapToObject</span><span class="params">(String source, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法很明白：对象到json字符串的转换和json字符串倒对象的转换。</p>
<p>DefaultEntityMapper内部使用jackson的ObjectMapper完成。</p>
<p>自定义的Repository继承自ElasticsearchRepository，最后会使用代理映射成SimpleElasticsearchRepository。</p>
<p>SimpleElasticsearchRepository内部有个属性ElasticsearchOperations用于完成与ES的交互。</p>
<p>我们看下SimpleElasticsearchRepository的save方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</div><div class="line">  Assert.notNull(entity, <span class="string">"Cannot save 'null' entity."</span>);</div><div class="line">  <span class="comment">// createIndexQuery方法会构造一个IndexQuery，然后调用ElasticsearchOperations的index方法</span></div><div class="line">  elasticsearchOperations.index(createIndexQuery(entity));</div><div class="line">  elasticsearchOperations.refresh(entityInformation.getIndexName());</div><div class="line">  <span class="keyword">return</span> entity;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ElasticsearchTemplate的index方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(IndexQuery query)</span> </span>&#123;</div><div class="line">      <span class="comment">// 调用prepareIndex方法构造一个IndexRequestBuilder</span></div><div class="line">	String documentId = prepareIndex(query).execute().actionGet().getId();</div><div class="line">	<span class="comment">// 设置保存文档的id</span></div><div class="line">	<span class="keyword">if</span> (query.getObject() != <span class="keyword">null</span>) &#123;</div><div class="line">		setPersistentEntityId(query.getObject(), documentId);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> documentId;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> IndexRequestBuilder <span class="title">prepareIndex</span><span class="params">(IndexQuery query)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">// 从@Document注解中得到索引的名字</span></div><div class="line">		String indexName = isBlank(query.getIndexName()) ? retrieveIndexNameFromPersistentEntity(query.getObject()</div><div class="line">				.getClass())[<span class="number">0</span>] : query.getIndexName();</div><div class="line">              <span class="comment">// 从@Document注解中得到索引的类型</span></div><div class="line">		String type = isBlank(query.getType()) ? retrieveTypeFromPersistentEntity(query.getObject().getClass())[<span class="number">0</span>]</div><div class="line">				: query.getType();</div><div class="line"></div><div class="line">		IndexRequestBuilder indexRequestBuilder = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (query.getObject() != <span class="keyword">null</span>) &#123; <span class="comment">// save方法这里保存的object就是POJO</span></div><div class="line">            <span class="comment">// 得到id字段</span></div><div class="line">			String id = isBlank(query.getId()) ? getPersistentEntityId(query.getObject()) : query.getId();</div><div class="line">			<span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123; <span class="comment">// 如果设置了id字段</span></div><div class="line">				indexRequestBuilder = client.prepareIndex(indexName, type, id);</div><div class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有设置id字段</span></div><div class="line">				indexRequestBuilder = client.prepareIndex(indexName, type);</div><div class="line">			&#125;</div><div class="line">            <span class="comment">// 使用ResultsMapper映射POJO到json字符串</span></div><div class="line">			indexRequestBuilder.setSource(resultsMapper.getEntityMapper().mapToString(query.getObject()));</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.getSource() != <span class="keyword">null</span>) &#123; <span class="comment">// 如果自定义了source属性，直接赋值</span></div><div class="line">			indexRequestBuilder = client.prepareIndex(indexName, type, query.getId()).setSource(query.getSource());</div><div class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有设置object属性或者source属性，抛出ElasticsearchException异常</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchException(<span class="string">"object or source is null, failed to index the document [id: "</span> + query.getId() + <span class="string">"]"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (query.getVersion() != <span class="keyword">null</span>) &#123; <span class="comment">// 设置版本</span></div><div class="line">			indexRequestBuilder.setVersion(query.getVersion());</div><div class="line">			indexRequestBuilder.setVersionType(EXTERNAL);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (query.getParentId() != <span class="keyword">null</span>) &#123; <span class="comment">// 设置parentId</span></div><div class="line">			indexRequestBuilder.setParent(query.getParentId());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> indexRequestBuilder;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchException(<span class="string">"failed to index the document [id: "</span> + query.getId() + <span class="string">"]"</span>, e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>save方法使用ResultsMapper完成了POJO到json的转换，所以save方法保存成功对应的文档数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">indexRequestBuilder.setSource(resultsMapper.getEntityMapper().mapToString(query.getObject()));</div></pre></td></tr></table></figure>
<p>自定义的findByGoodFace方法：</p>
<p>由于是Repository中的自定义方法，会被Spring Data通过代理进行构造，内部还是用了AOP，最终在QueryExecutorMethodInterceptor中并解析成ElasticsearchPartQuery这个RepositoryQuery接口的实现类，然后调用execute方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(Object[] parameters)</span> </span>&#123;</div><div class="line">  ParametersParameterAccessor accessor = <span class="keyword">new</span> ParametersParameterAccessor(queryMethod.getParameters(), parameters);</div><div class="line">  CriteriaQuery query = createQuery(accessor);</div><div class="line">  <span class="keyword">if</span>(tree.isDelete()) &#123; <span class="comment">// 如果是删除方法</span></div><div class="line">    Object result = countOrGetDocumentsForDelete(query, accessor);</div><div class="line">    elasticsearchOperations.delete(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryMethod.isPageQuery()) &#123; <span class="comment">// 如果是分页查询</span></div><div class="line">    query.setPageable(accessor.getPageable());</div><div class="line">    <span class="keyword">return</span> elasticsearchOperations.queryForPage(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryMethod.isStreamQuery()) &#123; <span class="comment">// 如果是流式查询</span></div><div class="line">    Class&lt;?&gt; entityType = queryMethod.getEntityInformation().getJavaType();</div><div class="line">    <span class="keyword">if</span> (query.getPageable() == <span class="keyword">null</span>) &#123;</div><div class="line">      query.setPageable(<span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">20</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> StreamUtils.createStreamFromIterator((CloseableIterator&lt;Object&gt;) elasticsearchOperations.stream(query, entityType));</div><div class="line"></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queryMethod.isCollectionQuery()) &#123; <span class="comment">// 如果是集合查询</span></div><div class="line">    <span class="keyword">if</span> (accessor.getPageable() == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">int</span> itemCount = (<span class="keyword">int</span>) elasticsearchOperations.count(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">      query.setPageable(<span class="keyword">new</span> PageRequest(<span class="number">0</span>, Math.max(<span class="number">1</span>, itemCount)));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        query.setPageable(accessor.getPageable());</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> elasticsearchOperations.queryForList(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree.isCountProjection()) &#123; <span class="comment">// 如果是count查询</span></div><div class="line">    <span class="keyword">return</span> elasticsearchOperations.count(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 单个查询</span></div><div class="line">  <span class="keyword">return</span> elasticsearchOperations.queryForObject(query, queryMethod.getEntityInformation().getJavaType());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>findByGoodFace方法是个集合查询，最终会调用ElasticsearchOperations的queryForList方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(CriteriaQuery query, Class&lt;T&gt; clazz)</span> </span>&#123;</div><div class="line">  <span class="comment">// 调用queryForPage方法</span></div><div class="line">  <span class="keyword">return</span> queryForPage(query, clazz).getContent();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">queryForPage</span><span class="params">(CriteriaQuery criteriaQuery, Class&lt;T&gt; clazz)</span> </span>&#123;</div><div class="line">  <span class="comment">// 查询解析器进行语法的解析</span></div><div class="line">  QueryBuilder elasticsearchQuery = <span class="keyword">new</span> CriteriaQueryProcessor().createQueryFromCriteria(criteriaQuery.getCriteria());</div><div class="line">  QueryBuilder elasticsearchFilter = <span class="keyword">new</span> CriteriaFilterProcessor().createFilterFromCriteria(criteriaQuery.getCriteria());</div><div class="line">  SearchRequestBuilder searchRequestBuilder = prepareSearch(criteriaQuery, clazz);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (elasticsearchQuery != <span class="keyword">null</span>) &#123;</div><div class="line">    searchRequestBuilder.setQuery(elasticsearchQuery);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    searchRequestBuilder.setQuery(QueryBuilders.matchAllQuery());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (criteriaQuery.getMinScore() &gt; <span class="number">0</span>) &#123;</div><div class="line">    searchRequestBuilder.setMinScore(criteriaQuery.getMinScore());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (elasticsearchFilter != <span class="keyword">null</span>)</div><div class="line">    searchRequestBuilder.setPostFilter(elasticsearchFilter);</div><div class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">    logger.debug(<span class="string">"doSearch query:\n"</span> + searchRequestBuilder.toString());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  SearchResponse response = getSearchResponse(searchRequestBuilder</div><div class="line">      .execute());</div><div class="line">  <span class="comment">// 最终的结果是用ResultsMapper进行映射</span></div><div class="line">  <span class="keyword">return</span> resultsMapper.mapResults(response, clazz, criteriaQuery.getPageable());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义的方法使用ElasticsearchQueryCreator去创建CriteriaQuery，内部做一些词法的分析，有了CriteriaQuery之后，使用CriteriaQueryProcessor基于Criteria构造了QueryBuilder，最后使用QueryBuilder去做rest请求得到es的查询结果。这些过程中是没有用到ResultsMapper，而只是用反射得到POJO的属性，只有在得到查询结果后才会用ResultsMapper去做映射。</p>
<p>如果出现了这种情况，解决方案目前有两种：</p>
<p>1.使用repository的search方法，参数可以是QueryBuilder或者SearchQuery</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">personRepository.search(</div><div class="line">        QueryBuilders.boolQuery()</div><div class="line">                .must(QueryBuilders.termQuery(<span class="string">"good_face"</span>, <span class="keyword">true</span>))</div><div class="line">)</div></pre></td></tr></table></figure>
<p>2.使用@Query注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Query</span>(<span class="string">"&#123;\"bool\" : &#123;\"must\" : &#123;\"term\" : &#123;\"good_face\" : \"?0\"&#125;&#125;&#125;&#125;"</span>)</div><div class="line"><span class="function">List&lt;Person&gt; <span class="title">findByGoodFace</span><span class="params">(<span class="keyword">boolean</span> isGoodFace)</span></span>;</div></pre></td></tr></table></figure>
<p>暂时发现这两种解决方法，不知还有否更好的解决方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作中使用了&lt;a href=&quot;https://github.com/spring-projects/spring-data-elasticsearch&quot;&gt;Spring Data Elasticsearch&lt;/a&gt;。发生它存在一个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document对应的POJO的属性跟es里面文档的字段名字不一样，这样Repository里面编写自定义的查询方法就会查询不出结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有个Person类，它有2个属性goodFace和goodAt。这2个属性在es的索引里对应的字段表为good_face和good_at：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Document&lt;/span&gt;(replicas = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, shards = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, type = &lt;span class=&quot;string&quot;&gt;&quot;person&quot;&lt;/span&gt;, indexName = &lt;span class=&quot;string&quot;&gt;&quot;person&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Getter&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Setter&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@JsonNaming&lt;/span&gt;(PropertyNamingStrategy.SnakeCaseStrategy.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Id&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String id;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; goodFace;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String goodAt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Repository中的自定义查询：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Repository&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PersonRepository&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ElasticsearchRepository&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;Person&amp;gt; &lt;span class=&quot;title&quot;&gt;findByGoodFace&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isGoodFace)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;List&amp;lt;Person&amp;gt; &lt;span class=&quot;title&quot;&gt;findByName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法findByGoodFace是查询不出结果的，而findByName是ok的。&lt;/p&gt;
&lt;p&gt;为什么findByGoodFace不行而findByName可以呢，来探究一下。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://fangjian0423.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="elasticsearch" scheme="http://fangjian0423.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之内置Servlet容器</title>
    <link href="http://fangjian0423.github.io/2017/05/22/springboot-embedded-servlet-container/"/>
    <id>http://fangjian0423.github.io/2017/05/22/springboot-embedded-servlet-container/</id>
    <published>2017-05-22T10:35:36.000Z</published>
    <updated>2017-05-22T12:51:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot内置了Servlet容器，这样项目的发布、部署就不需要额外的Servlet容器，直接启动jar包即可。SpringBoot官方文档上有一个小章节<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-embedded-container" target="_blank" rel="external">内置servlet容器支持</a>用于说明内置Servlet的相关问题。</p>
<p>在<a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a>文章中我们了解到如果是Web程序，那么会构造AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器，在<a href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/">SpringBoot源码分析之Spring容器的refresh过程</a>文章中我们知道AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器在refresh的过程中会在onRefresh方法中创建内置的Servlet容器。</p>
<p>接下来，我们分析一下内置的Servlet容器相关的知识点。</p>
<a id="more"></a>
<h2 id="内置Servlet容器相关的接口和类"><a href="#内置Servlet容器相关的接口和类" class="headerlink" title="内置Servlet容器相关的接口和类"></a>内置Servlet容器相关的接口和类</h2><p>SpringBoot对内置的Servlet容器做了一层封装：</p>
<pre><code>public interface EmbeddedServletContainer {
    // 启动内置的Servlet容器，如果容器已经启动，则不影响
    void start() throws EmbeddedServletContainerException;
    // 关闭内置的Servlet容器，如果容器已经关系，则不影响
    void stop() throws EmbeddedServletContainerException;
    // 内置的Servlet容器监听的端口
    int getPort();
}
</code></pre><p>它目前有3个实现类，分别是JettyEmbeddedServletContainer、TomcatEmbeddedServletContainer和UndertowEmbeddedServletContainer，分别对应Jetty、Tomcat和Undertow这3个Servlet容器。</p>
<p>EmbeddedServletContainerFactory接口是一个工厂接口，用于生产EmbeddedServletContainer：</p>
<pre><code>public interface EmbeddedServletContainerFactory {
    // 获得一个已经配置好的内置Servlet容器，但是这个容器还没有监听端口。需要手动调用内置Servlet容器的start方法监听端口
    // 参数是一群ServletContextInitializer，Servlet容器启动的时候会遍历这些ServletContextInitializer，并调用onStartup方法
    EmbeddedServletContainer getEmbeddedServletContainer(
            ServletContextInitializer... initializers);
}
</code></pre><p>ServletContextInitializer表示Servlet初始化器，用于设置ServletContext中的一些配置，在使用EmbeddedServletContainerFactory接口的getEmbeddedServletContainer方法获取Servlet内置容器并且容器启动的时候调用onStartup方法：</p>
<pre><code>public interface ServletContextInitializer {
    void onStartup(ServletContext servletContext) throws ServletException;
}
</code></pre><p>EmbeddedServletContainerFactory是在EmbeddedServletContainerAutoConfiguration这个自动化配置类中被注册到Spring容器中的(前期是Spring容器中不存在EmbeddedServletContainerFactory类型的bean，可以自己定义EmbeddedServletContainerFactory类型的bean)：</p>
<pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication // 在Web环境下才会起作用
@Import(BeanPostProcessorsRegistrar.class) // 会Import一个内部类BeanPostProcessorsRegistrar
public class EmbeddedServletContainerAutoConfiguration {

    @Configuration
    // Tomcat类和Servlet类必须在classloader中存在
    @ConditionalOnClass({ Servlet.class, Tomcat.class })
    // 当前Spring容器中不存在EmbeddedServletContainerFactory类型的实例
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedTomcat {

        @Bean
        public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
          // 上述条件注解成立的话就会构造TomcatEmbeddedServletContainerFactory这个EmbeddedServletContainerFactory
            return new TomcatEmbeddedServletContainerFactory();
        }

    }

    @Configuration
    // Server类、Servlet类、Loader类以及WebAppContext类必须在classloader中存在
    @ConditionalOnClass({ Servlet.class, Server.class, Loader.class,
            WebAppContext.class })
    // 当前Spring容器中不存在EmbeddedServletContainerFactory类型的实例
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedJetty {

        @Bean
        public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {
            // 上述条件注解成立的话就会构造JettyEmbeddedServletContainerFactory这个EmbeddedServletContainerFactory
            return new JettyEmbeddedServletContainerFactory();
        }

    }

    @Configuration
    // Undertow类、Servlet类、以及SslClientAuthMode类必须在classloader中存在
    @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
    // 当前Spring容器中不存在EmbeddedServletContainerFactory类型的实例
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedUndertow {

        @Bean
        public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {
            // 上述条件注解成立的话就会构造JettyEmbeddedServletContainerFactory这个EmbeddedServletContainerFactory
            return new UndertowEmbeddedServletContainerFactory();
        }

    }
    // 在EmbeddedServletContainerAutoConfiguration自动化配置类中被导入，实现了BeanFactoryAware接口(BeanFactory会被自动注入进来)和ImportBeanDefinitionRegistrar接口(会被ConfigurationClassBeanDefinitionReader解析并注册到Spring容器中)
    public static class EmbeddedServletContainerCustomizerBeanPostProcessorRegistrar
              implements ImportBeanDefinitionRegistrar, BeanFactoryAware {

          private ConfigurableListableBeanFactory beanFactory;

          @Override
          public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
              if (beanFactory instanceof ConfigurableListableBeanFactory) {
                  this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
              }
          }

          @Override
          public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
                  BeanDefinitionRegistry registry) {
              if (this.beanFactory == null) {
                  return;
              }
              // 如果Spring容器中不存在EmbeddedServletContainerCustomizerBeanPostProcessor类型的bean
              if (ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(
                      EmbeddedServletContainerCustomizerBeanPostProcessor.class, true,
                      false))) {
                  // 注册一个EmbeddedServletContainerCustomizerBeanPostProcessor
                  registry.registerBeanDefinition(
                          &quot;embeddedServletContainerCustomizerBeanPostProcessor&quot;,
                          new RootBeanDefinition(
                                  EmbeddedServletContainerCustomizerBeanPostProcessor.class));

              }
          }

      }

}
</code></pre><p>EmbeddedServletContainerCustomizerBeanPostProcessor是一个BeanPostProcessor，它在postProcessBeforeInitialization过程中去寻找Spring容器中EmbeddedServletContainerCustomizer类型的bean，并依次调用EmbeddedServletContainerCustomizer接口的customize方法做一些定制化：</p>
<pre><code>@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
    throws BeansException {
  // 在Spring容器中寻找ConfigurableEmbeddedServletContainer类型的bean，SpringBoot内部的3种内置Servlet容器工厂都实现了这个接口，该接口的作用就是进行Servlet容器的配置
  // 比如添加Servlet初始化器addInitializers、添加错误页addErrorPages、设置session超时时间setSessionTimeout、设置端口setPort等等
  if (bean instanceof ConfigurableEmbeddedServletContainer) {
    postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
  }
  return bean;
}

private void postProcessBeforeInitialization(
    ConfigurableEmbeddedServletContainer bean) {
  for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) {
    // 遍历获取的每个定制化器，并调用customize方法进行一些定制
    customizer.customize(bean);
  }
}

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() {
  if (this.customizers == null) {
    this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
        // 找出Spring容器中EmbeddedServletContainerCustomizer类型的bean
        this.applicationContext
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                false, false)
            .values());
    // 定制化器做排序
    Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
    // 设置定制化器到属性中
    this.customizers = Collections.unmodifiableList(this.customizers);
  }
  return this.customizers;
}
</code></pre><p>SpringBoot内置了一些EmbeddedServletContainerCustomizer，比如ErrorPageCustomizer、ServerProperties、TomcatWebSocketContainerCustomizer等。</p>
<p>定制器比如ServerProperties表示服务端的一些配置，以server为前缀，比如有server.port、server.contextPath、server.displayName等，它同时也实现了EmbeddedServletContainerCustomizer接口，其中customize方法的一部分代码如下：</p>
<pre><code>@Override
public void customize(ConfigurableEmbeddedServletContainer container) {
  // 3种ServletContainerFactory都实现了ConfigurableEmbeddedServletContainer接口，所以下面的这些设置相当于对ServletContainerFactory进行设置
  // 如果配置了端口信息
  if (getPort() != null) {
    container.setPort(getPort());
  }
  ...
  // 如果配置了displayName
  if (getDisplayName() != null) {
    container.setDisplayName(getDisplayName());
  }
  // 如果配置了server.session.timeout，session超时时间。注意：这里的Session指的是ServerProperties的内部静态类Session
  if (getSession().getTimeout() != null) {
    container.setSessionTimeout(getSession().getTimeout());
  }
  ...
  // 如果使用的是Tomcat内置Servlet容器，设置对应的Tomcat配置
  if (container instanceof TomcatEmbeddedServletContainerFactory) {
    getTomcat().customizeTomcat(this,
        (TomcatEmbeddedServletContainerFactory) container);
  }
  // 如果使用的是Jetty内置Servlet容器，设置对应的Tomcat配置
  if (container instanceof JettyEmbeddedServletContainerFactory) {
    getJetty().customizeJetty(this,
        (JettyEmbeddedServletContainerFactory) container);
  }
  // 如果使用的是Undertow内置Servlet容器，设置对应的Tomcat配置
  if (container instanceof UndertowEmbeddedServletContainerFactory) {
    getUndertow().customizeUndertow(this,
        (UndertowEmbeddedServletContainerFactory) container);
  }
  // 添加SessionConfiguringInitializer这个Servlet初始化器
  // SessionConfiguringInitializer初始化器的作用是基于ServerProperties的内部静态类Session设置Servlet中session和cookie的配置
  container.addInitializers(new SessionConfiguringInitializer(this.session));
  // 添加InitParameterConfiguringServletContextInitializer初始化器
  // InitParameterConfiguringServletContextInitializer初始化器的作用是基于ServerProperties的contextParameters配置设置到ServletContext的init param中
  container.addInitializers(new InitParameterConfiguringServletContextInitializer(
      getContextParameters()));
}
</code></pre><p>ErrorPageCustomizer在ErrorMvcAutoConfiguration自动化配置里定义，是个内部静态类：</p>
<pre><code>@Bean
public ErrorPageCustomizer errorPageCustomizer() {
    return new ErrorPageCustomizer(this.properties);
}

private static class ErrorPageCustomizer
          implements EmbeddedServletContainerCustomizer, Ordered {

        private final ServerProperties properties;

        protected ErrorPageCustomizer(ServerProperties properties) {
            this.properties = properties;
        }

        @Override
        public void customize(ConfigurableEmbeddedServletContainer container) {
            // 添加错误页ErrorPage，这个ErrorPage对应的路径是 /error
            // 可以通过配置修改 ${servletPath} + ${error.path}
            container.addErrorPages(new ErrorPage(this.properties.getServletPrefix()
                    + this.properties.getError().getPath()));
        }

        @Override
        public int getOrder() {
            return 0;
        }

   }
</code></pre><h2 id="DispatcherServlet的构造"><a href="#DispatcherServlet的构造" class="headerlink" title="DispatcherServlet的构造"></a>DispatcherServlet的构造</h2><p>DispatcherServlet是SpringMVC中的核心分发器。它是在DispatcherServletAutoConfiguration这个自动化配置类里构造的(如果Spring容器内没有自定义的DispatcherServlet)，并且还会被加到Servlet容器中(通过ServletRegistrationBean完成)。</p>
<p>DispatcherServletAutoConfiguration这个自动化配置类存在2个条件注解@ConditionalOnWebApplication和@ConditionalOnClass(DispatcherServlet.class)都满足条件，所以会被构造(存在@AutoConfigureAfter(EmbeddedServletContainerAutoConfiguration.class)注解，会在EmbeddedServletContainerAutoConfiguration自动化配置类构造后构造)：</p>
<pre><code>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(EmbeddedServletContainerAutoConfiguration.class)
public class DispatcherServletAutoConfiguration ...
</code></pre><p>DispatcherServletAutoConfiguration有个内部类DispatcherServletConfiguration，它会构造DispatcherServlet(使用了条件类DefaultDispatcherServletCondition，如果Spring容器已经存在自定义的DispatcherServlet类型的bean，该类就不会被构造，会直接使用自定义的DispatcherServlet)：</p>
<pre><code>@Configuration
// 条件类DefaultDispatcherServletCondition，是EmbeddedServletContainerAutoConfiguration的内部类
// DefaultDispatcherServletCondition条件类会去Spring容器中找DispatcherServlet类型的实例，如果找到了不会构造DispatcherServletConfiguration，否则就是构造DispatcherServletConfiguration，该类内部会构造DispatcherServlet
// 所以如果我们要自定义DispatcherServlet的话只需要自定义DispatcherServlet即可，这样DispatcherServletConfiguration内部就不会构造DispatcherServlet
@Conditional(DefaultDispatcherServletCondition.class)
// Servlet3.0开始才有的类，支持以编码的形式注册Servlet
@ConditionalOnClass(ServletRegistration.class)
// spring.mvc 为前缀的配置
@EnableConfigurationProperties(WebMvcProperties.class)
protected static class DispatcherServletConfiguration {

  @Autowired
  private ServerProperties server;

  @Autowired
  private WebMvcProperties webMvcProperties;

  @Autowired(required = false)
  private MultipartConfigElement multipartConfig;

  // Spring容器注册DispatcherServlet
  @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
  public DispatcherServlet dispatcherServlet() {
    // 直接构造DispatcherServlet，并设置WebMvcProperties中的一些配置
    DispatcherServlet dispatcherServlet = new DispatcherServlet();
    dispatcherServlet.setDispatchOptionsRequest(
        this.webMvcProperties.isDispatchOptionsRequest());
    dispatcherServlet.setDispatchTraceRequest(
        this.webMvcProperties.isDispatchTraceRequest());
    dispatcherServlet.setThrowExceptionIfNoHandlerFound(
        this.webMvcProperties.isThrowExceptionIfNoHandlerFound());
    return dispatcherServlet;
  }

  @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
  public ServletRegistrationBean dispatcherServletRegistration() {
    // 直接使用DispatcherServlet和server配置中的servletPath路径构造ServletRegistrationBean
    // ServletRegistrationBean实现了ServletContextInitializer接口，在onStartup方法中对应的Servlet注册到Servlet容器中
    // 所以这里DispatcherServlet会被注册到Servlet容器中，对应的urlMapping为server.servletPath配置
    ServletRegistrationBean registration = new ServletRegistrationBean(
        dispatcherServlet(), this.server.getServletMapping());
    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
    if (this.multipartConfig != null) {
      registration.setMultipartConfig(this.multipartConfig);
    }
    return registration;
  }

  @Bean // 构造文件上传相关的bean
  @ConditionalOnBean(MultipartResolver.class)
  @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
  public MultipartResolver multipartResolver(MultipartResolver resolver) {
    return resolver;
  }

}
</code></pre><p>ServletRegistrationBean实现了ServletContextInitializer接口，是个Servlet初始化器，onStartup方法代码：</p>
<pre><code>@Override
public void onStartup(ServletContext servletContext) throws ServletException {
  Assert.notNull(this.servlet, &quot;Servlet must not be null&quot;);
  String name = getServletName();
  if (!isEnabled()) {
    logger.info(&quot;Servlet &quot; + name + &quot; was not registered (disabled)&quot;);
    return;
  }
  logger.info(&quot;Mapping servlet: &apos;&quot; + name + &quot;&apos; to &quot; + this.urlMappings);
  // 把servlet添加到Servlet容器中，Servlet容器启动的时候会加载这个Servlet
  Dynamic added = servletContext.addServlet(name, this.servlet);
  if (added == null) {
    logger.info(&quot;Servlet &quot; + name + &quot; was not registered &quot;
        + &quot;(possibly already registered?)&quot;);
    return;
  }
  // 进行Servlet的一些配置，比如urlMapping，loadOnStartup等
  configure(added);
}
</code></pre><p>类似ServletRegistrationBean的还有ServletListenerRegistrationBean和FilterRegistrationBean，它们都是Servlet初始化器，分别都是在Servlet容器中添加Listener和Filter。</p>
<p>1个小漏洞：如果定义了一个名字为dispatcherServlet的bean，但是它不是DispatcherServlet类型，那么DispatcherServlet就不会被构造，@RestController和@Controller注解的控制器就没办法生效：</p>
<pre><code>@Bean(name = &quot;dispatcherServlet&quot;)
public Object test() {
    return new Object();
}
</code></pre><h2 id="内置Servlet容器的创建和启动"><a href="#内置Servlet容器的创建和启动" class="headerlink" title="内置Servlet容器的创建和启动"></a>内置Servlet容器的创建和启动</h2><p>web程序对应的Spring容器是AnnotationConfigEmbeddedWebApplicationContext，继承自EmbeddedWebApplicationContext。在onRefresh方法中会去创建内置Servlet容器：</p>
<pre><code>@Override
protected void onRefresh() {
  super.onRefresh();
  try {
    // 创建内置Servlet容器
    createEmbeddedServletContainer();
  }
  catch (Throwable ex) {
    throw new ApplicationContextException(&quot;Unable to start embedded container&quot;,
        ex);
  }
}

private void createEmbeddedServletContainer() {
      EmbeddedServletContainer localContainer = this.embeddedServletContainer;
      ServletContext localServletContext = getServletContext();
      // 内置Servlet容器和ServletContext都还没初始化的时候执行
      if (localContainer == null &amp;&amp; localServletContext == null) {
          // 从Spring容器中获取EmbeddedServletContainerFactory，如果EmbeddedServletContainerFactory不存在或者有多个的话会抛出异常中止程序
          EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();
          // 获取Servlet初始化器并创建Servlet容器，依次调用Servlet初始化器中的onStartup方法
          this.embeddedServletContainer = containerFactory
                  .getEmbeddedServletContainer(getSelfInitializer());
      }
      // 内置Servlet容器已经初始化但是ServletContext还没初始化的时候执行
      else if (localServletContext != null) {
          try {
      // 对已经存在的Servlet
      容器依次调用Servlet初始化器中的onStartup方法
              getSelfInitializer().onStartup(localServletContext);
          }
          catch (ServletException ex) {
              throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;,
                      ex);
          }
      }
      initPropertySources();
  }
</code></pre><p>getSelfInitializer方法获得的Servlet初始化器内部会去构造一个ServletContextInitializerBeans(Servlet初始化器的集合)，ServletContextInitializerBeans构造的时候会去Spring容器中查找ServletContextInitializer类型的bean，其中ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean会被找出(如果有定义)，这3种ServletContextInitializer会在onStartup方法中将Servlet、Filter、Listener添加到Servlet容器中(如果我们只定义了Servlet、Filter或者Listener，ServletContextInitializerBeans内部会调用addAdaptableBeans方法把它们包装成RegistrationBean)：</p>
<pre><code>// selfInitialize方法内部调用的getServletContextInitializerBeans方法获得ServletContextInitializerBeans
protected Collection&lt;ServletContextInitializer&gt; getServletContextInitializerBeans() {
  return new ServletContextInitializerBeans(getBeanFactory());
}

private void addServletContextInitializerBean(String beanName,
          ServletContextInitializer initializer, ListableBeanFactory beanFactory) {
      if (initializer instanceof ServletRegistrationBean) {
          Servlet source = ((ServletRegistrationBean) initializer).getServlet();
          addServletContextInitializerBean(Servlet.class, beanName, initializer,
                  beanFactory, source);
      }
      else if (initializer instanceof FilterRegistrationBean) {
          Filter source = ((FilterRegistrationBean) initializer).getFilter();
          addServletContextInitializerBean(Filter.class, beanName, initializer,
                  beanFactory, source);
      }
      else if (initializer instanceof DelegatingFilterProxyRegistrationBean) {
          String source = ((DelegatingFilterProxyRegistrationBean) initializer)
                  .getTargetBeanName();
          addServletContextInitializerBean(Filter.class, beanName, initializer,
                  beanFactory, source);
      }
      else if (initializer instanceof ServletListenerRegistrationBean) {
          EventListener source = ((ServletListenerRegistrationBean&lt;?&gt;) initializer)
                  .getListener();
          addServletContextInitializerBean(EventListener.class, beanName, initializer,
                  beanFactory, source);
      }
      else {
          addServletContextInitializerBean(ServletContextInitializer.class, beanName,
                  initializer, beanFactory, null);
      }
  }
</code></pre><p>Servlet容器创建完毕之后在finishRefresh方法中会去启动：</p>
<pre><code>@Override
protected void finishRefresh() {
  super.finishRefresh();
  // 调用startEmbeddedServletContainer方法
  EmbeddedServletContainer localContainer = startEmbeddedServletContainer();
  if (localContainer != null) {
    // 发布EmbeddedServletContainerInitializedEvent事件
    publishEvent(
        new EmbeddedServletContainerInitializedEvent(this, localContainer));
  }
}

private EmbeddedServletContainer startEmbeddedServletContainer() {
      // 先得到在onRefresh方法中构造的Servlet容器embeddedServletContainer
      EmbeddedServletContainer localContainer = this.embeddedServletContainer;
      if (localContainer != null) {
          // 启动
          localContainer.start();
      }
      return localContainer;
  }
</code></pre><h2 id="自定义Servlet、Filter、Listener"><a href="#自定义Servlet、Filter、Listener" class="headerlink" title="自定义Servlet、Filter、Listener"></a>自定义Servlet、Filter、Listener</h2><p>SpringBoot默认只会添加一个Servlet，也就是DispatcherServlet，如果我们想添加自定义的Servlet或者是Filter还是Listener，有以下几种方法。</p>
<p>1.在Spring容器中声明ServletRegistrationBean、FilterRegistrationBean或者ServletListenerRegistrationBean。原理在<strong>DispatcherServlet的构造</strong>章节中已经说明</p>
<pre><code>@Bean
public ServletRegistrationBean customServlet() {
    return new ServletRegistrationBean(new CustomServlet(), &quot;/custom&quot;);
}

private static class CustomServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(&quot;receive by custom servlet&quot;);
    }
}
</code></pre><p>2.@ServletComponentScan注解和@WebServlet、@WebFilter以及@WebListener注解配合使用。@ServletComponentScan注解启用ImportServletComponentScanRegistrar类，是个ImportBeanDefinitionRegistrar接口的实现类，会被Spring容器所解析。ServletComponentScanRegistrar内部会解析@ServletComponentScan注解，然后会在Spring容器中注册ServletComponentRegisteringPostProcessor，是个BeanFactoryPostProcessor，会去解析扫描出来的类是不是有@WebServlet、@WebListener、@WebFilter这3种注解，有的话把这3种类型的类转换成ServletRegistrationBean、FilterRegistrationBean或者ServletListenerRegistrationBean，然后让Spring容器去解析：</p>
<pre><code>@SpringBootApplication
@ServletComponentScan
public class EmbeddedServletApplication { ... }

@WebServlet(urlPatterns = &quot;/simple&quot;)
public class SimpleServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().write(&quot;receive by SimpleServlet&quot;);
    }

}
</code></pre><p>3.在Spring容器中声明Servlet、Filter或者Listener。因为在ServletContextInitializerBeans内部会去调用addAdaptableBeans方法把它们包装成ServletRegistrationBean：</p>
<pre><code>@Bean(name = &quot;dispatcherServlet&quot;)
public DispatcherServlet myDispatcherServlet() {
    return new DispatcherServlet();
}
</code></pre><h2 id="Whitelabel-Error-Page原理"><a href="#Whitelabel-Error-Page原理" class="headerlink" title="Whitelabel Error Page原理"></a>Whitelabel Error Page原理</h2><p>为什么SpringBoot的程序里Controller发生了错误，我们没有进行异常的捕捉，会跳转到Whitelabel Error Page页面，这是如何实现的？</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/embedded-servlet-container01.png" alt=""></p>
<p>SpringBoot內部提供了一个ErrorController叫做BasicErrorController，对应的@RequestMapping地址为 “server.error.path” 配置 或者 “error.path” 配置，这2个配置没配的话默认是/error，之前分析过ErrorPageCustomizer这个定制化器会把ErrorPage添加到Servlet容器中(这个ErrorPage的path就是上面说的那2个配置)，这样Servlet容器发生错误的时候就会访问ErrorPage配置的path，所以程序发生异常且没有被catch的话，就会走Servlet容器配置的ErrorPage。下面这段代码是BasicErrorController对应的处理请求方法：</p>
<pre><code>@RequestMapping(produces = &quot;text/html&quot;)
public ModelAndView errorHtml(HttpServletRequest request,
  HttpServletResponse response) {
    // 设置响应码
    response.setStatus(getStatus(request).value());
    // 设置一些信息，比如timestamp、statusCode、错误message等
    Map&lt;String, Object&gt; model = getErrorAttributes(request,
        isIncludeStackTrace(request, MediaType.TEXT_HTML));
    // 返回error视图
    return new ModelAndView(&quot;error&quot;, model);
}
</code></pre><p>这里名字为error视图会被BeanNameViewResolver这个视图解析器解析，它会去Spring容器中找出name为error的View，error这个bean在ErrorMvcAutoConfiguration自动化配置类里定义，它返回了一个SpelView视图，也就是刚才见到的Whitelabel Error Page(error.whitelabel.enabled配置需要是true，否则WhitelabelErrorViewConfiguration自动化配置类不会被注册)：</p>
<pre><code>@Configuration
@ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)
@Conditional(ErrorTemplateMissingCondition.class)
protected static class WhitelabelErrorViewConfiguration {

  // Whitelabel Error Page
  private final SpelView defaultErrorView = new SpelView(
      &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;
          + &quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;
          + &quot;&lt;div id=&apos;created&apos;&gt;${timestamp}&lt;/div&gt;&quot;
          + &quot;&lt;div&gt;There was an unexpected error (type=${error}, status=${status}).&lt;/div&gt;&quot;
          + &quot;&lt;div&gt;${message}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;);

  @Bean(name = &quot;error&quot;) // bean的名字是error
  @ConditionalOnMissingBean(name = &quot;error&quot;) // 名字为error的bean不存在才会构造
  public View defaultErrorView() {
    return this.defaultErrorView;
  }

  @Bean
  @ConditionalOnMissingBean(BeanNameViewResolver.class)
  public BeanNameViewResolver beanNameViewResolver() {
    // BeanNameViewResolver会去Spring容器找对应bean的视图
    BeanNameViewResolver resolver = new BeanNameViewResolver();
    resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
    return resolver;
  }

}
</code></pre><p>如果自定义了error页面，比如使用freemarker模板的话存在/templates/error.ftl页面，使用thymeleaf模板的话存在/templates/error.html页面。那么Whitelabel Error Page就不会生效了，而是会跳到这些error页面。这又是如何实现的呢?</p>
<p>这是因为ErrorMvcAutoConfiguration自动化配置类里的内部类  WhitelabelErrorViewConfiguration自动化配置类里有个条件类ErrorTemplateMissingCondition，它的getMatchOutcome方法：</p>
<pre><code>@Override
public ConditionOutcome getMatchOutcome(ConditionContext context,
    AnnotatedTypeMetadata metadata) {
  // 从spring.factories文件中找出key为TemplateAvailabilityProvider为类，TemplateAvailabilityProvider用来查询视图是否可用
  List&lt;TemplateAvailabilityProvider&gt; availabilityProviders = SpringFactoriesLoader
      .loadFactories(TemplateAvailabilityProvider.class,
          context.getClassLoader());
  // 遍历各个TemplateAvailabilityProvider
  for (TemplateAvailabilityProvider availabilityProvider : availabilityProviders)
    // 如果error视图可用
    if (availabilityProvider.isTemplateAvailable(&quot;error&quot;,
        context.getEnvironment(), context.getClassLoader(),
        context.getResourceLoader())) {
      // 条件不生效。WhitelabelErrorViewConfiguration不会被构造
      return ConditionOutcome.noMatch(&quot;Template from &quot;
          + availabilityProvider + &quot; found for error view&quot;);
    }
  }
  // 条件生效。WhitelabelErrorViewConfiguration被构造
  return ConditionOutcome.match(&quot;No error template view detected&quot;);
}
</code></pre><p>比如FreeMarkerTemplateAvailabilityProvider这个TemplateAvailabilityProvider的逻辑如下：</p>
<pre><code>public class FreeMarkerTemplateAvailabilityProvider
        implements TemplateAvailabilityProvider {

    @Override
    public boolean isTemplateAvailable(String view, Environment environment,
            ClassLoader classLoader, ResourceLoader resourceLoader) {
        // 判断是否存在freemarker包中的Configuration类，存在的话才会继续
        if (ClassUtils.isPresent(&quot;freemarker.template.Configuration&quot;, classLoader)) {
            // 构造属性解析器
            RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,
                    &quot;spring.freemarker.&quot;);
            // 设置一些配置
            String loaderPath = resolver.getProperty(&quot;template-loader-path&quot;,
                    FreeMarkerProperties.DEFAULT_TEMPLATE_LOADER_PATH);
            String prefix = resolver.getProperty(&quot;prefix&quot;,
                    FreeMarkerProperties.DEFAULT_PREFIX);
            String suffix = resolver.getProperty(&quot;suffix&quot;,
                    FreeMarkerProperties.DEFAULT_SUFFIX);
            // 查找对应的资源文件是否存在
            return resourceLoader.getResource(loaderPath + prefix + view + suffix)
                    .exists();
        }
        return false;
    }

}
</code></pre><p>所以BeanNameViewResolver不会被构造，Whitelabel Error Page也不会构造，而是直接去找自定义的error视图。</p>
<p>一些测试代码： <a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-embedded-servlet-conatiner" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-embedded-servlet-conatiner</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot内置了Servlet容器，这样项目的发布、部署就不需要额外的Servlet容器，直接启动jar包即可。SpringBoot官方文档上有一个小章节&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-embedded-container&quot;&gt;内置servlet容器支持&lt;/a&gt;用于说明内置Servlet的相关问题。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/&quot;&gt;SpringBoot源码分析之SpringBoot的启动过程&lt;/a&gt;文章中我们了解到如果是Web程序，那么会构造AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器，在&lt;a href=&quot;http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/&quot;&gt;SpringBoot源码分析之Spring容器的refresh过程&lt;/a&gt;文章中我们知道AnnotationConfigEmbeddedWebApplicationContext类型的Spring容器在refresh的过程中会在onRefresh方法中创建内置的Servlet容器。&lt;/p&gt;
&lt;p&gt;接下来，我们分析一下内置的Servlet容器相关的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之条件注解的底层实现</title>
    <link href="http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/"/>
    <id>http://fangjian0423.github.io/2017/05/16/springboot-condition-annotation/</id>
    <published>2017-05-16T11:40:13.000Z</published>
    <updated>2017-05-31T13:16:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot内部提供了特有的注解：条件注解(Conditional Annotation)。比如@ConditionalOnBean、@ConditionalOnClass、@ConditionalOnExpression、@ConditionalOnMissingBean等。</p>
<p>条件注解存在的意义在于动态识别(也可以说是代码自动化执行)。比如@ConditionalOnClass会检查类加载器中是否存在对应的类，如果有的话被注解修饰的类就有资格被Spring容器所注册，否则会被skip。</p>
<p>比如FreemarkerAutoConfiguration这个自动化配置类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; freemarker.template.Configuration.class,</div><div class="line">		FreeMarkerConfigurationFactory.class &#125;)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration.class)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(FreeMarkerProperties.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeMarkerAutoConfiguration</span></span></div></pre></td></tr></table></figure>
<p>这个自动化配置类被@ConditionalOnClass条件注解修饰，这个条件注解存在的意义在于判断类加载器中是否存在freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类，如果都存在的话会在Spring容器中加载这个FreeMarkerAutoConfiguration配置类；否则不会加载。</p>
<a id="more"></a>
<h2 id="条件注解内部的一些基础"><a href="#条件注解内部的一些基础" class="headerlink" title="条件注解内部的一些基础"></a>条件注解内部的一些基础</h2><p>在分析条件注解的底层实现之前，我们先来看一下这些条件注解的定义。以@ConditionalOnClass注解为例，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Conditional</span>(OnClassCondition.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnClass &#123;</div><div class="line">  Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 需要匹配的类</span></div><div class="line">  String[] name() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 需要匹配的类名</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它有2个属性，分别是类数组和字符串数组(作用一样，类型不一样)，而且被@Conditional注解所修饰，这个@Conditional注解有个名为values的Class&lt;? extends Condition&gt;[]类型的属性。 这个Condition是个接口，用于匹配组件是否有资格被容器注册，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">  <span class="comment">// ConditionContext内部会存储Spring容器、应用程序环境信息、资源加载器、类加载器</span></div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说@Conditional注解属性中可以持有多个Condition接口的实现类，所有的Condition接口需要全部匹配成功后这个@Conditional修饰的组件才有资格被注册。</p>
<p>Condition接口有个子接口ConfigurationCondition：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurationCondition</span> <span class="keyword">extends</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function">ConfigurationPhase <span class="title">getConfigurationPhase</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> ConfigurationPhase &#123;</div><div class="line"></div><div class="line">  	PARSE_CONFIGURATION,</div><div class="line"></div><div class="line">  	REGISTER_BEAN</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个子接口是一种特殊的条件接口，多了一个getConfigurationPhase方法，也就是条件注解的生效阶段。只有在ConfigurationPhase中定义的两种阶段下才会生效。</p>
<p>Condition接口有个实现抽象类SpringBootCondition，SpringBoot中所有条件注解对应的条件类都继承这个抽象类。它实现了matches方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context,</span></span></div><div class="line">		AnnotatedTypeMetadata metadata) &#123;</div><div class="line">  String classOrMethodName = getClassOrMethodName(metadata); <span class="comment">// 得到类名或者方法名(条件注解可以作用的类或者方法上)</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">  	ConditionOutcome outcome = getMatchOutcome(context, metadata); <span class="comment">// 抽象方法，具体子类实现。ConditionOutcome记录了匹配结果boolean和log信息</span></div><div class="line">  	logOutcome(classOrMethodName, outcome); <span class="comment">// log记录一下匹配信息</span></div><div class="line">  	recordEvaluation(context, classOrMethodName, outcome); <span class="comment">// 报告记录一下匹配信息</span></div><div class="line">  	<span class="keyword">return</span> outcome.isMatch(); <span class="comment">// 返回是否匹配</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (NoClassDefFoundError ex) &#123;</div><div class="line">  	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">  			<span class="string">"Could not evaluate condition on "</span> + classOrMethodName + <span class="string">" due to "</span></div><div class="line">  					+ ex.getMessage() + <span class="string">" not "</span></div><div class="line">  					+ <span class="string">"found. Make sure your own configuration does not rely on "</span></div><div class="line">  					+ <span class="string">"that class. This can also happen if you are "</span></div><div class="line">  					+ <span class="string">"@ComponentScanning a springframework package (e.g. if you "</span></div><div class="line">  					+ <span class="string">"put a @ComponentScan in the default package by mistake)"</span>,</div><div class="line">  			ex);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (RuntimeException ex) &#123;</div><div class="line">  	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">  			<span class="string">"Error processing condition on "</span> + getName(metadata), ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基于Class的条件注解"><a href="#基于Class的条件注解" class="headerlink" title="基于Class的条件注解"></a>基于Class的条件注解</h2><p>SpringBoot提供了两个基于Class的条件注解：@ConditionalOnClass(类加载器中存在指明的类)或者@ConditionalOnMissingClass(类加载器中不存在指明的类)。</p>
<p>@ConditionalOnClass或者@ConditionalOnMissingClass注解对应的条件类是OnClassCondition，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE) <span class="comment">// 优先级、最高级别</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnClassCondition</span> <span class="keyword">extends</span> <span class="title">SpringBootCondition</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></div><div class="line">  		AnnotatedTypeMetadata metadata) &#123;</div><div class="line"></div><div class="line">  	StringBuffer matchMessage = <span class="keyword">new</span> StringBuffer(); <span class="comment">// 记录匹配信息</span></div><div class="line"></div><div class="line">  	MultiValueMap&lt;String, Object&gt; onClasses = getAttributes(metadata,</div><div class="line">  			ConditionalOnClass.class); <span class="comment">// 得到@ConditionalOnClass注解的属性</span></div><div class="line">  	<span class="keyword">if</span> (onClasses != <span class="keyword">null</span>) &#123; <span class="comment">// 如果属性存在</span></div><div class="line">  		List&lt;String&gt; missing = getMatchingClasses(onClasses, MatchType.MISSING,</div><div class="line">  				context); <span class="comment">// 得到在类加载器中不存在的类</span></div><div class="line">  		<span class="keyword">if</span> (!missing.isEmpty()) &#123; <span class="comment">// 如果存在类加载器中不存在对应的类，返回一个匹配失败的ConditionalOutcome</span></div><div class="line">  			<span class="keyword">return</span> ConditionOutcome</div><div class="line">  					.noMatch(<span class="string">"required @ConditionalOnClass classes not found: "</span></div><div class="line">  							+ StringUtils.collectionToCommaDelimitedString(missing));</div><div class="line">  		&#125;</div><div class="line">                <span class="comment">// 如果类加载器中存在对应的类的话，匹配信息进行记录</span></div><div class="line">  		matchMessage.append(<span class="string">"@ConditionalOnClass classes found: "</span></div><div class="line">  				+ StringUtils.collectionToCommaDelimitedString(</div><div class="line">  						getMatchingClasses(onClasses, MatchType.PRESENT, context)));</div><div class="line">  	&#125;</div><div class="line">        <span class="comment">// 对@ConditionalOnMissingClass注解做相同的逻辑处理(说明@ConditionalOnClass和@ConditionalOnMissingClass可以一起使用)</span></div><div class="line">  	MultiValueMap&lt;String, Object&gt; onMissingClasses = getAttributes(metadata,</div><div class="line">  			ConditionalOnMissingClass.class);</div><div class="line">  	<span class="keyword">if</span> (onMissingClasses != <span class="keyword">null</span>) &#123;</div><div class="line">  		List&lt;String&gt; present = getMatchingClasses(onMissingClasses, MatchType.PRESENT,</div><div class="line">  				context);</div><div class="line">  		<span class="keyword">if</span> (!present.isEmpty()) &#123;</div><div class="line">  			<span class="keyword">return</span> ConditionOutcome</div><div class="line">  					.noMatch(<span class="string">"required @ConditionalOnMissing classes found: "</span></div><div class="line">  							+ StringUtils.collectionToCommaDelimitedString(present));</div><div class="line">  		&#125;</div><div class="line">  		matchMessage.append(matchMessage.length() == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">" "</span>);</div><div class="line">  		matchMessage.append(<span class="string">"@ConditionalOnMissing classes not found: "</span></div><div class="line">  				+ StringUtils.collectionToCommaDelimitedString(getMatchingClasses(</div><div class="line">  						onMissingClasses, MatchType.MISSING, context)));</div><div class="line">  	&#125;</div><div class="line">        <span class="comment">// 返回全部匹配成功的ConditionalOutcome</span></div><div class="line">  	<span class="keyword">return</span> ConditionOutcome.match(matchMessage.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">enum</span> MatchType &#123; <span class="comment">// 枚举：匹配类型。用于查询类名在对应的类加载器中是否存在。</span></div><div class="line"></div><div class="line">  	PRESENT &#123; <span class="comment">// 匹配成功</span></div><div class="line">  		<span class="meta">@Override</span></div><div class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ConditionContext context)</span> </span>&#123;</div><div class="line">  			<span class="keyword">return</span> ClassUtils.isPresent(className, context.getClassLoader());</div><div class="line">  		&#125;</div><div class="line">  	&#125;,</div><div class="line"></div><div class="line">  	MISSING &#123; <span class="comment">// 匹配不成功</span></div><div class="line">  		<span class="meta">@Override</span></div><div class="line">  		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ConditionContext context)</span> </span>&#123;</div><div class="line">  			<span class="keyword">return</span> !ClassUtils.isPresent(className, context.getClassLoader());</div><div class="line">  		&#125;</div><div class="line">  	&#125;;</div><div class="line"></div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ConditionContext context)</span></span>;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如FreemarkerAutoConfiguration中的@ConditionalOnClass注解中有value属性是freemarker.template.Configuration.class和FreeMarkerConfigurationFactory.class。在OnClassCondition执行过程中得到的最终ConditionalOutcome中的log message如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnClass</span> classes found: freemarker.template.Configuration,org.springframework.ui.freemarker.FreeMarkerConfigurationFactory</div></pre></td></tr></table></figure>
<h2 id="基于Bean的条件注解"><a href="#基于Bean的条件注解" class="headerlink" title="基于Bean的条件注解"></a>基于Bean的条件注解</h2><p>@ConditionalOnBean(Spring容器中存在指明的bean)、@ConditionalOnMissingBean(Spring容器中不存在指明的bean)以及ConditionalOnSingleCandidate(Spring容器中存在且只存在一个指明的bean)都是基于Bean的条件注解，它们对应的条件类是ConditionOnBean。</p>
<p>@ConditionOnBean注解定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Conditional</span>(OnBeanCondition.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnBean &#123;</div><div class="line">  Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean类型</span></div><div class="line">  String[] type() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean类型的类名</span></div><div class="line">  Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean注解</span></div><div class="line">  String[] name() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 匹配的bean的名字</span></div><div class="line">  <span class="function">SearchStrategy <span class="title">search</span><span class="params">()</span> <span class="keyword">default</span> SearchStrategy.ALL</span>; <span class="comment">// 搜索策略。提供CURRENT(只在当前容器中找)、PARENTS(只在所有的父容器中找；但是不包括当前容器)和ALL(CURRENT和PARENTS的组合)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OnBeanCondition条件类的匹配代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></div><div class="line">    AnnotatedTypeMetadata metadata) &#123;</div><div class="line">  StringBuffer matchMessage = <span class="keyword">new</span> StringBuffer(); <span class="comment">// 记录匹配信息</span></div><div class="line">  <span class="keyword">if</span> (metadata.isAnnotated(ConditionalOnBean.class.getName())) &#123;</div><div class="line">    BeanSearchSpec spec = <span class="keyword">new</span> BeanSearchSpec(context, metadata,</div><div class="line">        ConditionalOnBean.class); <span class="comment">// 构造一个BeanSearchSpec，会从@ConditionalOnBean注解中获取属性，然后设置到BeanSearchSpec中</span></div><div class="line">    List&lt;String&gt; matching = getMatchingBeans(context, spec); <span class="comment">// 从BeanFactory中根据策略找出所有匹配的bean</span></div><div class="line">    <span class="keyword">if</span> (matching.isEmpty()) &#123; <span class="comment">// 如果没有匹配的bean，返回一个没有匹配成功的ConditionalOutcome</span></div><div class="line">      <span class="keyword">return</span> ConditionOutcome</div><div class="line">          .noMatch(<span class="string">"@ConditionalOnBean "</span> + spec + <span class="string">" found no beans"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果找到匹配的bean，匹配信息进行记录</span></div><div class="line">    matchMessage.append(</div><div class="line">        <span class="string">"@ConditionalOnBean "</span> + spec + <span class="string">" found the following "</span> + matching);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123; <span class="comment">// 相同的逻辑，针对@ConditionalOnSingleCandidate注解</span></div><div class="line">    BeanSearchSpec spec = <span class="keyword">new</span> SingleCandidateBeanSearchSpec(context, metadata,</div><div class="line">        ConditionalOnSingleCandidate.class);</div><div class="line">    List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class="line">    <span class="keyword">if</span> (matching.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(</div><div class="line">          <span class="string">"@ConditionalOnSingleCandidate "</span> + spec + <span class="string">" found no beans"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matching)) &#123; <span class="comment">// 多了一层判断，判断是否只有一个bean</span></div><div class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(<span class="string">"@ConditionalOnSingleCandidate "</span> + spec</div><div class="line">          + <span class="string">" found no primary candidate amongst the"</span> + <span class="string">" following "</span></div><div class="line">          + matching);</div><div class="line">    &#125;</div><div class="line">    matchMessage.append(<span class="string">"@ConditionalOnSingleCandidate "</span> + spec + <span class="string">" found "</span></div><div class="line">        + <span class="string">"a primary candidate amongst the following "</span> + matching);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123; <span class="comment">// 相同的逻辑，针对@ConditionalOnMissingBean注解</span></div><div class="line">    BeanSearchSpec spec = <span class="keyword">new</span> BeanSearchSpec(context, metadata,</div><div class="line">        ConditionalOnMissingBean.class);</div><div class="line">    List&lt;String&gt; matching = getMatchingBeans(context, spec);</div><div class="line">    <span class="keyword">if</span> (!matching.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> ConditionOutcome.noMatch(<span class="string">"@ConditionalOnMissingBean "</span> + spec</div><div class="line">          + <span class="string">" found the following "</span> + matching);</div><div class="line">    &#125;</div><div class="line">    matchMessage.append(matchMessage.length() == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">" "</span>);</div><div class="line">    matchMessage.append(<span class="string">"@ConditionalOnMissingBean "</span> + spec + <span class="string">" found no beans"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ConditionOutcome.match(matchMessage.toString()); <span class="comment">//返回匹配成功的ConditonalOutcome</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpringBoot还提供了其他比如ConditionalOnJava、ConditionalOnNotWebApplication、ConditionalOnWebApplication、ConditionalOnResource、ConditionalOnProperty、ConditionalOnExpression等条件注解，有兴趣的读者可以自行查看它们的底层处理逻辑。</p>
<h2 id="各种条件注解的总结"><a href="#各种条件注解的总结" class="headerlink" title="各种条件注解的总结"></a>各种条件注解的总结</h2><table>
<thead>
<tr>
<th>条件注解</th>
<th>对应的Condition处理类</th>
<th>处理逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnBean</td>
<td>OnBeanCondition</td>
<td>Spring容器中是否存在对应的实例。可以通过实例的类型、类名、注解、昵称去容器中查找(可以配置从当前容器中查找或者父容器中查找或者两者一起查找)这些属性都是数组，通过”与”的关系进行查找</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>OnClassCondition</td>
<td>类加载器中是否存在对应的类。可以通过Class指定(value属性)或者Class的全名指定(name属性)。如果是多个类或者多个类名的话，关系是”与”关系，也就是说这些类或者类名都必须同时在类加载器中存在</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>OnExpressionCondition</td>
<td>判断SpEL 表达式是否成立</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>OnJavaCondition</td>
<td>指定Java版本是否符合要求。内部有2个属性value和range。value表示一个枚举的Java版本，range表示比这个老或者新于等于指定的Java版本(默认是新于等于)。内部会基于某些jdk版本特有的类去类加载器中查询，比如如果是jdk9，类加载器中需要存在java.security.cert.URICertStoreParameters；如果是jdk8，类加载器中需要存在java.util.function.Function；如果是jdk7，类加载器中需要存在java.nio.file.Files；如果是jdk6，类加载器中需要存在java.util.ServiceLoader</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>OnBeanCondition</td>
<td>Spring容器中是否缺少对应的实例。可以通过实例的类型、类名、注解、昵称去容器中查找(可以配置从当前容器中查找或者父容器中查找或者两者一起查找)这些属性都是数组，通过”与”的关系进行查找。还多了2个属性ignored(类名)和ignoredType(类名)，匹配的过程中会忽略这些bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>OnClassCondition</td>
<td>跟ConditionalOnClass的处理逻辑一样，只是条件相反，在类加载器中不存在对应的类</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>OnWebApplicationCondition</td>
<td>应用程序是否是非Web程序，没有提供属性，只是一个标识。会从判断Web程序特有的类是否存在，环境是否是Servlet环境，容器是否是Web容器等</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>OnPropertyCondition</td>
<td>应用环境中的屬性是否存在。提供prefix、name、havingValue以及matchIfMissing属性。prefix表示属性名的前缀，name是属性名，havingValue是具体的属性值，matchIfMissing是个boolean值，如果属性不存在，这个matchIfMissing为true的话，会继续验证下去，否则属性不存在的话直接就相当于匹配不成功</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>OnResourceCondition</td>
<td>是否存在指定的资源文件。只有一个属性resources，是个String数组。会从类加载器中去查询对应的资源文件是否存在</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>OnBeanCondition</td>
<td>Spring容器中是否存在且只存在一个对应的实例。只有3个属性value、type、search。跟ConditionalOnBean中的这3种属性值意义一样</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>OnWebApplicationCondition</td>
<td>应用程序是否是Web程序，没有提供属性，只是一个标识。会从判断Web程序特有的类是否存在，环境是否是Servlet环境，容器是否是Web容器等</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>例子</th>
<th>例子意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnBean(javax.sql.DataSource.class)</td>
<td>Spring容器或者所有父容器中需要存在至少一个javax.sql.DataSource类的实例</td>
</tr>
<tr>
<td>@ConditionalOnClass<br>({ Configuration.class,<br>FreeMarkerConfigurationFactory.class })</td>
<td>类加载器中必须存在Configuration和FreeMarkerConfigurationFactory这两个类</td>
</tr>
<tr>
<td>@ConditionalOnExpression<br>(“‘${server.host}’==’localhost’”)</td>
<td>server.host配置项的值需要是localhost</td>
</tr>
<tr>
<td>ConditionalOnJava(JavaVersion.EIGHT)</td>
<td>Java版本至少是8</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</td>
<td>Spring当前容器中不存在ErrorController类型的bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass<br>(“GenericObjectPool”)</td>
<td>类加载器中不能存在GenericObjectPool这个类</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>必须在非Web应用下才会生效</td>
</tr>
<tr>
<td>@ConditionalOnProperty(prefix = “spring.aop”, name = “auto”, havingValue = “true”, matchIfMissing = true)</td>
<td>应用程序的环境中必须有spring.aop.auto这项配置，且它的值是true或者环境中不存在spring.aop.auto配置(matchIfMissing为true)</td>
</tr>
<tr>
<td>@ConditionalOnResource<br>(resources=”mybatis.xml”)</td>
<td>类加载路径中必须存在mybatis.xml文件</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate<br>(PlatformTransactionManager.class)</td>
<td>Spring当前或父容器中必须存在PlatformTransactionManager这个类型的实例，且只有一个实例</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>必须在Web应用下才会生效</td>
</tr>
</tbody>
</table>
<h2 id="SpringBoot条件注解的激活机制"><a href="#SpringBoot条件注解的激活机制" class="headerlink" title="SpringBoot条件注解的激活机制"></a>SpringBoot条件注解的激活机制</h2><p>分析完了条件注解的执行逻辑之后，接下来的问题就是SpringBoot是如何让这些条件注解生效的？</p>
<p>SpringBoot使用ConditionEvaluator这个内部类完成条件注解的解析和判断。</p>
<p>在Spring容器的refresh过程中，只有跟解析或者注册bean有关系的类都会使用ConditionEvaluator完成条件注解的判断，这个过程中一些类不满足条件的话就会被skip。这些类比如有AnnotatedBeanDefinitionReader、ConfigurationClassBeanDefinitionReader、ConfigurationClassParse、ClassPathScanningCandidateComponentProvider等。</p>
<p>比如ConfigurationClassParser的构造函数会初始化内部属性conditionEvaluator：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConfigurationClassParser</span><span class="params">(MetadataReaderFactory metadataReaderFactory,</span></span></div><div class="line">    ProblemReporter problemReporter, Environment environment, ResourceLoader resourceLoader,</div><div class="line">    BeanNameGenerator componentScanBeanNameGenerator, BeanDefinitionRegistry registry) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.metadataReaderFactory = metadataReaderFactory;</div><div class="line">  <span class="keyword">this</span>.problemReporter = problemReporter;</div><div class="line">  <span class="keyword">this</span>.environment = environment;</div><div class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</div><div class="line">  <span class="keyword">this</span>.registry = registry;</div><div class="line">  <span class="keyword">this</span>.componentScanParser = <span class="keyword">new</span> ComponentScanAnnotationParser(</div><div class="line">      resourceLoader, environment, componentScanBeanNameGenerator, registry);</div><div class="line">  <span class="comment">// 构造ConditionEvaluator用于处理条件注解</span></div><div class="line">  <span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, resourceLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConfigurationClassParser对每个配置类进行解析的时候都会使用ConditionEvaluator：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConditionEvaluator的skip方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldSkip</span><span class="params">(AnnotatedTypeMetadata metadata, ConfigurationPhase phase)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果这个类没有被@Conditional注解所修饰，不会skip</span></div><div class="line">  <span class="keyword">if</span> (metadata == <span class="keyword">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 如果参数中沒有设置条件注解的生效阶段</span></div><div class="line">  <span class="keyword">if</span> (phase == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// 是配置类的话直接使用PARSE_CONFIGURATION阶段</span></div><div class="line">    <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> AnnotationMetadata &amp;&amp;</div><div class="line">        ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123;</div><div class="line">      <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 否则使用REGISTER_BEAN阶段</span></div><div class="line">    <span class="keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 要解析的配置类的条件集合</span></div><div class="line">  List&lt;Condition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;Condition&gt;();</div><div class="line">  <span class="comment">// 获取配置类的条件注解得到条件数据，并添加到集合中</span></div><div class="line">  <span class="keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</div><div class="line">    <span class="keyword">for</span> (String conditionClass : conditionClasses) &#123;</div><div class="line">      Condition condition = getCondition(conditionClass, <span class="keyword">this</span>.context.getClassLoader());</div><div class="line">      conditions.add(condition);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 对条件集合做个排序</span></div><div class="line">  AnnotationAwareOrderComparator.sort(conditions);</div><div class="line">  <span class="comment">// 遍历条件集合</span></div><div class="line">  <span class="keyword">for</span> (Condition condition : conditions) &#123;</div><div class="line">    ConfigurationPhase requiredPhase = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> ConfigurationCondition) &#123;</div><div class="line">      requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 没有这个解析类不需要阶段的判断或者解析类和参数中的阶段一致才会继续进行</span></div><div class="line">    <span class="keyword">if</span> (requiredPhase == <span class="keyword">null</span> || requiredPhase == phase) &#123;</div><div class="line">      <span class="comment">// 阶段一致切不满足条件的话，返回true并跳过这个bean的解析</span></div><div class="line">      <span class="keyword">if</span> (!condition.matches(<span class="keyword">this</span>.context, metadata)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SpringBoot在条件注解的解析log记录在了ConditionEvaluationReport类中，可以通过BeanFactory获取(BeanFactory是有父子关系的；每个BeanFactory都存有一份ConditionEvaluationReport，互不相干)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ConditionEvaluationReport conditionEvaluationReport = beanFactory.getBean(<span class="string">"autoConfigurationReport"</span>, ConditionEvaluationReport.class);</div><div class="line">Map&lt;String, ConditionEvaluationReport.ConditionAndOutcomes&gt; result = conditionEvaluationReport.getConditionAndOutcomesBySource();</div><div class="line"><span class="keyword">for</span>(String key : result.keySet()) &#123;</div><div class="line">    ConditionEvaluationReport.ConditionAndOutcomes conditionAndOutcomes = result.get(key);</div><div class="line">    Iterator&lt;ConditionEvaluationReport.ConditionAndOutcome&gt; iterator = conditionAndOutcomes.iterator();</div><div class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">        ConditionEvaluationReport.ConditionAndOutcome conditionAndOutcome = iterator.next();</div><div class="line">        System.out.println(key + <span class="string">" -- "</span> + conditionAndOutcome.getCondition().getClass().getSimpleName() + <span class="string">" -- "</span> + conditionAndOutcome.getOutcome());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印出条件注解下的类加载信息：</p>
<pre><code>.......
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: freemarker.template.Configuration,org.springframework.ui.freemarker.FreeMarkerConfigurationFactory
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: groovy.text.markup.MarkupTemplateEngine
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: com.google.gson.Gson
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: org.h2.server.web.WebServlet
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: org.springframework.hateoas.Resource,org.springframework.plugin.core.Plugin
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration -- OnClassCondition -- required @ConditionalOnClass classes not found: com.hazelcast.core.HazelcastInstance
.......
</code></pre><p>一些测试的例子代码在 <a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-conditional" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-conditional</a> 上</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot内部提供了特有的注解：条件注解(Conditional Annotation)。比如@ConditionalOnBean、@ConditionalOnClass、@ConditionalOnExpression、@ConditionalOnMissingBean等。&lt;/p&gt;
&lt;p&gt;条件注解存在的意义在于动态识别(也可以说是代码自动化执行)。比如@ConditionalOnClass会检查类加载器中是否存在对应的类，如果有的话被注解修饰的类就有资格被Spring容器所注册，否则会被skip。&lt;/p&gt;
&lt;p&gt;比如FreemarkerAutoConfiguration这个自动化配置类的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@ConditionalOnClass&lt;/span&gt;(&amp;#123; freemarker.template.Configuration.class,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		FreeMarkerConfigurationFactory.class &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@AutoConfigureAfter&lt;/span&gt;(WebMvcAutoConfiguration.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;(FreeMarkerProperties.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FreeMarkerAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个自动化配置类被@ConditionalOnClass条件注解修饰，这个条件注解存在的意义在于判断类加载器中是否存在freemarker.template.Configuration和FreeMarkerConfigurationFactory这两个类，如果都存在的话会在Spring容器中加载这个FreeMarkerAutoConfiguration配置类；否则不会加载。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之Spring容器的refresh过程</title>
    <link href="http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/"/>
    <id>http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/</id>
    <published>2017-05-10T11:55:21.000Z</published>
    <updated>2017-08-23T07:38:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们分析了SpringBoot的启动过程：构造SpringApplication并调用它的run方法。其中构造SpringApplication的时候会初始化一些监听器和初始化器；run方法调用的过程中会有对应的监听器监听，并且会创建Spring容器。</p>
<p>Spring容器创建之后，会调用它的refresh方法，refresh的时候会做很多事情：比如完成配置类的解析、各种BeanFactoryPostProcessor和BeanPostProcessor的注册、国际化配置的初始化、web内置容器的构造等等。</p>
<p>我们来分析一下这个refresh过程。</p>
<a id="more"></a>
<p>还是以web程序为例，那么对应的Spring容器为AnnotationConfigEmbeddedWebApplicationContext。它的refresh方法调用了父类AbstractApplicationContext的refresh方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">  <span class="comment">// refresh过程只能一个线程处理，不允许并发执行</span></div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">    prepareRefresh();</div><div class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line">    prepareBeanFactory(beanFactory);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      postProcessBeanFactory(beanFactory);</div><div class="line">      invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">      registerBeanPostProcessors(beanFactory);</div><div class="line">      initMessageSource();</div><div class="line">      initApplicationEventMulticaster();</div><div class="line">      onRefresh();</div><div class="line">      registerListeners();</div><div class="line">      finishBeanFactoryInitialization(beanFactory);</div><div class="line">      finishRefresh();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</div><div class="line">            <span class="string">"cancelling refresh attempt: "</span> + ex);</div><div class="line">      &#125;</div><div class="line">      destroyBeans();</div><div class="line">      cancelRefresh(ex);</div><div class="line">      <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">      resetCommonCaches();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="prepareRefresh方法"><a href="#prepareRefresh方法" class="headerlink" title="prepareRefresh方法"></a>prepareRefresh方法</h2><p>表示在真正做refresh操作之前需要准备做的事情：</p>
<ol>
<li>设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。</li>
<li>初始化属性源信息(Property)</li>
<li>验证环境信息里一些必须存在的属性</li>
</ol>
<h2 id="prepareBeanFactory方法"><a href="#prepareBeanFactory方法" class="headerlink" title="prepareBeanFactory方法"></a>prepareBeanFactory方法</h2><p>从Spring容器获取BeanFactory(Spring Bean容器)并进行相关的设置为后续的使用做准备：</p>
<ol>
<li>设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)</li>
<li>添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。因为ApplicationContextAwareProcessor把这5个接口的实现工作做了</li>
<li>设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器</li>
<li>注入一些其它信息的bean，比如environment、systemProperties等</li>
</ol>
<h2 id="postProcessBeanFactory方法"><a href="#postProcessBeanFactory方法" class="headerlink" title="postProcessBeanFactory方法"></a>postProcessBeanFactory方法</h2><p>BeanFactory设置之后再进行后续的一些BeanFactory操作。</p>
<p>不同的Spring容器做不同的操作。比如GenericWebApplicationContext容器会在BeanFactory中添加ServletContextAwareProcessor用于处理ServletContextAware类型的bean初始化的时候调用setServletContext或者setServletConfig方法(跟ApplicationContextAwareProcessor原理一样)。</p>
<p>AnnotationConfigEmbeddedWebApplicationContext对应的postProcessBeanFactory方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">  <span class="comment">// 调用父类EmbeddedWebApplicationContext的实现</span></div><div class="line">  <span class="keyword">super</span>.postProcessBeanFactory(beanFactory);</div><div class="line">  <span class="comment">// 查看basePackages属性，如果设置了会使用ClassPathBeanDefinitionScanner去扫描basePackages包下的bean并注册</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.basePackages != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.basePackages.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.basePackages);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 查看annotatedClasses属性，如果设置了会使用AnnotatedBeanDefinitionReader去注册这些bean</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.annotatedClasses != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.annotatedClasses.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.reader.register(<span class="keyword">this</span>.annotatedClasses);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>父类EmbeddedWebApplicationContext的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</div><div class="line">  beanFactory.addBeanPostProcessor(</div><div class="line">      <span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</div><div class="line">  beanFactory.ignoreDependencyInterface(ServletContextAware.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="invokeBeanFactoryPostProcessors方法"><a href="#invokeBeanFactoryPostProcessors方法" class="headerlink" title="invokeBeanFactoryPostProcessors方法"></a>invokeBeanFactoryPostProcessors方法</h2><p>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。</p>
<p>介绍两个接口：</p>
<ol>
<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>
<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>
</ol>
<p>基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：</p>
<pre><code>AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
</code></pre><p>invokeBeanFactoryPostProcessors方法处理BeanFactoryPostProcessor的逻辑如下：</p>
<p>从Spring容器中找出BeanDefinitionRegistryPostProcessor类型的bean(这些processor是在容器刚创建的时候通过构造AnnotatedBeanDefinitionReader的时候注册到容器中的)，然后按照优先级分别执行，优先级的逻辑如下：</p>
<ol>
<li>实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor先全部找出来，然后排序后依次执行</li>
<li>实现Ordered接口的BeanDefinitionRegistryPostProcessor找出来，然后排序后依次执行</li>
<li>没有实现PriorityOrdered和Ordered接口的BeanDefinitionRegistryPostProcessor找出来执行并依次执行</li>
</ol>
<p>接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。</p>
<p>这里需要说明的是ConfigurationClassPostProcessor这个processor是优先级最高的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用ConfigurationClassParser去解析这个类。ConfigurationClassParser内部有个Map<configurationclass, configurationclass="">类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中。</configurationclass,></p>
<p>这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。</p>
<p>在我们的程序中，只有主类RefreshContextApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser解析。解析过程如下：</p>
<ol>
<li>处理@PropertySources注解：进行一些配置信息的解析</li>
<li>处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析</li>
<li>处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：<ol>
<li>遍历这些@Import注解内部的属性类集合</li>
<li>如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第6步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理</li>
<li>如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中</li>
<li>其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类</li>
</ol>
</li>
<li>处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中</li>
<li>处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中</li>
<li>处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理</li>
</ol>
<p>这里@SpringBootApplication注解被@EnableAutoConfiguration修饰，@EnableAutoConfiguration注解被@Import(EnableAutoConfigurationImportSelector.class)修饰，所以在第3步会找出这个@Import修饰的类EnableAutoConfigurationImportSelector，这个类刚好实现了DeferredImportSelector接口，接着就会在第6步被执行。第6步selectImport得到的类就是自动化配置类。</p>
<p>EnableAutoConfigurationImportSelector的selectImport方法会在spring.factories文件中找出key为EnableAutoConfiguration对应的值，有81个，这81个就是所谓的自动化配置类(XXXAutoConfiguration)。</p>
<p>ConfigurationClassParser解析完成之后，被解析出来的类会放到configurationClasses属性中。然后使用ConfigurationClassBeanDefinitionReader去解析这些类。</p>
<p>这个时候这些bean只是被加载到了Spring容器中。下面这段代码是ConfigurationClassBeanDefinitionReader的解析bean过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</div><div class="line">  TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</div><div class="line">  <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</div><div class="line">    <span class="comment">// 对每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法</span></div><div class="line">    loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span></div><div class="line">    TrackedConditionEvaluator trackedConditionEvaluator) &#123;</div><div class="line">  <span class="comment">// 使用条件注解判断是否需要跳过这个配置类</span></div><div class="line">  <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</div><div class="line">    <span class="comment">// 跳过配置类的话在Spring容器中移除bean的注册</span></div><div class="line">    String beanName = configClass.getBeanName();</div><div class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</div><div class="line">      <span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.importRegistry.removeImportingClassFor(configClass.getMetadata().getClassName());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</div><div class="line">    <span class="comment">// 如果自身是被@Import注释所import的，注册自己</span></div><div class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 注册方法中被@Bean注解修饰的bean</span></div><div class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</div><div class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 注册@ImportResource注解注释的资源文件中的bean</span></div><div class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</div><div class="line">  <span class="comment">// 注册@Import注解中的ImportBeanDefinitionRegistrar接口的registerBeanDefinitions</span></div><div class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>invokeBeanFactoryPostProcessors方法总结来说就是从Spring容器中找出BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的实现类并按照一定的规则顺序进行执行。 其中ConfigurationClassPostProcessor这个BeanDefinitionRegistryPostProcessor优先级最高，它会对项目中的@Configuration注解修饰的类(@Component、@ComponentScan、@Import、@ImportResource修饰的类也会被处理)进行解析，解析完成之后把这些bean注册到BeanFactory中。需要注意的是这个时候注册进来的bean还没有实例化。</p>
<p>下面这图就是对ConfigurationClassPostProcessor后置器的总结：</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/configuration-annotation-process.png" alt=""></p>
<h2 id="registerBeanPostProcessors方法"><a href="#registerBeanPostProcessors方法" class="headerlink" title="registerBeanPostProcessors方法"></a>registerBeanPostProcessors方法</h2><p>从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中。之后bean被实例化的时候会调用这个BeanPostProcessor。</p>
<p>该方法委托给了PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法执行。这里的过程跟invokeBeanFactoryPostProcessors类似：</p>
<ol>
<li>先找出实现了PriorityOrdered接口的BeanPostProcessor并排序后加到BeanFactory的BeanPostProcessor集合中</li>
<li>找出实现了Ordered接口的BeanPostProcessor并排序后加到BeanFactory的BeanPostProcessor集合中</li>
<li>没有实现PriorityOrdered和Ordered接口的BeanPostProcessor加到BeanFactory的BeanPostProcessor集合中</li>
</ol>
<p>这些已经存在的BeanPostProcessor在postProcessBeanFactory方法中已经说明，都是由AnnotationConfigUtils的registerAnnotationConfigProcessors方法注册的。这些BeanPostProcessor包括有AutowiredAnnotationBeanPostProcessor(处理被@Autowired注解修饰的bean并注入)、RequiredAnnotationBeanPostProcessor(处理被@Required注解修饰的方法)、CommonAnnotationBeanPostProcessor(处理@PreDestroy、@PostConstruct、@Resource等多个注解的作用)等。</p>
<p>如果是自定义的BeanPostProcessor，已经被ConfigurationClassPostProcessor注册到容器内。</p>
<p>这些BeanPostProcessor会在这个方法内被实例化(通过调用BeanFactory的getBean方法，如果没有找到实例化的类，就会去实例化)。</p>
<h2 id="initMessageSource方法"><a href="#initMessageSource方法" class="headerlink" title="initMessageSource方法"></a>initMessageSource方法</h2><p>在Spring容器中初始化一些国际化相关的属性。</p>
<h2 id="initApplicationEventMulticaster方法"><a href="#initApplicationEventMulticaster方法" class="headerlink" title="initApplicationEventMulticaster方法"></a>initApplicationEventMulticaster方法</h2><p>在Spring容器中初始化事件广播器，事件广播器用于事件的发布。</p>
<p>在<a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a>中分析过，EventPublishingRunListener这个SpringApplicationRunListener会监听事件，其中发生contextPrepared事件的时候EventPublishingRunListener会把事件广播器注入到BeanFactory中。</p>
<p>所以initApplicationEventMulticaster不再需要再次注册，只需要拿出BeanFactory中的事件广播器然后设置到Spring容器的属性中即可。如果没有使用SpringBoot的话，Spring容器得需要自己初始化事件广播器。</p>
<h2 id="onRefresh方法"><a href="#onRefresh方法" class="headerlink" title="onRefresh方法"></a>onRefresh方法</h2><p>一个模板方法，不同的Spring容器做不同的事情。</p>
<p>比如web程序的容器AnnotationConfigEmbeddedWebApplicationContext中会调用createEmbeddedServletContainer方法去创建内置的Servlet容器。</p>
<p>目前SpringBoot只支持3种内置的Servlet容器：</p>
<ol>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ol>
<h2 id="registerListeners方法"><a href="#registerListeners方法" class="headerlink" title="registerListeners方法"></a>registerListeners方法</h2><p>把Spring容器内的时间监听器和BeanFactory中的时间监听器都添加的事件广播器中。</p>
<p>然后如果存在early event的话，广播出去。</p>
<h2 id="finishBeanFactoryInitialization方法"><a href="#finishBeanFactoryInitialization方法" class="headerlink" title="finishBeanFactoryInitialization方法"></a>finishBeanFactoryInitialization方法</h2><p>实例化BeanFactory中已经被注册但是未实例化的所有实例(懒加载的不需要实例化)。</p>
<p>比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。</p>
<p>实例化的过程各种BeanPostProcessor开始起作用。</p>
<h2 id="finishRefresh方法"><a href="#finishRefresh方法" class="headerlink" title="finishRefresh方法"></a>finishRefresh方法</h2><p>refresh做完之后需要做的其他事情。</p>
<ol>
<li>初始化生命周期处理器，并设置到Spring容器中(LifecycleProcessor)</li>
<li>调用生命周期处理器的onRefresh方法，这个方法会找出Spring容器中实现了SmartLifecycle接口的类并进行start方法的调用</li>
<li>发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</li>
<li>调用LiveBeansView的registerApplicationContext方法：如果设置了JMX相关的属性，则就调用该方法</li>
<li>发布EmbeddedServletContainerInitializedEvent事件告知对应的ApplicationListener进行响应的操作</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring容器的refresh过程就是上述11个方法的介绍。内容还是非常多的，本文也只是说了个大概，像bean的实例化过程没有具体去分析，这方面的内容以后会看情况去做分析。</p>
<p>这篇文章也是为之后的文章比如内置Servlet容器的创建启动、条件注解的使用等打下基础。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>写了一个例子用来验证容器的refresh过程，包括bean解析，processor的使用、Lifecycle的使用等。</p>
<p>可以启动项目debug去看看对应的过程，这样对Spring容器会有一个更好的理解。</p>
<p>地址在：<a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-refresh-context" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-refresh-context</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，我们分析了SpringBoot的启动过程：构造SpringApplication并调用它的run方法。其中构造SpringApplication的时候会初始化一些监听器和初始化器；run方法调用的过程中会有对应的监听器监听，并且会创建Spring容器。&lt;/p&gt;
&lt;p&gt;Spring容器创建之后，会调用它的refresh方法，refresh的时候会做很多事情：比如完成配置类的解析、各种BeanFactoryPostProcessor和BeanPostProcessor的注册、国际化配置的初始化、web内置容器的构造等等。&lt;/p&gt;
&lt;p&gt;我们来分析一下这个refresh过程。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码分析之SpringBoot的启动过程</title>
    <link href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/"/>
    <id>http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/</id>
    <published>2017-04-30T12:33:33.000Z</published>
    <updated>2017-05-31T13:20:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot的启动很简单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(MyApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。</p>
<p>因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。</p>
<p>我们以上述这段代码为例，分析SpringBoot的启动过程。</p>
<a id="more"></a>
<h2 id="SpringApplication的构造过程"><a href="#SpringApplication的构造过程" class="headerlink" title="SpringApplication的构造过程"></a>SpringApplication的构造过程</h2><p>SpringApplication构造的时候内部会调用一个private方法initialize：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Object... sources)</span> </span>&#123;</div><div class="line">  initialize(sources); <span class="comment">// sources目前是一个MyApplication的class对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.sources.addAll(Arrays.asList(sources)); <span class="comment">// 把sources设置到SpringApplication的sources属性中，目前只是一个MyApplication类对象</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.webEnvironment = deduceWebEnvironment(); <span class="comment">// 判断是否是web程序(javax.servlet.Servlet和org.springframework.web.context.ConfigurableWebApplicationContext都必须在类加载器中存在)，并设置到webEnvironment属性中</span></div><div class="line">  <span class="comment">// 从spring.factories文件中找出key为ApplicationContextInitializer的类并实例化后设置到SpringApplication的initializers属性中。这个过程也就是找出所有的应用程序初始化器</span></div><div class="line">  setInitializers((Collection) getSpringFactoriesInstances(</div><div class="line">      ApplicationContextInitializer.class));</div><div class="line">  <span class="comment">// 从spring.factories文件中找出key为ApplicationListener的类并实例化后设置到SpringApplication的listeners属性中。这个过程就是找出所有的应用程序事件监听器</span></div><div class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</div><div class="line">  <span class="comment">// 找出main类，这里是MyApplication类</span></div><div class="line">  <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ApplicationContextInitializer，应用程序初始化器，做一些初始化的工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ApplicationListener，应用程序事件(ApplicationEvent)监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的应用程序事件(ApplicationEvent)有应用程序启动事件(ApplicationStartedEvent)，失败事件(ApplicationFailedEvent)，准备事件(ApplicationPreparedEvent)等。</p>
<p>应用程序事件监听器跟监听事件是绑定的。比如ConfigServerBootstrapApplicationListener只跟ApplicationEnvironmentPreparedEvent事件绑定，LiquibaseServiceLocatorApplicationListener只跟ApplicationStartedEvent事件绑定，LoggingApplicationListener跟所有事件绑定等。</p>
<p>默认情况下，initialize方法从spring.factories文件中找出的key为ApplicationContextInitializer的类有：</p>
<ol>
<li>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</li>
<li>org.springframework.boot.context.ContextIdApplicationContextInitializer</li>
<li>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</li>
<li>org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer</li>
<li>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</li>
</ol>
<p>key为ApplicationListener的有：</p>
<ol>
<li>org.springframework.boot.context.config.ConfigFileApplicationListener</li>
<li>org.springframework.boot.context.config.AnsiOutputApplicationListener</li>
<li>org.springframework.boot.logging.LoggingApplicationListener</li>
<li>org.springframework.boot.logging.ClasspathLoggingApplicationListener</li>
<li>org.springframework.boot.autoconfigure.BackgroundPreinitializer</li>
<li>org.springframework.boot.context.config.DelegatingApplicationListener</li>
<li>org.springframework.boot.builder.ParentContextCloserApplicationListener</li>
<li>org.springframework.boot.context.FileEncodingApplicationListener</li>
<li>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</li>
</ol>
<h2 id="SpringApplication的执行"><a href="#SpringApplication的执行" class="headerlink" title="SpringApplication的执行"></a>SpringApplication的执行</h2><p>分析run方法之前，先看一下SpringApplication中的一些事件和监听器概念。</p>
<p>首先是SpringApplicationRunListeners类和SpringApplicationRunListener类的介绍。</p>
<p>SpringApplicationRunListeners内部持有SpringApplicationRunListener集合和1个Log日志类。用于SpringApplicationRunListener监听器的批量执行。</p>
<p>SpringApplicationRunListener看名字也知道用于监听SpringApplication的run方法的执行。</p>
<p>它定义了5个步骤：</p>
<ol>
<li>started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartedEvent)</li>
<li>environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent)</li>
<li>contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件)</li>
<li>contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent)</li>
<li>finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent)</li>
</ol>
<p>SpringApplicationRunListener目前只有一个实现类EventPublishingRunListener，它把监听的过程封装成了SpringApplicationEvent事件并让内部属性(属性名为multicaster)ApplicationEventMulticaster接口的实现类SimpleApplicationEventMulticaster广播出去，广播出去的事件对象会被SpringApplication中的listeners属性进行处理。</p>
<p>所以说SpringApplicationRunListener和ApplicationListener之间的关系是通过ApplicationEventMulticaster广播出去的SpringApplicationEvent所联系起来的。</p>
<p><img src="http://7x2wh6.com1.z0.glb.clouddn.com/startup2.jpg" alt=""></p>
<p>SpringApplication的run方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch(); <span class="comment">// 构造一个任务执行观察器</span></div><div class="line">  stopWatch.start(); <span class="comment">// 开始执行，记录开始时间</span></div><div class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</div><div class="line">  configureHeadlessProperty();</div><div class="line">  <span class="comment">// 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener</span></div><div class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</div><div class="line">  <span class="comment">// 上面分析过，会封装成SpringApplicationEvent事件然后广播出去给SpringApplication中的listeners所监听</span></div><div class="line">  <span class="comment">// 这里接受ApplicationStartedEvent事件的listener会执行相应的操作</span></div><div class="line">  listeners.started();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 构造一个应用程序参数持有类</span></div><div class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</div><div class="line">        args);</div><div class="line">    <span class="comment">// 创建Spring容器</span></div><div class="line">    context = createAndRefreshContext(listeners, applicationArguments);</div><div class="line">    <span class="comment">// 容器创建完成之后执行额外一些操作</span></div><div class="line">    afterRefresh(context, applicationArguments);</div><div class="line">    <span class="comment">// 广播出ApplicationReadyEvent事件给相应的监听器执行</span></div><div class="line">    listeners.finished(context, <span class="keyword">null</span>);</div><div class="line">    stopWatch.stop(); <span class="comment">// 执行结束，记录执行时间</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</div><div class="line">          .logStarted(getApplicationLog(), stopWatch);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> context; <span class="comment">// 返回Spring容器</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">    handleRunFailure(context, listeners, ex); <span class="comment">// 这个过程报错的话会执行一些异常操作、然后广播出ApplicationFailedEvent事件给相应的监听器执行</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建容器的方法createAndRefreshContext如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title">createAndRefreshContext</span><span class="params">(</span></span></div><div class="line">    SpringApplicationRunListeners listeners,</div><div class="line">    ApplicationArguments applicationArguments) &#123;</div><div class="line">  ConfigurableApplicationContext context; <span class="comment">// 定义Spring容器</span></div><div class="line">  <span class="comment">// 创建应用程序的环境信息。如果是web程序，创建StandardServletEnvironment；否则，创建StandardEnvironment</span></div><div class="line">  ConfigurableEnvironment environment = getOrCreateEnvironment();</div><div class="line">  <span class="comment">// 配置一些环境信息。比如profile，命令行参数</span></div><div class="line">  configureEnvironment(environment, applicationArguments.getSourceArgs());</div><div class="line">  <span class="comment">// 广播出ApplicationEnvironmentPreparedEvent事件给相应的监听器执行</span></div><div class="line">  listeners.environmentPrepared(environment);</div><div class="line">  <span class="comment">// 环境信息的校对</span></div><div class="line">  <span class="keyword">if</span> (isWebEnvironment(environment) &amp;&amp; !<span class="keyword">this</span>.webEnvironment) &#123;</div><div class="line">    environment = convertToStandardEnvironment(environment);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode != Banner.Mode.OFF) &#123; <span class="comment">// 是否在控制台上打印自定义的banner</span></div><div class="line">    printBanner(environment);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create, load, refresh and run the ApplicationContext</span></div><div class="line">  context = createApplicationContext(); <span class="comment">// 创建Spring容器</span></div><div class="line">  context.setEnvironment(environment); <span class="comment">// 设置Spring容器的环境信息</span></div><div class="line">  postProcessApplicationContext(context); <span class="comment">// 回调方法，Spring容器创建之后做一些额外的事</span></div><div class="line">  applyInitializers(context); <span class="comment">// SpringApplication的的初始化器开始工作</span></div><div class="line">  <span class="comment">// 遍历调用SpringApplicationRunListener的contextPrepared方法。目前只是将这个事件广播器注册到Spring容器中</span></div><div class="line">  listeners.contextPrepared(context);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</div><div class="line">    logStartupInfo(context.getParent() == <span class="keyword">null</span>);</div><div class="line">    logStartupProfileInfo(context);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 把应用程序参数持有类注册到Spring容器中，并且是一个单例</span></div><div class="line">  context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</div><div class="line">      applicationArguments);</div><div class="line"></div><div class="line">  Set&lt;Object&gt; sources = getSources();</div><div class="line">  Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</div><div class="line">  load(context, sources.toArray(<span class="keyword">new</span> Object[sources.size()]));</div><div class="line">  <span class="comment">// 广播出ApplicationPreparedEvent事件给相应的监听器执行</span></div><div class="line">  listeners.contextLoaded(context);</div><div class="line"></div><div class="line">  <span class="comment">// Spring容器的刷新</span></div><div class="line">  refresh(context);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      context.registerShutdownHook();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</div><div class="line">      <span class="comment">// Not allowed in some environments.</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器的创建createApplicationContext方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">  Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</div><div class="line">  <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 如果是web程序，那么构造org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext容器</span></div><div class="line">      <span class="comment">// 否则构造org.springframework.context.annotation.AnnotationConfigApplicationContext容器</span></div><div class="line">      contextClass = Class.forName(<span class="keyword">this</span>.webEnvironment</div><div class="line">          ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">          <span class="string">"Unable create a default ApplicationContext, "</span></div><div class="line">              + <span class="string">"please specify an ApplicationContextClass"</span>,</div><div class="line">          ex);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器创建之后有个回调方法postProcessApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessApplicationContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.webEnvironment) &#123; <span class="comment">// 如果是web程序</span></div><div class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123; <span class="comment">// 并且也是Spring Web容器</span></div><div class="line">			ConfigurableWebApplicationContext configurableContext = (ConfigurableWebApplicationContext) context;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) &#123; <span class="comment">// 如果SpringApplication设置了是实例命名生成器，注册到Spring容器中</span></div><div class="line">				configurableContext.getBeanFactory().registerSingleton(</div><div class="line">						AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</div><div class="line">						<span class="keyword">this</span>.beanNameGenerator);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123; <span class="comment">// 如果SpringApplication设置了资源加载器，设置到Spring容器中</span></div><div class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> GenericApplicationContext) &#123;</div><div class="line">			((GenericApplicationContext) context)</div><div class="line">					.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> DefaultResourceLoader) &#123;</div><div class="line">			((DefaultResourceLoader) context)</div><div class="line">					.setClassLoader(<span class="keyword">this</span>.resourceLoader.getClassLoader());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化器做的工作，比如ContextIdApplicationContextInitializer会设置应用程序的id；AutoConfigurationReportLoggingInitializer会给应用程序添加一个条件注解解析器报告等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</div><div class="line">  <span class="comment">// 遍历每个初始化器，对调用对应的initialize方法</span></div><div class="line">  <span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;</div><div class="line">    Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</div><div class="line">        initializer.getClass(), ApplicationContextInitializer.class);</div><div class="line">    Assert.isInstanceOf(requiredType, context, <span class="string">"Unable to call initializer."</span>);</div><div class="line">    initializer.initialize(context);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器的刷新refresh方法内部会做很多很多的事情：比如BeanFactory的设置，BeanFactoryPostProcessor接口的执行、BeanPostProcessor接口的执行、自动化配置类的解析、条件注解的解析、国际化的初始化等等。这部分内容会在之后的文章中进行讲解。</p>
<p>run方法中的Spring容器创建完成之后会调用afterRefresh方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context,</span></span></div><div class="line">     ApplicationArguments args) &#123;</div><div class="line">   afterRefresh(context, args.getSourceArgs()); <span class="comment">// 目前是个空实现</span></div><div class="line">   callRunners(context, args); <span class="comment">// 调用Spring容器中的ApplicationRunner和CommandLineRunner接口的实现类</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</div><div class="line">	List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line">   <span class="comment">// 找出Spring容器中ApplicationRunner接口的实现类</span></div><div class="line">	runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</div><div class="line">   <span class="comment">// 找出Spring容器中CommandLineRunner接口的实现类</span></div><div class="line">	runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</div><div class="line">   <span class="comment">// 对runners进行排序</span></div><div class="line">	AnnotationAwareOrderComparator.sort(runners);</div><div class="line">   <span class="comment">// 遍历runners依次执行</span></div><div class="line">	<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</div><div class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123; <span class="comment">// 如果是ApplicationRunner，进行ApplicationRunner的run方法调用</span></div><div class="line">			callRunner((ApplicationRunner) runner, args);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123; <span class="comment">// 如果是CommandLineRunner，进行CommandLineRunner的run方法调用</span></div><div class="line">			callRunner((CommandLineRunner) runner, args);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样run方法执行完成之后。Spring容器也已经初始化完成，各种监听器和初始化器也做了相应的工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SpringBoot启动的时候，不论调用什么方法，都会构造一个SpringApplication的实例，然后调用这个实例的run方法，这样就表示启动SpringBoot。</p>
<p>在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事：</p>
<ol>
<li>把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数。本文的例子中这个sources就是MyApplication的class对象</li>
<li>判断是否是web程序，并设置到webEnvironment这个boolean属性中</li>
<li>找出所有的初始化器，默认有5个，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，默认有9个，设置到listeners属性中</li>
<li>找出运行的主类(main class)</li>
</ol>
<p>SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事：</p>
<ol>
<li>构造一个StopWatch，观察SpringApplication的执行</li>
<li>找出所有的SpringApplicationRunListener并封装到SpringApplicationRunListeners中，用于监听run方法的执行。监听的过程中会封装成事件并广播出去让初始化过程中产生的应用程序监听器进行监听</li>
<li>构造Spring容器(ApplicationContext)，并返回<br>3.1 创建Spring容器的判断是否是web环境，是的话构造AnnotationConfigEmbeddedWebApplicationContext，否则构造AnnotationConfigApplicationContext<br>3.2 初始化过程中产生的初始化器在这个时候开始工作<br>3.3 Spring容器的刷新(完成bean的解析、各种processor接口的执行、条件注解的解析等等)</li>
<li>从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>写了一个例子用来验证分析的启动逻辑，包括自定义的初始化器、监听器、ApplicationRunner和CommandLineRunner。</p>
<p>地址在：<a href="https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-startup" target="_blank" rel="external">https://github.com/fangjian0423/springboot-analysis/tree/master/springboot-startup</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot的启动很简单，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyApplication&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        SpringApplication.run(MyApplication.class, args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从代码上可以看出，调用了SpringApplication的静态方法run。这个run方法会构造一个SpringApplication的实例，然后再调用这里实例的run方法就表示启动SpringBoot。&lt;/p&gt;
&lt;p&gt;因此，想要分析SpringBoot的启动过程，我们需要熟悉SpringApplication的构造过程以及SpringApplication的run方法执行过程即可。&lt;/p&gt;
&lt;p&gt;我们以上述这段代码为例，分析SpringBoot的启动过程。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/categories/springboot/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="springboot" scheme="http://fangjian0423.github.io/tags/springboot/"/>
    
      <category term="springboot源码分析" scheme="http://fangjian0423.github.io/tags/springboot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>记录自己理解的一些设计模式</title>
    <link href="http://fangjian0423.github.io/2017/03/26/design-pattern/"/>
    <id>http://fangjian0423.github.io/2017/03/26/design-pattern/</id>
    <published>2017-03-26T07:33:29.000Z</published>
    <updated>2017-03-26T07:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下自己理解的一些设计模式，并尽量使用表达清楚的例子进行讲解。</p>
<a id="more"></a>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式应该是最基础的一个设计模式，它是对行为的一个抽象。jdk中的Comparator比较器就是一个使用策略设计模式的策略。</p>
<p>比如有一个Student学生类，有name和age两个属性。如果有个需求需要打印学生名单，并按照字母顺序排序，可以使用Comparator接口并在内部使用name进行比较即可。 如果哪一天需要按照年龄进行排序，那么只需要修改Comparator即可，也就是使用一个新的策略，其它完全不变。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式的意义在于对象的创建、管理可以使用工厂去管理，而不是创建者自身。最典型的工厂模式使用者就是Spring，Spring内部的容器就是一个工厂，所有的bean都由这个容器管理，包括它们的创建、销毁、注入都被这个容器管理。</p>
<p>工厂模式分简单工厂和抽象工厂。它们的区别在于抽象工厂抽象程度更高，把工厂也抽象成了一个接口，这样可以再每添加一个新的对象的时候而不需要修改工厂的代码。</p>
<p>比如有个Repository接口，用于存储数据，有DatabaseRepository，CacheRepository，FileRepository分别在数据库，缓存，文件中存储数据，定义如下：</p>
<pre><code>public interface Repository {
    void save(Object obj);
}

class DatabaseRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in database&quot;);
    }
}
class CacheRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in cache&quot;);
    }
}
class FileRepository implements Repository {
    @Override
    public void save(Object obj) {
        System.out.println(&quot;save in file&quot;);
    }
}
</code></pre><h3 id="简单工厂的使用"><a href="#简单工厂的使用" class="headerlink" title="简单工厂的使用"></a>简单工厂的使用</h3><pre><code>public class RepositoryFactory {

    public Repository create(String type) {
        Repository repository = null;
        switch (type) {
            case &quot;db&quot;:
                repository = new DatabaseRepository();
                break;
            case &quot;cache&quot;:
                repository = new CacheRepository();
                break;
            case &quot;file&quot;:
                repository = new FileRepository();
                break;
        }
        return repository;
    }

    public static void main(String[] args) {
        RepositoryFactory factory = new RepositoryFactory();
        factory.create(&quot;db&quot;).save(new Object());
        factory.create(&quot;cache&quot;).save(new Object());
        factory.create(&quot;file&quot;).save(new Object());
    }
}
</code></pre><p>简单工厂的弊端在于每添加一个新的Repository，都必须修改RepositoryFactory中的代码</p>
<h3 id="抽象工厂的使用"><a href="#抽象工厂的使用" class="headerlink" title="抽象工厂的使用"></a>抽象工厂的使用</h3><pre><code>public interface RepositoryFactoryProvider {
    Repository create();
}

class DatabaseRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new DatabaseRepository();
    }
}
class CacheRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new CacheRepository();
    }
}
class FileRepositoryFactory implements RepositoryFactoryProvider {
    @Override
    public Repository create() {
        return new FileRepository();
    }
}
</code></pre><p>抽象工厂的测试：</p>
<pre><code>RepositoryFactoryProvider dbProvider = new DatabaseRepositoryFactory();
dbProvider.create().save(new Object());
RepositoryFactoryProvider cacheProvider = new CacheRepositoryFactory();
cacheProvider.create().save(new Object());
RepositoryFactoryProvider fileProvider = new FileRepositoryFactory();
fileProvider.create().save(new Object());
</code></pre><p>抽象工厂把工厂也进行了抽象话，所以添加一个新的Repository的话，只需要新增一个RepositoryFactory即可，原有代码不需要修改。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式的作用就在于它可以在不改变原有类的基础上动态地给类添加新的功能。之前写过一篇<a href="http://www.cnblogs.com/fangjian0423/p/mybatis-cache.html" target="_blank" rel="external">通过源码分析MyBatis的缓存</a>文章，mybatis中的query就是使用了装饰者设计模式。</p>
<p>用一段简单的代码来模拟一下mybatis中query的实现原理：</p>
<pre><code>@Data
@AllArgsConstructor
@ToString
class Result { // 查询结果类，相当于一个domain
  private Object obj;
  private String sql;
}

public interface Query { // 查询接口，有简单查询和缓存查询
  Result query(String sql);
}

public class SimpleQuery implements Query { // 简单查询，相当于直接查询数据库，这里直接返回Result，相当于是数据库查询的结果
  @Override
  public Result query(String sql) {
      return new Result(new Object(), sql);
  }
}

public class CacheQuery implements Query { // 缓存查询，如果查询相同的sql，不直接查询数据库，而是返回map中存在的Result
  private Query query;
  private Map&lt;String, Result&gt; cache = new HashMap&lt;&gt;();
  public CacheQuery(Query query) {
      this.query = query;
  }
  @Override
  public Result query(String sql) {
      if(cache.containsKey(sql)) {
          return cache.get(sql);
      }
      Result result = query.query(sql);
      cache.put(sql, result);
      return result;
  }
}
</code></pre><p>测试：</p>
<pre><code>Query simpleQuery = new SimpleQuery();
System.out.println(simpleQuery.query(&quot;select * from t_student&quot;) == simpleQuery.query(&quot;select * from t_student&quot;)); // false
Query cacheQuery = new CacheQuery(simpleQuery);
System.out.println(cacheQuery.query(&quot;select * from t_student&quot;) == cacheQuery.query(&quot;select * from t_student&quot;)); // true
</code></pre><p>这里CacheQuery就是一个装饰类，SimpleQuery是一个被装饰者。我们通过装饰者设计模式动态地给SimpleQuery添加了缓存功能，而不需要修改SimpleQuery的代码。</p>
<p>当然，装饰者模式也有缺点，就是会存在太多的类。</p>
<p>如果我们需要添加一个过滤的查询(sql中有敏感字的就直接返回null，而不查询数据库)，只需要可以添加一个FilterQuery装饰者即可：</p>
<pre><code>public class FilterQuery implements Query {
    private Query query;
    private List&lt;String&gt; words = new ArrayList&lt;&gt;();
    public FilterQuery(Query query) {
        this.query = query;
        words.add(&quot;fuck&quot;);
        words.add(&quot;sex&quot;);
    }
    @Override
    public Result query(String sql) {
        for(String word : words) {
            if(sql.contains(word)) return null;
        }
        return query.query(sql);
    }
}

Query filterQuery = new FilterQuery(simpleQuery);
System.out.println(filterQuery.query(&quot;select * from t_student where name = &apos;fuck&apos;&quot;));  // null
System.out.println(filterQuery.query(&quot;select * from t_student where name = &apos;format&apos;&quot;)); // Result(obj=java.lang.Object@1b4fb997, sql=select * from t_student where name = &apos;format&apos;)
</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的作用是使用一个代理类来代替原先类进行操作。比较常见的就是aop中就是使用代理模式完成事务的处理。</p>
<p>代理模式分静态代理和动态代理，静态代理的原理就是对目标对象进行封装，最后调用目标对象的方法即可。</p>
<p>动态代理跟静态代理的区别就是动态代理中的代理类是程序运行的时候生成的。Spring中对于接口的代理使用jdk内置的Proxy和InvocationHandler实现，对于类的代理使用cglib完成。</p>
<p>以1个UserService为例，使用jdk自带的代理模式完成计算方法调用时间的需求：</p>
<pre><code>// UserService接口
public interface IUserService {
    void printAll();
}
// UserService实现类
class UserService implements IUserService {
    @Override
    public void printAll() {
        System.out.println(&quot;print all users&quot;);
    }
}
// InvocationHandler策略，这里打印了方法调用前后的时间
@AllArgsConstructor
class UserInvocationHandler implements InvocationHandler {
    private IUserService userService;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;start : &quot; + System.currentTimeMillis());
        Object result = method.invoke(userService, args);
        System.out.println(&quot;end : &quot; + System.currentTimeMillis());
        return result;
    }
}
</code></pre><p>测试：</p>
<pre><code>IUserService userService = new UserService();
UserInvocationHandler uih = new UserInvocationHandler(userService);
IUserService proxy = (IUserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), new Class[] {IUserService.class}, uih);
proxy.printAll(); // 打印出start : 1489665566456  print all users  end : 1489665566457
</code></pre><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式经常跟策略模式配合使用，用来组合所有的策略，并遍历这些策略找出满足条件的策略。之前写过一篇<a href="http://www.cnblogs.com/fangjian0423/p/springMVC-xml-json-convert.html" target="_blank" rel="external">SpringMVC关于json、xml自动转换的原理研究</a>文章，里面springmvc把返回的返回值映射给用户的response做了一层抽象，封装到了HandlerMethodReturnValueHandler策略接口中。</p>
<p>在HandlerMethodReturnValueHandlerComposite类中，使用存在的HandlerMethodReturnValueHandler对返回值进行处理，在HandlerMethodReturnValueHandlerComposite内部的代码如下：</p>
<pre><code>// 策略集合
private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;HandlerMethodReturnValueHandler&gt;();

@Override
public void handleReturnValue(Object returnValue, MethodParameter returnType,
    ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    // 调用selectHandler方法
    HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
    if (handler == null) {
      throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
    }
    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest); // 使用找到的handler进行处理
}

private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {
    boolean isAsyncValue = isAsyncReturnValue(value, returnType);
    // 遍历存在的HandlerMethodReturnValueHandler
    for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
      if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
        continue;
      }
      if (handler.supportsReturnType(returnType)) { // 找到匹配的handler
        return handler;
      }
    }
    return null;
}
</code></pre><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>跟策略模式类似，模板模式会先定义好实现的逻辑步骤，但是具体的实现方式由子类完成，跟策略模式的区别就是模板模式是有逻辑步骤的。比如要给院系里的学生排序，并取出排名第一的学生。这里就有2个步骤，分别是排序和取出第一名学生。</p>
<p>一段伪代码：</p>
<pre><code>public abstract class AbstractStudentGetter {
    public final Student getStudent(List&lt;Student&gt; students) {
        sort(students); // 第一步
        if(!CollectionUtils.isEmpty(students)) {
            return students.get(0);  // 第二步
        }
        return null;
    }
    abstract public void sort(List&lt;Student&gt; students);
}
class AgeStudentGetter extends AbstractStudentGetter { // 取出年纪最大的学生
    @Override
    public void sort(List&lt;Student&gt; students) {
        students.sort(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student s1, Student s2) {
                return s2.getAge() - s1.getAge();
            }
        });
    }
}
class NameStudentGetter extends AbstractStudentGetter { // 按照名字字母排序取出第一个学生
    @Override
    public void sort(List&lt;Student&gt; students) {
        students.sort(new Comparator&lt;Student&gt;() {
            @Override
            public int compare(Student s1, Student s2) {
                return s2.getName().compareTo(s1.getName());
            }
        });
    }
}
</code></pre><p>测试：</p>
<pre><code>AbstractStudentGetter ageGetter = new AgeStudentGetter();
AbstractStudentGetter nameGetter = new NameStudentGetter();

List&lt;Student&gt; students = new ArrayList&lt;&gt;();
students.add(new Student(&quot;jim&quot;, 22));
students.add(new Student(&quot;format&quot;, 25));

System.out.println(ageGetter.getStudent(students)); // Student(name=format, age=25)
System.out.println(nameGetter.getStudent(students)); // Student(name=jim, age=22)
</code></pre><h2 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h2><p>观察者设计模式主要的使用场景在于一个对象变化之后，依赖该对象的对象会收到通知。典型的例子就是rss的订阅，当订阅了博客的rss之后，当博客更新之后，订阅者就会收到新的订阅信息。</p>
<p>jdk内置提供了Observable和Observer，用来实现观察者模式：</p>
<pre><code>// 定义一个Observable
public class MetricsObserable extends Observable {
    private Map&lt;String, Long&gt; counterMap = new HashMap&lt;&gt;();
    public void updateCounter(String key, Long value) {
        counterMap.put(key, value);
        setChanged();
        notifyObservers(counterMap);
    }
}
// Observer
public class AdminA implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;adminA: &quot; + arg);
    }
}
public class AdminB implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;adminB: &quot; + arg);
    }
}
</code></pre><p>测试：</p>
<pre><code>MetricsObserable metricsObserable = new MetricsObserable();
metricsObserable.addObserver(new AdminA());
metricsObserable.addObserver(new AdminB());
metricsObserable.updateCounter(&quot;request-count&quot;, 100l);
</code></pre><p>打印出：</p>
<pre><code>adminB: {request-count=100}
adminA: {request-count=100}
</code></pre><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>线程池中会构造几个核心线程用于处理，这些线程会去取阻塞队列里的任务然后进行执行。这些线程就是会被共享、且被重复使用的。因为线程的创建、销毁、调度都是需要消耗资源的，没有必要每次创建新的线程，而是共用一些线程。这就是享元模式的使用。类似的还有jdbc连接池，对象池等。</p>
<p>之前有一次面试被问到：</p>
<pre><code>Integer.valueOf(&quot;1&quot;) == Integer.valueOf(&quot;1&quot;) // true还是false
</code></pre><p>当时回答的是false，后来翻了下Integer的源码发现Integer里面有个内部类IntegerCache，用于缓存一些共用的Integer。这个缓存的范围可以在jvm启动的时候进行设置。</p>
<p>其实后来想想也应该这么做，我们没有必要每次使用对象的时候都返回新的对象，可以共享这些对象，因为新对象的创建都是需要消耗内存的。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式比较好理解。像生活中插线口的插头有2个口的，也有3个口的。如果电脑的电源插口只有3个口的，但是我们需要一个2个口的插口的话，这个时候就需要使用插座来外接这个3个口的插头，插座上有2个口的插头。</p>
<p>这个例子跟我们编程一样，当用户系统的接口跟我们系统内部的接口不一致时，我们可以使用适配器来完成接口的转换。</p>
<p>使用继承的方式实现类的适配：</p>
<pre><code>public class Source {
    public void method() {
        System.out.println(&quot;source method&quot;);
    }
}
interface Targetable {
    void method();
    void newMethod();
}
class Adapter extends Source implements Targetable {
    @Override
    public void newMethod() {
        System.out.println(&quot;new method&quot;);
    }
}
</code></pre><p>测试：</p>
<pre><code>Targetable targetable = new Adapter();
targetable.method(); // source method
targetable.newMethod(); // new method
</code></pre><p>上述方式是用接口和继承的方式实现适配器模式。当然我们也可以使用组合的方式实现(把Source当成属性放到Adapter中)。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式比较好理解，Spring就是典型的例子。被Spring中的容器管理的对象都有对应的scope，配置成singleton说明这个对象就是单例，也就是在Spring容器的生命周期中，这个类只有1个实例。</p>
<p>java中单例模式的写法也有好多种。比如懒汉式、饿汉式、内部类方式、枚举方式等。</p>
<p>需要注意的如果使用dcl的话需要初始化过程，这篇<a href="http://cmsblogs.com/?p=2161&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="external">Java内存模型之从JMM角度分析DCL</a>文章中说明了dcl的正确用法。</p>
<p>Effectice java中推荐的单例方式写法是使用枚举类型的方式。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式用来包装一组接口用于方便使用。 比如系统中分10个模块，有个功能需要组合使用所有的模块，这个时候就需要一个包装类包装这10个接口，然后进行业务逻辑的调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下自己理解的一些设计模式，并尽量使用表达清楚的例子进行讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="architecture" scheme="http://fangjian0423.github.io/categories/architecture/"/>
    
    
      <category term="java" scheme="http://fangjian0423.github.io/tags/java/"/>
    
      <category term="architecture" scheme="http://fangjian0423.github.io/tags/architecture/"/>
    
  </entry>
  
</feed>
